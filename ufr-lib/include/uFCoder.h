/*
 * uFCoder.h
 *
 * library version: 6.128.10
 *
 * Created on:  2009-01-14
 * Last edited: 2024-10-25
 *
 * Author: D-Logic
 */
#ifndef uFCoder_H_
#define uFCoder_H_

#include <stdio.h>
#include <stdint.h>
#include <stddef.h>

#define IN  // array that you pass to function
#define OUT // array that you receive from function
#define VAR // first element of array that you receive from function (single variable)

////////////////////////////////////////////////////////////////////
/**
 * Type for representing null terminated char array ( aka C-String )
 * Array is always one byte longer ( for null character ) then string
 * Memory space for array must be allocated before use.
 */
typedef const char *c_string;
////////////////////////////////////////////////////////////////////

#ifdef _WIN32
// WINDOWS
#if defined(DL_CREATE_STATIC_LIB) || defined(DL_USE_STATIC_LIB)
#define DL_API
#else
#ifndef DL_uFC_EXPORTS
#ifdef _WIN_IOT
#define DL_API __declspec(dllimport) // Win IoT
#else
#define DL_API /*__declspec(dllimport) */ __stdcall // STDCALL - GCC - .NET
#endif                                              //  _WIN_IOT
#else
#define DL_API __declspec(dllexport) __stdcall
#endif // DL_uFC_EXPORTS
#endif // DL_CREATE_STATIC_LIB
#else
// Linux & MAC OS
#define DL_API
#endif // _WIN32

#if defined(DL_uFC_EXPORTS) || defined(DL_CREATE_STATIC_LIB) || defined(__ANDROID__) || defined(ESP_PLATFORM) || defined(IOS_PLATFORM)
typedef struct S_UFR_HANDLE *UFR_HANDLE;
#else
typedef void *UFR_HANDLE;
#endif

// MIFARE CLASSIC type id's:
#define MIFARE_CLASSIC_1k               0x08
#define MF1ICS50                        0x08
#define SLE66R35                        0x88 // Infineon = Mifare Classic 1k
#define MIFARE_CLASSIC_4k               0x18
#define MF1ICS70                        0x18
#define MIFARE_CLASSIC_MINI             0x09
#define MF1ICS20                        0x09

// DLOGIC CARD TYPE
#define TAG_UNKNOWN						0
#define DL_MIFARE_ULTRALIGHT			0x01
#define DL_MIFARE_ULTRALIGHT_EV1_11		0x02
#define DL_MIFARE_ULTRALIGHT_EV1_21		0x03
#define DL_MIFARE_ULTRALIGHT_C			0x04
#define DL_NTAG_203						0x05
#define DL_NTAG_210						0x06
#define DL_NTAG_212						0x07
#define DL_NTAG_213						0x08
#define DL_NTAG_215						0x09
#define DL_NTAG_216						0x0A
#define DL_MIKRON_MIK640D				0x0B
#define NFC_T2T_GENERIC					0x0C
#define DL_NT3H_1101                    0x0D
#define DL_NT3H_1201                    0x0E
#define DL_NT3H_2111                    0x0F
#define DL_NT3H_2211                    0x10
#define DL_NTAG_413_DNA                 0x11
#define DL_NTAG_424_DNA                 0x12
#define DL_NTAG_424_DNA_TT				0x13
#define DL_NTAG_210U                    0x14
#define DL_NTAG_213_TT                  0x15

#define DL_MIFARE_CLASSIC_2K 0x19
#define DL_MIFARE_MINI					0x20
#define	DL_MIFARE_CLASSIC_1K			0x21
#define DL_MIFARE_CLASSIC_4K			0x22
#define DL_MIFARE_PLUS_S_2K_SL0			0x23
#define DL_MIFARE_PLUS_S_4K_SL0			0x24
#define DL_MIFARE_PLUS_X_2K_SL0			0x25
#define DL_MIFARE_PLUS_X_4K_SL0			0x26
#define DL_MIFARE_DESFIRE				0x27
#define DL_MIFARE_DESFIRE_EV1_2K		0x28
#define DL_MIFARE_DESFIRE_EV1_4K		0x29
#define DL_MIFARE_DESFIRE_EV1_8K		0x2A
#define DL_MIFARE_DESFIRE_EV2_2K		0x2B
#define DL_MIFARE_DESFIRE_EV2_4K		0x2C
#define DL_MIFARE_DESFIRE_EV2_8K		0x2D
#define DL_MIFARE_PLUS_S_2K_SL1			0x2E
#define DL_MIFARE_PLUS_X_2K_SL1			0x2F
#define DL_MIFARE_PLUS_EV1_2K_SL1       0x30
#define DL_MIFARE_PLUS_X_2K_SL2			0x31
#define DL_MIFARE_PLUS_S_2K_SL3			0x32
#define DL_MIFARE_PLUS_X_2K_SL3			0x33
#define DL_MIFARE_PLUS_EV1_2K_SL3       0x34
#define DL_MIFARE_PLUS_S_4K_SL1			0x35
#define DL_MIFARE_PLUS_X_4K_SL1			0x36
#define DL_MIFARE_PLUS_EV1_4K_SL1       0x37
#define DL_MIFARE_PLUS_X_4K_SL2			0x38
#define DL_MIFARE_PLUS_S_4K_SL3			0x39
#define DL_MIFARE_PLUS_X_4K_SL3			0x3A
#define DL_MIFARE_PLUS_EV1_4K_SL3       0x3B
#define DL_MIFARE_PLUS_SE_SL0           0x3C
#define DL_MIFARE_PLUS_SE_SL1           0x3D
#define DL_MIFARE_PLUS_SE_SL3           0x3E
#define DL_MIFARE_DESFIRE_LIGHT         0x3F

#define DL_UNKNOWN_ISO_14443_4          0x40
#define DL_GENERIC_ISO14443_4           0x40
#define DL_GENERIC_ISO14443_4_TYPE_B    0x41
#define DL_GENERIC_ISO14443_3_TYPE_B    0x42
#define DL_MIFARE_PLUS_EV1_2K_SL0       0x43
#define DL_MIFARE_PLUS_EV1_4K_SL0       0x44
#define DL_MIFARE_DESFIRE_EV3_2K        0x45
#define DL_MIFARE_DESFIRE_EV3_4K        0x46
#define DL_MIFARE_DESFIRE_EV3_8K        0x47

#define DL_MOBILE_AID                   0x60
#define DL_APPLE_VAS_V1                 0x6A
#define DL_APPLE_VAS_V2                 0x6B
#define DL_IMEI_UID                     0x80

// ST Product ID-s:
#define M24SR02                         0x82
#define M24SR02_AUTOMOTIVE              0x8A
#define M24SR04                         0x86
#define M24SR04_AUTOMOTIVE              0x8E
#define M24SR16                         0x85
#define M24SR16_AUTOMOTIVE              0x8D
#define M24SR64                         0x84
#define M24SR64_AUTOMOTIVE              0x8C

// DLJavaCardTypes:
#define DLSigner81 0xA0
#define DLSigner22 0xA1
#define DLSigner30 0xA2
#define DLSigner10 0xA3
#define DLSigner145 0xAA

enum E_CARD_IN_SAM_SLOT
{
    SAM_SLOT_MIFARE_SAM_AV2 = 1,
    SAM_SLOT_GENERIC = 4
};

// DLJavaCardSignerAlgorithmTypes:
enum E_SIGNER_CIPHERS
{
    SIG_CIPHER_RSA = 0,
    SIG_CIPHER_ECDSA,

    SIG_CIPHER_MAX_SUPPORTED
};

enum E_SIGNER_RSA_PADDINGS
{
    PAD_NULL = 0,
    PAD_PKCS1_V1_5,
    PAD_PKCS1_PSS,

    SIG_PAD_MAX_SUPPORTED
};
#define PAD_PKCS1 PAD_PKCS1_V1_5

enum E_SIGNER_DIGESTS
{
    ALG_NULL = 0,
    ALG_SHA,
    ALG_SHA_256,
    ALG_SHA_384,
    ALG_SHA_512,
    ALG_SHA_224,
    ALG_SHA_512_224,
    ALG_SHA_512_256,

    SIG_DIGEST_MAX_SUPPORTED
};

enum E_KEY_TYPES
{
    TYPE_RSA_PRIVATE = 0,
    TYPE_RSA_CRT_PRIVATE,
    TYPE_EC_F2M_PRIVATE,
    TYPE_EC_FP_PRIVATE
};

enum E_OBJ_TYPES
{
    OBJ_TYPE_RSA_CERT = 0,
    OBJ_TYPE_EC_CERT,
    OBJ_TYPE_CA_CERT,

    OBJ_TYPES_COUNT
};

// JCDL_AIDs
#define DL_RAW_SIZEOF_SZ(x)	(sizeof(x) - 1)
#define DL_AID_RID_PLUS 	"\xF0" "DLogic"
#define DL_SIGNER_PIX		"\x00\x01"
#define DL_STORAGE_PIX		"\x01\x01"
#define DL_SIGNER_AID		DL_AID_RID_PLUS  DL_SIGNER_PIX
#define DL_SIGNER_AID_SIZE	9
#define DL_STORAGE_AID		DL_AID_RID_PLUS  DL_STORAGE_PIX
#define DL_STORAGE_AID_SIZE	9

// Universal JCDL instructions:
#define INS_LOGIN					0x20
#define INS_GET_PIN_TRIES_REMAINING 0x21
#define INS_PIN_CHANGE				0x22
#define INS_PIN_UNBLOCK				0x23

// JCDLStorage instructions:
#define INS_PIN_ENABLE				0x24
#define INS_PIN_DISABLE				0x25
#define INS_LIST_FILES				0x31
#define INS_GET_FILE_SIZE			0x32
#define INS_READ_FILE				0x33
#define INS_WRITE_FILE				0x34
#define INS_DELETE_FILE				0x3F

// JCDLSigner instructions:
#define INS_SET_RSA_PRIKEY			0x51
#define INS_GEN_RSA_KEY_PAIR		0x52
#define INS_GET_RSA_PUBKEY_MODULUS	0x53
#define INS_GET_RSA_PUBKEY_EXPONENT	0x54
#define INS_DEL_RSA_KEY_PAIR		0x5F
#define INS_SET_EC_PRIKEY			0x61
#define INS_GEN_EC_KEY_PAIR			0x62
#define INS_GET_EC_PUBKEY			0x63
#define INS_GET_EC_FIELD			0x64
#define INS_GET_EC_AB				0x65
#define INS_GET_EC_G				0x66
#define INS_GET_EC_RK_SIZE			0x67
#define INS_DEL_EC_KEY_PAIR			0x6F
#define INS_GET_SIGNATURE			0x71
#define INS_PUT_OBJ					0x31
#define INS_PUT_OBJ_SUBJECT			0x32
#define INS_INVALIDATE_CERT			0x33
#define INS_GET_OBJ					0x41
#define INS_GET_OBJ_ID				0x42
#define INS_GET_OBJ_SUBJECT			0x43

// Universal JCDL constants:
#define PIN_MAX_TRIES				5
#define PIN_MIN_LENGTH				4
#define PIN_MAX_LENGTH				8
#define PUK_MAX_TRIES				10
#define PUK_LENGTH					8

// JCDLSigner constants:
#define JC_APP_MAX_KEY_INDEX ((3) - 1)
#define JC_APP_MAX_CA_CERT_INDEX ((12) - 1)
#define JC_APP_MAX_ID_SIZE 253
#define JC_APP_MAX_SUBJECT_SIZE 255
#define JC_APP_MAX_SIGNATURE_LEN 256
#define JC_APP_MAX_PIN_LENGTH 8

// JCDLStorage constants:
#define JC_DL_STORAGE_MAX_FILES 16
#define JC_DL_STORAGE_MAX_FILE_SIZE (32 * 1024 - 2) // 32KB - 2 byte system reserved

// MIFARE CLASSIC Authentication Modes:
enum MIFARE_AUTHENTICATION
{
    MIFARE_AUTHENT1A = 0x60,
    MIFARE_AUTHENT1B = 0x61,
};

// MIFARE PLUS AES Authentication Modes:
enum MIFARE_PLUS_AES_AUTHENTICATION
{
    MIFARE_PLUS_AES_AUTHENT1A = 0x80,
    MIFARE_PLUS_AES_AUTHENT1B = 0x81,
};

enum MIFARE_PLUS_AES_KEY_TYPE
{
    MIFARE_PLUS_AES_KEY_A = 1,
    MIFARE_PLUS_AES_KEY_B = 2,
};

// T2T authentication constants:
enum T2T_AUTHENTICATION
{
    T2T_NO_PWD_AUTH = 0,
    T2T_RKA_PWD_AUTH = 1,
    T2T_PK_PWD_AUTH = 3,
    T2T_WITHOUT_PWD_AUTH = 0x60,
    T2T_WITH_PWD_AUTH = 0x61,
};

// T4T authentication constants
enum T4T_AUTHENTICATION
{
    T4T_WITHOUT_PWD_AUTH = 0x60,
    T4T_PK_PWD_AUTH = 0x80,
    T4T_RKA_PWD_AUTH = 0x02,
};

enum ADDRESS_MODE
{
    ADDRESS_MODE_BLOCK = 0,
    ADDRESS_MODE_SECTOR,
};

#define MAX_UID_LEN 10
#define MAX_ATS_LEN 25
#define ECC_SIG_LEN 32

// API Status Codes Type:
typedef enum UFCODER_ERROR_CODES
{
    UFR_OK = 0x00,
    UFR_COMMUNICATION_ERROR = 0x01,
    UFR_CHKSUM_ERROR = 0x02,
    UFR_READING_ERROR = 0x03,
    UFR_WRITING_ERROR = 0x04,
    UFR_BUFFER_OVERFLOW = 0x05,
    UFR_MAX_ADDRESS_EXCEEDED = 0x06,
    UFR_MAX_KEY_INDEX_EXCEEDED = 0x07,
    UFR_NO_CARD = 0x08,
    UFR_COMMAND_NOT_SUPPORTED = 0x09,
    UFR_FORBIDEN_DIRECT_WRITE_IN_SECTOR_TRAILER = 0x0A,
    UFR_ADDRESSED_BLOCK_IS_NOT_SECTOR_TRAILER = 0x0B,
    UFR_WRONG_ADDRESS_MODE = 0x0C,
    UFR_WRONG_ACCESS_BITS_VALUES = 0x0D,
    UFR_AUTH_ERROR = 0x0E,
    UFR_PARAMETERS_ERROR = 0x0F,
    UFR_MAX_SIZE_EXCEEDED = 0x10,
    UFR_UNSUPPORTED_CARD_TYPE = 0x11,

    UFR_COMMUNICATION_BREAK = 0x50,
    UFR_NO_MEMORY_ERROR = 0x51,
    UFR_CAN_NOT_OPEN_READER = 0x52,
    UFR_READER_NOT_SUPPORTED = 0x53,
    UFR_READER_OPENING_ERROR = 0x54,
    UFR_READER_PORT_NOT_OPENED = 0x55,
    UFR_CANT_CLOSE_READER_PORT = 0x56,
    UFR_BLE_INVALID_PAIRING = 0x57,

    UFR_I2C_BUS_ERROR = 0x6A,
    UFR_ECC_STORAGE_ERROR = 0x6B,

    UFR_WRITE_VERIFICATION_ERROR = 0x70,
    UFR_BUFFER_SIZE_EXCEEDED = 0x71,
    UFR_VALUE_BLOCK_INVALID = 0x72,
    UFR_VALUE_BLOCK_ADDR_INVALID = 0x73,
    UFR_VALUE_BLOCK_MANIPULATION_ERROR = 0x74,
    UFR_WRONG_UI_MODE = 0x75,
    UFR_KEYS_LOCKED = 0x76,
    UFR_KEYS_UNLOCKED = 0x77,
    UFR_WRONG_PASSWORD = 0x78,
    UFR_CAN_NOT_LOCK_DEVICE = 0x79,
    UFR_CAN_NOT_UNLOCK_DEVICE = 0x7A,
    UFR_DEVICE_EEPROM_BUSY = 0x7B,
    UFR_RTC_SET_ERROR = 0x7C,

    ANTI_COLLISION_DISABLED = 0x7D,
    NO_TAGS_ENUMERRATED = 0x7E,
    CARD_ALREADY_SELECTED = 0x7F,

    // NDEF error codes
    UFR_WRONG_NDEF_CARD_FORMAT = 0x80,
    UFR_NDEF_MESSAGE_NOT_FOUND = 0x81,
    UFR_NDEF_UNSUPPORTED_CARD_TYPE = 0x82,
    UFR_NDEF_CARD_FORMAT_ERROR = 0x83,
    UFR_MAD_NOT_ENABLED = 0x84,
    UFR_MAD_VERSION_NOT_SUPPORTED = 0x85,
    UFR_NDEF_MESSAGE_NOT_COMPATIBLE = 0x86,

    // Tag emulation mode errors:
    FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90,

    // FTDI errors:
    UFR_FT_STATUS_ERROR_1 = 0xA0,
    UFR_FT_STATUS_ERROR_2 = 0xA1,
    UFR_FT_STATUS_ERROR_3 = 0xA2,
    UFR_FT_STATUS_ERROR_4 = 0xA3,
    UFR_FT_STATUS_ERROR_5 = 0xA4,
    UFR_FT_STATUS_ERROR_6 = 0xA5,
    UFR_FT_STATUS_ERROR_7 = 0xA6,
    UFR_FT_STATUS_ERROR_8 = 0xA7,
    UFR_FT_STATUS_ERROR_9 = 0xA8,

    // MIFARE PLUS error codes
    UFR_MFP_COMMAND_OVERFLOW = 0xB0,
    UFR_MFP_INVALID_MAC = 0xB1,
    UFR_MFP_INVALID_BLOCK_NR = 0xB2,
    UFR_MFP_NOT_EXIST_BLOCK_NR = 0xB3,
    UFR_MFP_COND_OF_USE_ERROR = 0xB4,
    UFR_MFP_LENGTH_ERROR = 0xB5,
    UFR_MFP_GENERAL_MANIP_ERROR = 0xB6,
    UFR_MFP_SWITCH_TO_ISO14443_4_ERROR = 0xB7,
    UFR_MFP_ILLEGAL_STATUS_CODE = 0xB8,
    UFR_MFP_MULTI_BLOCKS_READ = 0xB9,

    // NT4H error codes
    NT4H_COMMAND_ABORTED = 0xC0,
    NT4H_LENGTH_ERROR = 0xC1,
    NT4H_PARAMETER_ERROR = 0xC2,
    NT4H_NO_SUCH_KEY = 0xC3,
    NT4H_PERMISSION_DENIED = 0xC4,
    NT4H_AUTHENTICATION_DELAY = 0xC5,
    NT4H_MEMORY_ERROR = 0xC6,
    NT4H_INTEGRITY_ERROR = 0xC7,
    NT4H_FILE_NOT_FOUND = 0xC8,
    NT4H_BOUNDARY_ERROR = 0xC9,
    NT4H_INVALID_MAC = 0xCA,
    NT4H_NO_CHANGES = 0xCB,

    // multiple units - return from the functions with ReaderList_ prefix in name
    UFR_DEVICE_WRONG_HANDLE = 0x100,
    UFR_DEVICE_INDEX_OUT_OF_BOUND,
    UFR_DEVICE_ALREADY_OPENED,
    UFR_DEVICE_ALREADY_CLOSED,
    UFR_DEVICE_IS_NOT_CONNECTED,

    // Originality Check Error Codes:
    UFR_NOT_NXP_GENUINE = 0x200,
    UFR_OPEN_SSL_DYNAMIC_LIB_FAILED,
    UFR_OPEN_SSL_DYNAMIC_LIB_NOT_FOUND,

    // DESFIRE Card Status Error Codes:
    READER_ERROR = 0xBB7,                // 2999 [dec]
    NO_CARD_DETECTED = 0xBB8,            // 3000 [dec]
    CARD_OPERATION_OK = 0xBB9,           // 3001 [dec]
    WRONG_KEY_TYPE = 0xBBA,              // 3002 [dec]
    KEY_AUTH_ERROR = 0xBBB,              // 3003 [dec]
    CARD_CRYPTO_ERROR = 0xBBC,           // 3004 [dec]
    READER_CARD_COMM_ERROR = 0xBBD,      // 3005 [dec]
    PC_READER_COMM_ERROR = 0xBBE,        // 3006 [dec]
    COMMIT_TRANSACTION_NO_REPLY = 0xBBF, // 3007 [dec]
    COMMIT_TRANSACTION_ERROR = 0xBC0,    // 3008 [dec]
    NOT_SUPPORTED_KEY_TYPE = 0xBC2,      // 3010 [dec]
    WRONG_FILE_TYPE = 0xBC3,             // 3011 [dec]

    DESFIRE_CARD_NO_CHANGES = 0x0C0C,
    DESFIRE_CARD_OUT_OF_EEPROM_ERROR = 0x0C0E,
    DESFIRE_CARD_ILLEGAL_COMMAND_CODE = 0x0C1C,
    DESFIRE_CARD_INTEGRITY_ERROR = 0x0C1E,
    DESFIRE_CARD_NO_SUCH_KEY = 0x0C40,
    DESFIRE_CARD_LENGTH_ERROR = 0x0C7E,
    DESFIRE_CARD_PERMISSION_DENIED = 0x0C9D,
    DESFIRE_CARD_PARAMETER_ERROR = 0x0C9E,
    DESFIRE_CARD_APPLICATION_NOT_FOUND = 0x0CA0,
    DESFIRE_CARD_APPL_INTEGRITY_ERROR = 0x0CA1,
    DESFIRE_CARD_AUTHENTICATION_ERROR = 0x0CAE,
    DESFIRE_CARD_ADDITIONAL_FRAME = 0x0CAF,
    DESFIRE_CARD_BOUNDARY_ERROR = 0x0CBE,
    DESFIRE_CARD_PICC_INTEGRITY_ERROR = 0x0CC1,
    DESFIRE_CARD_COMMAND_ABORTED = 0x0CCA,
    DESFIRE_CARD_PICC_DISABLED_ERROR = 0x0CCD,
    DESFIRE_CARD_COUNT_ERROR = 0x0CCE,
    DESFIRE_CARD_DUPLICATE_ERROR = 0x0CDE,
    DESFIRE_CARD_EEPROM_ERROR_DES = 0x0CEE,
    DESFIRE_CARD_FILE_NOT_FOUND = 0x0CF0,
    DESFIRE_CARD_FILE_INTEGRITY_ERROR = 0x0CF1,
    DESFIRE_CATD_AUTHENTICATION_DELAY = 0X0CAD,

    // uFCoder library errors:
    UFR_NOT_IMPLEMENTED = 0x1000,
    UFR_COMMAND_FAILED = 0x1001,
    UFR_TIMEOUT_ERR = 0x1002,
    UFR_FILE_SYSTEM_ERROR = 0x1003,
    UFR_FILE_SYSTEM_PATH_NOT_EXISTS = 0x1004,
    UFR_FILE_NOT_EXISTS = 0x1005,

    // uFCoder library/licensing specific
    UFR_JSON_INVALID = 0x1012,
    UFR_LICENSE_INVALID = 0x1013,
    UFR_LICENSE_SAVE_FAILED = 0x1014,
    UFR_LICENSE_NOT_FOUND = 0x1015,
    UFR_LICENSE_HAS_EXPIRED = 0x1016,

    // SAM module error codes:
    UFR_SAM_APDU_ERROR = 0x2000,
    UFR_SAM_AUTH_ERROR,
    UFR_SAM_CRYPTO_ERROR,

    // TLS, HTTPS Error Codes:
    TLS_ERR_OPENING_SOCKET = 0x5000,
    TLS_ERR_NO_SUCH_HOST = 0x5001,
    TLS_CONNECTING_ERROR = 0x5002,
    TLS_ERR_SERVER_UNEXPECTEDLY_CLOSED_CONNECTION = 0x5003,
    TLS_ERR_UNKNOWN_GIDS_CERTIFICATE_FORMAT = 0x5004,
    TLS_ERR_SET_PIN_FOR_GIDS_CERT_ONLY = 0x5005,
    TLS_ERR_GIDS_PIN_CODE_WRONG = 0x5006,
    TLS_ERR_UNSUPPORTED_CERTIFICATE_TYPE = 0x5007,
    TLS_ERR_PRIVATE_KEY_CONTEXT_WRONG = 0x5008,

    // JC cards APDU Error Codes:
    UFR_APDU_TRANSCEIVE_ERROR = 0xAE,
    UFR_APDU_JC_APP_NOT_SELECTED = 0x6000,
    UFR_APDU_JC_APP_BUFF_EMPTY = 0x6001,
    UFR_APDU_WRONG_SELECT_RESPONSE = 0x6002,
    UFR_APDU_WRONG_KEY_TYPE = 0x6003,
    UFR_APDU_WRONG_KEY_SIZE = 0x6004,
    UFR_APDU_WRONG_KEY_PARAMS = 0x6005,
    UFR_APDU_WRONG_SIGNING_ALGORITHM = 0x6006,
    UFR_APDU_PLAIN_TEXT_MAX_SIZE_EXCEEDED = 0x6007,
    UFR_APDU_UNSUPPORTED_KEY_SIZE = 0x6008,
    UFR_APDU_UNSUPPORTED_ALGORITHMS = 0x6009,
    UFR_APDU_PKI_OBJECT_NOT_FOUND = 0x600A,
    UFR_APDU_MAX_PIN_LENGTH_EXCEEDED = 0x600B,
    UFR_DIGEST_LENGTH_DOES_NOT_MATCH = 0x600C,

    // reserved: 0x6100,
    CRYPTO_SUBSYS_NOT_INITIALIZED = 0x6101,
    CRYPTO_SUBSYS_SIGNATURE_VERIFICATION_ERROR = 0x6102,
    CRYPTO_SUBSYS_MAX_HASH_INPUT_EXCEEDED = 0x6103,
    CRYPTO_SUBSYS_INVALID_HASH_ALGORITHM = 0x6104,
    CRYPTO_SUBSYS_INVALID_CIPHER_ALGORITHM = 0x6105,
    CRYPTO_SUBSYS_INVALID_PADDING_ALGORITHM = 0x6106,
    CRYPTO_SUBSYS_WRONG_SIGNATURE = 0x6107,
    CRYPTO_SUBSYS_WRONG_HASH_OUTPUT_LENGTH = 0x6108,
    CRYPTO_SUBSYS_UNKNOWN_ECC_CURVE = 0x6109,
    CRYPTO_SUBSYS_HASHING_ERROR = 0x610A,
    CRYPTO_SUBSYS_INVALID_SIGNATURE_PARAMS = 0x610B,
    CRYPTO_SUBSYS_INVALID_RSA_PUB_KEY = 0x610C,
    CRYPTO_SUBSYS_INVALID_ECC_PUB_KEY_PARAMS = 0x610D,
    CRYPTO_SUBSYS_INVALID_ECC_PUB_KEY = 0x610E,

    UFR_WRONG_PEM_CERT_FORMAT = 0x61C0,

    // X.509 specific statuses:
    X509_CAN_NOT_OPEN_FILE = 0x6200,
    X509_WRONG_DATA = 0x6201,
    X509_WRONG_LENGTH = 0x6202,
    X509_UNSUPPORTED_PUBLIC_KEY_TYPE = 0x6203,
    X509_UNSUPPORTED_PUBLIC_KEY_SIZE = 0x6204,
    X509_UNSUPPORTED_PUBLIC_KEY_EXPONENT = 0x6205,
    X509_EXTENSION_NOT_FOUND = 0x6206,
    X509_WRONG_SIGNATURE = 0x6207,
    X509_UNKNOWN_PUBLIC_KEY_TYPE = 0x6208,
    X509_WRONG_RSA_PUBLIC_KEY_FORMAT = 0x6209,
    X509_WRONG_ECC_PUBLIC_KEY_FORMAT = 0x620A,
    X509_SIGNATURE_NOT_MATCH_CA_PUBLIC_KEY = 0x620B,
    X509_UNSUPPORTED_SIGNATURE_SCH = 0x620C,
    X509_UNSUPPORTED_ECC_CURVE = 0x620D,

    // PKCS#7 specific statuses:
    PKCS7_WRONG_DATA = 0x6241,
    PKCS7_UNSUPPORTED_SIGNATURE_SCHEME = 0x6242,
    PKCS7_SIG_SCH_NOT_MATCH_CERT_KEY_TYPE = 0x6243,

    PKCS7_WRONG_SIGNATURE = 0x6247,

    // MRTD specific statuses:
    MRTD_SECURE_CHANNEL_SESSION_FAILED = 0x6280,
    MRTD_WRONG_SOD_DATA = 0x6281,
    MRTD_WRONG_SOD_LENGTH = 0x6282,
    MRTD_UNKNOWN_DIGEST_ALGORITHM = 0x6283,
    MRTD_WARNING_DOES_NOT_CONTAINS_DS_CERT = 0x6284,
    MRTD_DATA_GROUOP_INDEX_NOT_EXIST = 0x6285,
    MRTD_EF_COM_WRONG_DATA = 0x6286,
    MRTD_EF_DG_WRONG_DATA = 0x6287,
    MRTD_EF_DG1_WRONG_LDS_VERSION_LENGTH = 0x6288,
    MRTD_VERIFY_CSCA_NOT_EXIST = 0x6289,
    MRTD_VERIFY_WRONG_DS_SIGNATURE = 0x628A,
    MRTD_VERIFY_WRONG_CSCA_SIGNATURE = 0x628B,
    MRTD_MRZ_CHECK_ERROR = 0x628C,

    // ICAO Master List specific statuses:
    ICAO_ML_WRONG_FORMAT = 0x6300,
    ICAO_ML_CAN_NOT_OPEN_FILE = 0x6301,
    ICAO_ML_CAN_NOT_READ_FILE = 0x6302,
    ICAO_ML_CERTIFICATE_NOT_FOUND = 0x6303,
    ICAO_ML_WRONG_SIGNATURE = 0x6307,

    // EMV specific statuses
    SYS_ERR_OUT_OF_MEMORY = 0x7001,
    EMV_ERR_WRONG_INPUT_DATA = 0x7002,
    EMV_ERR_MAX_TAG_LEN_BYTES_EXCEEDED = 0x7004,
    EMV_ERR_TAG_NOT_FOUND = 0x7005,
    EMV_ERR_TAG_WRONG_SIZE = 0x7006,
    EMV_ERR_TAG_WRONG_TYPE = 0x7007,
    EMV_ERR_IN_CARD_READER = 0x7008,
    EMV_ERR_READING_RECORD = 0x7009,
    EMV_ERR_PDOL_IS_EMPTY = 0x7010,
    EMV_ERR_LIST_FORMAT_NOT_FOUND = 0x7011,
    EMV_ERR_AFL_NOT_FOUND = 0x7012,
    EMV_ERR_AID_NOT_FOUND = 0x7013,

    // ISO7816-4 Errors (R-APDU) - 2 SW bytes returned by the card, prefixed with 0x000A:
    UFR_APDU_SW_TAG = 0x000A0000,
    UFR_APDU_SW_OPERATION_IS_FAILED = 0x000A6300,
    UFR_APDU_SW_WRONG_PIN_4_TRIES_REMAINING = 0x000A63C4,
    UFR_APDU_SW_WRONG_PIN_3_TRIES_REMAINING = 0x000A63C3,
    UFR_APDU_SW_WRONG_PIN_2_TRIES_REMAINING = 0x000A63C2,
    UFR_APDU_SW_WRONG_PIN_1_TRIES_REMAINING = 0x000A63C1,
    UFR_APDU_SW_WRONG_PIN_0_TRIES_REMAINING = 0x000A63C0,
    UFR_APDU_SW_WRONG_LENGTH = 0x000A6700,
    UFR_APDU_SW_SECURITY_STATUS_NOT_SATISFIED = 0x000A6982,
    UFR_APDU_SW_AUTHENTICATION_METHOD_BLOCKED = 0x000A6983,
    UFR_APDU_SW_DATA_INVALID = 0x000A6984,
    UFR_APDU_SW_CONDITIONS_NOT_SATISFIED = 0x000A6985,
    UFR_APDU_SW_WRONG_DATA = 0x000A6A80,
    UFR_APDU_SW_FILE_NOT_FOUND = 0x000A6A82,
    UFR_APDU_SW_RECORD_NOT_FOUND = 0x000A6A83,
    UFR_APDU_SW_DATA_NOT_FOUND = 0x000A6A88,
    UFR_APDU_SW_ENTITY_ALREADY_EXISTS = 0x000A6A89,
    UFR_APDU_SW_INS_NOT_SUPPORTED = 0x000A6D00,
    UFR_APDU_SW_NO_PRECISE_DIAGNOSTIC = 0x000A6F00,

    MAX_UFR_STATUS = 0x7FFFFFFF

} UFR_STATUS;

typedef enum UFCODER_SESSION_CODES
{
    UFR_SESSION_UNKNOWN_ERROR = 0x00,
    UFR_SESSION_CLOSED = 0x01,
    UFR_SESSION_EXPIRED = 0x02,
    UFR_SESSION_DEVICE_DISCONNECTED = 0x03,
    UFR_SESSION_DEVICE_FAILED_TO_CONNECT = 0x04,

    // BLE specific error codes
    UFR_BLE_SESSION_ERROR_INVALID_PARAMETERS = 0x11,
    UFR_BLE_SESSION_ERROR_INVALID_HANDLE = 0x12,
    UFR_BLE_SESSION_ERROR_NOT_CONNECTED = 0x13,
    UFR_BLE_SESSION_ERROR_OUT_OF_SPACE = 0x14,
    UFR_BLE_SESSION_ERROR_OPERATION_CANCELLED = 0x15,
    UFR_BLE_SESSION_ERROR_CONNECTION_TIMEOUT = 0x16,
    UFR_BLE_SESSION_ERROR_UUID_NOT_ALLOWED = 0x17,
    UFR_BLE_SESSION_ERROR_ALREADY_ADVERTISING = 0x18,
    UFR_BLE_SESSION_ERROR_CONNECTION_LIMIT_REACHED = 0x19,
    UFR_BLE_SESSION_ERROR_UNKNOWN_DEVICE = 0x20,
    UFR_BLE_SESSION_ERROR_OPERATION_NOT_SUPPORTED = 0x21,
    UFR_BLE_SESSION_ERROR_PEER_REMOVED_PAIRING_INFORMATION = 0x22,
    UFR_BLE_SESSION_ERROR_ENCRYPTION_TIMED_OUT = 0x23,
    UFR_BLE_SESSION_ERROR_TOO_MANY_LE_PAIRED_DEVICES = 0x24,

    // NFC specific error codes

    // Sesssion errors
    UFR_NFC_SESSION_ERROR_FIRST_NDEF_TAG_READ = 0x30,
    UFR_NFC_SESSION_ERROR_SESSION_INVALIDATION_TERMINATED_UNEXPECTEDLY = 0x31,
    UFR_NFC_SESSION_ERROR_SESSION_INVALIDATION_TIMEOUT = 0x32,
    UFR_NFC_SESSION_ERROR_SESSION_INVALIDATION_SYSTEM_IS_BUSY = 0x33,
    UFR_NFC_SESSION_ERROR_SESSION_INVALIDATION_USER_CANCELED = 0x34,

    // NDEF errors
    UFR_NFC_SESSION_ERROR_TAG_NOT_WRITABLE = 0x40, 
    UFR_NFC_SESSION_ERROR_TAG_SIZE_TOO_SMALL = 0x41,
    UFR_NFC_SESSION_ERROR_TAG_UPDATE_FAILURE = 0x42,
    UFR_NFC_SESSION_ERROR_ZERO_LENGTH_MESSAGE = 0x43,

    // Transceive errors
    UFR_NFC_SESSION_ERROR_RETRY_EXCEEDED = 0x50,
    UFR_NFC_SESSION_ERROR_TAG_CONNECTION_LOST = 0x51,
    UFR_NFC_SESSION_ERROR_TAG_NOT_CONNECTED = 0x52,
    UFR_NFC_SESSION_ERROR_TAG_RESPONSE_ERROR = 0x53,
    UFR_NFC_SESSION_ERROR_TAG_TRANSCEIVE_SESSION_INVALIDATED = 0x54,
    UFR_NFC_SESSION_ERROR_TAG_TRANSCEIVE_PACKET_TOO_LONG = 0x55,

    UFR_NFC_SESSION_ERROR_TAG_COMMAND_CONFIGURATION_INVALID_PARAMETERS = 0x56,

    // Other
    UFR_NFC_SESSION_ERROR_UNSUPPORTED_FEATURE = 0x61,
    UFR_NFC_SESSION_ERROR_INVALID_PARAMETER = 0x62,
    UFR_NFC_SESSION_ERROR_INVALID_PARAMETER_LENGTH = 0x63,
    UFR_NFC_SESSION_ERROR_PARAMETER_OUT_OF_BOUNDS = 0x64,
    UFR_NFC_SESSION_ERROR_RADIO_DISABLED = 0x65,
    UFR_NFC_SESSION_ERROR_SECURITY_VIOLATION = 0x66,

} UFR_SESSION_STATUS;

// DESFIRE key settings values
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_CHANGE_KEY_CHANGE 0x09
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_CHANGE_KEY_CHANGE 0x0F
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_NOT_CHANGE_KEY_CHANGE 0x01
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_NOT_CHANGE_KEY_CHANGE 0x07
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_CHANGE_KEY_NOT_CHANGE 0x08
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_CHANGE_KEY_NOT_CHANGE 0x0E
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_NOT_CHANGE_KEY_NOT_CHANGE 0x00
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_NOT_CHANGE_KEY_NOT_CHANGE 0x06

#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_NOT_CHANGE_KEY_NOT_CHANGE_APP_IDS_WITH_AUTH 0x00
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_NOT_CHANGE_KEY_CHANGE_APP_IDS_WITH_AUTH 0x01
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_NOT_CHANGE_KEY_NOT_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x02
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_NOT_CHANGE_KEY_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x03
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_NOT_CHANGE_KEY_NOT_CHANGE_APP_IDS_WITH_AUTH 0x04
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_NOT_CHANGE_KEY_CHANGE_APP_IDS_WITH_AUTH 0x05
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_NOT_CHANGE_KEY_NOT_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x06
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_NOT_CHANGE_KEY_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x07
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_CHANGE_KEY_NOT_CHANGE_APP_IDS_WITH_AUTH 0x08
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_CHANGE_KEY_CHANGE_APP_IDS_WITH_AUTH 0x09
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_CHANGE_KEY_NOT_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x0A
#define DESFIRE_KEY_SET_CREATE_WITH_AUTH_SET_CHANGE_KEY_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x0B
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_CHANGE_KEY_NOT_CHANGE_APP_IDS_WIDTH_AUTH 0x0C
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_CHANGE_KEY_CHANGE_APP_IDS_WIDTH_AUTH 0x0D
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_CHANGE_KEY_NOT_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x0E
#define DESFIRE_KEY_SET_CREATE_WITHOUT_AUTH_SET_CHANGE_KEY_CHANGE_APP_IDS_WIDTHOUT_AUTH 0x0F

enum E_ASYMMETRIC_KEY_TYPES
{
    RSA_PRIVATE_KEY = 0,
    ECDSA_PRIVATE_KEY,

    ASYMMETRIC_KEY_TYPES_NUM
};

#define MAX_ECC_CURVE_NAME_LEN 30

enum E_ECC_CURVE_DEFINITION_TYPES
{
    ECC_CURVE_INDEX,
    ECC_CURVE_NAME,
    ECC_CURVE_DOMAIN_PARAMETERS,

    ECC_CURVE_DEFINITION_TYPES_NUM
};

enum E_SIGNATURE_SCHEMES
{
    SHA1_WITH_RSA,
    SHA256_WITH_RSA,
    SHA384_WITH_RSA,
    SHA512_WITH_RSA,
    SHA224_WITH_RSA,
    SHA512_224_WITH_RSA,
    SHA512_256_WITH_RSA,

    RSA_PSS,

    ECDSA_WITH_SHA1,
    ECDSA_WITH_SHA256,
    ECDSA_WITH_SHA384,
    ECDSA_WITH_SHA512,
    ECDSA_WITH_SHA224,

    SIGNATURE_SCHEMES_NUM // Don't change the order. NEVER!
};
enum E_SIGNATURE_SCH_TYPES
{
    RSA_PKCS1,
    RSA_PKCS1_PSS,
    ECDSA,

    SIGNATURE_SCH_TYPES_NUM
};
enum E_PUB_KEY_TYPES
{
    PUB_KEY_TYPE_RSA,
    PUB_KEY_TYPE_ECDSA_NAMED_CURVE,
    PUB_KEY_TYPE_ECDSA_DOMAIN_PARAMS,

    PUB_KEY_TYPES_NUM
};

enum E_BIT_ENCODINGS
{
    ENCODING_BIN,
    ENCODING_HEX
};

enum E_CERTIFICATE_TYPES
{
    X509_PEM,
    X509_DER,
    X509_GIDS_NFC,

    E_CERTIFICATE_TYPES_NUM
};

enum E_ECC_CURVES
{
    secp112r1,
    secp112r2,
    secp128r1,
    secp128r2,
    secp160r1,
    secp160r2,
    secp160k1,
    secp192r1,
    prime192v2,
    prime192v3,
    secp192k1,
    secp224r1,
    secp224k1,
    secp256r1,
    secp256k1,
    secp384r1,
    secp521r1,
    prime239v1,
    prime239v2,
    prime239v3,
    brainpoolP160r1,
    brainpoolP192r1,
    brainpoolP224r1,
    brainpoolP256r1,
    brainpoolP320r1,
    brainpoolP384r1,
    brainpoolP512r1,
    brainpoolP160t1,
    brainpoolP192t1,
    brainpoolP224t1,
    brainpoolP256t1,
    brainpoolP320t1,
    brainpoolP384t1,
    brainpoolP512t1,

    ECC_CURVES_NUM

    /* Not supported in uFCoder library yet:
     sect113r1,
     sect113r2,
     sect131r1,
     sect131r2,
     sect163k1,
     sect163r1,
     sect163r2,
     sect193r1,
     sect193r2,
     sect233k1,
     sect233r1,
     sect239k1,
     sect283k1,
     sect283r1,
     sect409k1,
     sect409r1,
     sect571k1,
     sect571r1
    */
};
// #define F2M_CURVES sect113r1

typedef struct
{
    uint8_t *serial;
    uint8_t *subject;
    uint8_t *issuer;
    uint8_t *SKI;
    uint8_t *AKI;
    uint32_t serial_len;
    uint32_t subject_len;
    uint32_t issuer_len;
    uint32_t SKI_len;
    uint32_t AKI_len;
} icaoMlSearchCriteria_t;

typedef struct
{
    uint32_t ecc_curve_field_type;
    void *field_domain_params; // To be defined. For now only a named primary field curves are supported.
} ecc_curve_domain_params_t;

typedef struct
{
    uint32_t ecc_curve_definition_type; // one of the E_ECC_CURVE_DEFINITION_TYPES
    uint32_t ecc_curve_index;
    char *ecc_curve_name;
    ecc_curve_domain_params_t *ecc_curve_domain_params;
} ecc_key_param_t;

enum E_MRTD_IMG_TYPE
{
    MRTD_IMG_JPEG = 0,
    MRTD_IMG_JP2 = 1,
    MRTD_IMG_JPEG2000 = 1, // Alias for the MRTD_IMG_JP2

    MRTD_IMG_TYPE_UNKNOWN = 0xFFFFFFFF
};

typedef enum
{
    USER_PIN = 0,
    SO_PIN,
    USER_PUK,
    SO_PUK
} dl_sec_code_t;

enum E_PRINT_VERBOSE_LEVELS
{
    PRINT_NONE,
    PRINT_ESSENTIALS,
    PRINT_DETAILS,
    PRINT_ALL_PLUS_STATUSES,
};

// SAM definition
typedef enum E_SAM_HW_VER
{
    SAM_UNKNOWN_TYPE,
    SAM_T1AD2060_AV1_MODE,
    SAM_T1AD2060_AV2_MODE,
    SAM_T1AR1070_AV1_MODE,
    SAM_T1AR1070_AV2_MODE
} SAM_HW_TYPE;

// Reader status
typedef enum E_EMULATION_MODES
{
    TAG_EMU_DISABLED,
    TAG_EMU_DEDICATED,
    TAG_EMU_COMBINED,
    TAG_EMU_AUTO_AD_HOC
} emul_modes_t;

typedef enum E_EMULATION_STATES
{
    EMULATION_NONE,
    EMULATION_IDLE,
    EMULATION_AUTO_COLL,
    EMULATION_ACTIVE,
    EMULATION_HALT,
    EMULATION_POWER_OFF
} emul_states_t;

typedef enum E_PCD_MGR_STATES
{
    PCD_MGR_NO_RF_GENERATED,
    PCD_MGR_14443A_POLLING,
    PCD_MGR_14443A_SELECTED,
    PCD_MGR_CE_DEDICATED,
    PCD_MGR_CE_COMBO_START,
    PCD_MGR_CE_COMBO,
    PCD_MGR_CE_COMBO_IN_FIELD
} pcd_states_t;

enum E_RGB_PORT_NAMES
{
    EXTERNAL_RGB_PORT,
    INTERNAL_RGB_PORT
};

enum E_CUSTOM_UI_IDLE_MODES
{
    CUSTOM_UI_IDLE_MODE_NONE = 0,
    CUSTOM_UI_IDLE_MODE_STATIC_LED,
    CUSTOM_UI_IDLE_MODE_BLINKING_LED,
    CUSTOM_UI_IDLE_MODES_NUMBER_INDICATOR
};

enum E_CUSTOM_UI_DETECTED_MODES
{
    CUSTOM_UI_DETECTED_MODE_NONE = 0,
    CUSTOM_UI_DETECTED_MODE_STATIC_LED,
    CUSTOM_UI_DETECTED_MODE_STATIC_LED_BEEP,
    CUSTOM_UI_DETECTED_MODE_BEEP,
    CUSTOM_UI_DETECTED_MODE_BLINKING_LED,
    CUSTOM_UI_DETECTED_MODE_BLINKING_LED_BEEP,
    CUSTOM_UI_DETECTED_MODES_NUMBER_INDICATOR
};

typedef enum UFCODER_FLASH_OPTION
{
    ONLINE_READER = 0x01,
    NFC_READER = 0x02,
    MAX_READER = 0x03
} READER_FLASH_OPTION;

typedef enum UFCODER_PROGRESS
{
    TRANSFER_DATA = 0x01,
    PROCESS_DATA = 0x02,
    MAX_PROGRESS = 0x03
} READER_PROGRESS_STATUS;


#ifdef __cplusplus
extern "C"
{
#endif

    /**
    * @defgroup INTERNAL !!!INTERNAL!!! uFR API calls (Not for public SDK use) (remove from final revision)
    * @{
    */
    /** @} */ // end of defgroup INTERNAL

    /**
    * @defgroup UNDOCUMENTED UNDOCUMENTED uFR API calls (remove from final revision)
    * @brief Excluded from docs due to the nature of their usage
    * @{
    */
    /**@}*/ // end of defgroup INTERNAL

    /** @defgroup LibLic Library licensing
    * @brief Prerequisite API calls for facilitating use of uFR MDK (Mobile Development Kit) with Android/iOS devices (usage of mobile device internal NFC antenna)
    *  @{
    */
    /** @} */ // end of LibLic

    /** @defgroup SingleReader Single Reader
    * @{
    */
    /** @defgroup ReaderAndLibrary Reader and library
    ** @brief Functions related to reader itself, to obtain some info or set certain device parameters.
    * @{
    */
    /** @defgroup ReaderAndLibrary_Communication Communication with the reader
     * @brief Functions related to establishing, closing and changing speed of communication with the reader and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_Communication

    /** @defgroup ReaderAndLibrary_Information Information about the reader
     * @brief Functions related to getting information about the reader, e.g serial number, hardware/fimware version, reader type and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_Information

    /** @defgroup ReaderAndLibrary_EEPROM EEPROM manipulation
     * @brief Functions related to reading/writing data in the reader EEPROM, e.g user data, keys and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_EEPROM

    /** @defgroup ReaderAndLibrary_Signalization Signalization (default)
     * @brief Functions related to interacting with the basic reader signalization
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_Signalization

    /** @defgroup ReaderAndLibrary_RGBSignalization RGB Signalization
     * @brief Functions related to RGB signalization on supported reader types. E.g uFR Zero series, uFR Classic CS, uFR Advance, uFR XL.
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_RGBSignalization

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures Specific firmware features for uFR Series NFC readers
     * @brief uFR Series readers specific firmware features, advanced set of different functions such as RTC, Display control, Tag emulation (dedicated/combined/ad-hoc) and more 
    * @{
    */
    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_RTC Real Time Clock (RTC)
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_RTC

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl Display Control
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode Tag emulation mode
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_CombinedMode Combined emulation mode
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_CombinedMode

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode Ad-Hoc emulation mode
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM Shared RAM
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending Asynchronous UID Sending
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep Sleep and Auto Sleep
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings RF Analog register settings
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings

    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures

    /** @defgroup ReaderAndLibrary_uFRZeroSpecificFeatures Specific firmware features for uFR Zero Series NFC readers
     * @brief uFR Zero Series readers specific firmware features
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRZeroSpecificFeatures

    /** @defgroup ReaderAndLibrary_uFROnlineCommands uFR Online Reader specific commands
     * @brief Functions related to uFR Online series readers only, specifically targetting the embedded ESP32 MCU
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFROnlineCommands

    /** @defgroup ReaderAndLibrary_BaseHDUFR uFR library support for Base HD NFC readers
    * @brief Functions related to toggling BaseHD reader relay and access control
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_BaseHDUFR

    /** @defgroup ReaderAndLibrary_NXPSAM Support for NXP SAM (Secure Application Module)
     * @brief Functions related to interacting with the SAM (Secure Application Module), such as authentication, key entry and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_NXPSAM

    /** @defgroup ReaderAndLibrary_HelperFunc Helper library functions
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_HelperFunc

    /**@}*/ // end of defgroup ReaderAndLibrary

    /** @defgroup Card_Tag Card/tag commands
    ** @brief Functions used for card (or tag) data manipulation, such as obtaining some info, reading or  writing data into card
    * @{
    */
    /** @defgroup Card_Tag_General General purpose card related commands
    ** @brief Functions for getting common card data, not specific to card type.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_General

    /** @defgroup Card_Tag_Mifare Mifare Classic specific commands
    ** @brief Functions specific to Mifare Classic® family of cards (Classic 1K and 4K). All functions
    * are dedicated for use with Mifare Classic® cards. However, some functions can be used
    * with other card types, mostly in cases of direct addressing scheme. E.g BlockRead(), BlockWrite(), LinearRead(), LinearWrite() can be used also with the NTAG2XX tags.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_Mifare

    /** @defgroup Card_Tag_NDEF NDEF related commands
    ** @brief Functions for reading and writing common NDEF messages and records into various NFC tags.
    * Currently, only NFC Type 2 Tags are supported, while support for other NFC Tag types will be added in future upgrades.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_NDEF

    /** @defgroup Card_Tag_NTAG_2XX NTAG2XX (Type 2) specific commands
    ** @brief Functions specific to NTAG® family chips such as NTAG 203, 210, 212, 213, 215, 216. Due to the different memory sizes of various NTAG chips, we implemented functions for handling NTAG chips as generic NFC Type 2 Tag.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_NTAG

    /** @defgroup Card_Tag_NT4H NT4H (Type 4) specific commands
    ** @brief Functions specific to NT4H (Type 4) chips (e.g NTAG424DNA, with TagTamper support)
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_NT4H

    /** @defgroup Card_Tag_Mifare_Desfire Mifare DESFire specific commands
    ** @brief Functions specific to Mifare DESFire® cards. All uFR Series readers support DESfire set of commands in AES encryption mode according to manufacturer's recommendations. In addition to AES, support for DES/2K3DES/3K3DES included.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_Mifare_Desfire

    /** @defgroup Card_Tag_Mifare_Desfire_Light Mifare DESFire Light specific commands
    ** @brief Functions specific to Mifare DESFire® Light cards.
    * @{
    */
    /**@}*/
    // end of defgroup Card_Tag_Mifare_Desfire_Light

    /** @defgroup Card_Tag_Mifare_Plus Mifare Plus specific commands
    ** @brief Functions specific to Mifare Plus cards.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_Mifare_Plus

    /** @defgroup Card_Tag_Ultralight_C Ultralight C specific commands
    ** @brief Functions specific to Ultralight C cards.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_Ultralight_C

    /** @defgroup Card_Tag_JavaCardApplication Java Card Application (JCApp) specific commands
    ** @brief "Java Card" refers to a contactless or dual interface Java Cards. For now, we have supported two JCApps in our uFR Series NFC API. Those JCApps are DLSigner and DLStorage.
    * @{
    */
    /** @defgroup Card_Tag_JavaCardApplication_Common Common JCApp PIN functions
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_JavaCardApplication_Common

    /** @defgroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature PKI infrastructure and digital signature support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature

    /** @defgroup Card_Tag_JavaCardApplication_DLStorage DLStorage JCApp support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_JavaCardApplication_DLStorage

    /**@}*/ // end of defgroup Card_Tag_JavaCardApplication

    /** @defgroup Card_Tag_CardFeatures Support for specific card features
    ** @brief This is a group for specific card features (Originality checking, MRTD, EMV etc...)
    * @{
    */
    /** @defgroup Card_Tag_CardFeatures_OriginalityChecking Originality Checking
    * @brief Some card chips supports originality checking mechanism using Elliptic Curve Digital Signature Algorithm (ECDSA). Chip families that support originality checking mechanism are NTAG 21x and Mifare Ultralight EV1.
    * For details on originality checking, you must have an non-disclosure agreement (NDA) with the manufacturer who will provide you with the relevant documentation.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_OriginalityChecking

    /** @defgroup Card_Tag_CardFeatures_ISO144434_4 ISO14443-4 Protocol
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_ISO144434_4

    /** @defgroup Card_Tag_CardFeatures_ISO7816 ISO7816 Protocol
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_ISO7816

    /** @defgroup Card_Tag_CardFeatures_GeneralPurposeCrypto General purpose cryptographic functions
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_GeneralPurposeCrypto

    /** @defgroup Card_Tag_CardFeatures_CryptoHashAlgorithms Cryptographic hashing algorithms
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_CryptoHashAlgorithms

    /** @defgroup Card_Tag_CardFeatures_DigitalSignatureVerification Digital signature verification
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_DigitalSignatureVerification

    /** @defgroup Card_Tag_CardFeatures_MRTD Machine Readable Travel Documents (MRTD) support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_MRTD

    /** @defgroup Card_Tag_CardFeatures_TLS TLS 1.2 with TLS/SSL Client Certificate Authentication using Generic Identity Device Specification (GIDS) smart card support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_TLS

    /** @defgroup Card_Tag_CardFeatures_EMV Europay, Mastercard, Visa (EMV) standard support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_EMV

    /** @defgroup Card_Tag_CardFeatures_AntiCollision Anti-collision support i.e. multi card reader mode
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_AntiCollision

    /** @defgroup Card_Tag_CardFeatures_TransceiveMode Transeive mode support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_TransceiveMode

    /**@}*/ // end of defgroup Card_Tag_CardFeatures

    /**@}*/ // end of defgroup Card_Tag

    /** @defgroup Miscellaneous Miscellaneous
    * @{
    */
    /**@}*/ // end of defgroup Miscellaneous

    /**@}*/ // end of defgroup SingleReader

    /** @defgroup MultiReader MultiReader
    * @{
    ** @defgroup ReaderAndLibrary_ReaderList Handling multiple readers
    * @brief If you want to communicate and use multiple readers from an application, you have to follow the
    * initial procedure for enumerating uFR compatible devices and getting their handles
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_ReaderList

    /** @defgroup ReaderAndLibrary_M Reader and library
    * @brief Functions related to reader itself, to obtain some info or set certain device parameters.
    * @{
    */ 
    /** @defgroup ReaderAndLibrary_Communication_M Communication with the reader
     * @brief Functions related to establishing, closing and changing speed of communication with the reader and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_Communication_M

    /** @defgroup ReaderAndLibrary_Information_M Information about the reader
     * @brief Functions related to getting information about the reader, e.g serial number, hardware/fimware version, reader type and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_Information_M

    /** @defgroup ReaderAndLibrary_EEPROM_M EEPROM manipulation
     * @brief Functions related to reading/writing data in the reader EEPROM, e.g user data, keys and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_EEPROM_M

    /** @defgroup ReaderAndLibrary_Signalization_M Signalization (default)
     * @brief Functions related to interacting with the basic reader signalization
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_Signalization_M

    /** @defgroup ReaderAndLibrary_RGBSignalization_M RGB Signalization
     * @brief Functions related to RGB signalization on supported reader types. E.g uFR Zero series, uFR Classic CS, uFR Advance, uFR XL
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_RGBSignalization_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_M Specific firmware features for uFR Series NFC readers
     * @brief uFR Series readers specific firmware features, advanced set of different functions such as RTC, Display control, Tag emulation (dedicated/combined/ad-hoc) and more 
     * @{
     */ 
    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_RTC_M Real Time Clock (RTC)
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_RTC_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl_M Display Control
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode_M Tag emulation mode
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_CombinedMode_M Combined emulation mode
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_CombinedMode_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode_M Ad-Hoc emulation mode
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM_M Shared RAM
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending_M Asynchronous UID Sending
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep_M Sleep and Auto Sleep
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep_M

    /** @defgroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M RF Analog register settings
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M

    /**@}*/ // end of defgroup ReaderAndLibrary_uFRSpecificFeatures_M

    /** @defgroup ReaderAndLibrary_uFRZeroSpecificFeatures_M Specific firmware features for uFR Zero Series NFC readers
     * @brief uFR Zero Series readers specific firmware features
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFRZeroSpecificFeatures_M

    /** @defgroup ReaderAndLibrary_uFROnlineCommands_M uFR Online Reader specific commands
     * @brief Functions related to uFR Online series readers only, specifically targetting the embedded ESP32 MCU
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_uFROnlineCommands_M

    /** @defgroup ReaderAndLibrary_BaseHDUFR_M uFR library support for Base HD NFC readers
    * @brief Functions related to toggling BaseHD reader relay and access control
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_BaseHDUFR_M

    /** @defgroup ReaderAndLibrary_NXPSAM_M Support for NXP SAM (Secure Application Module)
     * @brief Functions related to interacting with the SAM (Secure Application Module), such as authentication, key entry and more
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_NXPSAM_M

    /** @defgroup ReaderAndLibrary_HelperFunc_M Helper library functions
    * @{
    */
    /**@}*/ // end of defgroup ReaderAndLibrary_HelperFunc_M

    /**@}*/ // end of defgroup ReaderAndLibrary_M

    /** @defgroup Card_Tag_M Card/tag commands
    ** @brief Functions used for card (or tag) data manipulation, such as obtaining some info, reading or  writing data into card
    * @{
    */ 
    /** @defgroup Card_Tag_General_M General purpose card related commands
    ** @brief Functions for getting common card data, not specific to card type.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_General

    /** @defgroup Card_Tag_Mifare_M Mifare Classic specific commands
    ** @brief Functions specific to Mifare Classic® family of cards (Classic 1K and 4K). All functions
    * are dedicated for use with Mifare Classic® cards. However, some functions can be used
    * with other card types, mostly in cases of direct addressing scheme. E.g BlockReadM(), BlockWriteM(), LinearReadM(), LinearWriteM() can be used also with the NTAG2XX tags.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_Mifare

    /** @defgroup Card_Tag_NDEF_M NDEF related commands
    ** @brief Functions for reading and writing common NDEF messages and records into various NFC tags.
    * Currently, only NFC Type 2 Tags are supported, while support for other NFC Tag types will be added in future upgrades.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_NDEF_M

    /** @defgroup Card_Tag_NTAG_2XX_M NTAG2XX (Type 2) related commands
    ** @brief Functions specific to NTAG® family chips such as NTAG 203, 210, 212, 213, 215, 216. Due to the different memory sizes of various NTAG chips, we implemented functions for handling NTAG chips as generic NFC Type 2 Tag.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_NTAG_2XX_M

    /** @defgroup Card_Tag_NT4H_M NT4H (Type 4) specific commands
    ** @brief Functions specific to NT4H (Type 4) chips (e.g NTAG424DNA, with TagTamper support)
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_NT4H_M

    /** @defgroup Card_Tag_Mifare_Desfire_M Mifare DESFire specific commands
    ** @brief Functions specific to Mifare DESFire® cards. All uFR Series readers support DESfire set of commands in AES encryption mode according to manufacturer's recommendations. In addition to AES, support for DES/2K3DES/3K3DES included.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_Mifare_Desfire_M

    /** @defgroup Card_Tag_Mifare_Desfire_Light_M Mifare DESFire Light specific commands
    ** @brief Functions specific to Mifare DESFire® Light cards.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_Mifare_Desfire_Light_M

    /** @defgroup Card_Tag_Mifare_Plus_M Mifare Plus specific commands
    ** @brief Functions specific to Mifare Plus cards.
    * @{
    */ 
    /**@}*/
    // end of defgroup Card_Tag_Mifare_Plus_M

    /** @defgroup Card_Tag_Ultralight_C_M Ultralight C specific commands
    ** @brief Functions specific to Ultralight C cards.
    * @{
    */
    /**@}*/
    // end of defgroup Card_Tag_Ultralight_C_M

    /** @defgroup Card_Tag_JavaCardApplication_M Java Card Application (JCApp) specific commands
    ** @brief "Java Card" refers to a contactless or dual interface Java Cards. For now, we have supported two JCApps in our uFR Series NFC API. Those JCApps are DLSigner and DLStorage.
    * @{
    */ 
        /** @defgroup Card_Tag_JavaCardApplication_Common_M Common JCApp PIN functions
        * @{
        */
        /**@}*/ // end of defgroup Card_Tag_JavaCardApplication_Common_M

    /** @defgroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M PKI infrastructure and digital signature support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M

    /** @defgroup Card_Tag_JavaCardApplication_DLStorage_M DLStorage JCApp support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_JavaCardApplication_DLStorage_M

    /**@}*/ // end of defgroup Card_Tag_JavaCardApplication_M

    /** @defgroup Card_Tag_CardFeatures_M Support for specific card features
    ** @brief This is a group for specific card features (Originality checking, MRTD, EMV etc...)
    * @{
    */
    /** @defgroup Card_Tag_CardFeatures_OriginalityChecking_M Originality Checking
    * @brief Some card chips supports originality checking mechanism using Elliptic Curve Digital Signature Algorithm (ECDSA). Chip families that support originality checking mechanism are NTAG 21x and Mifare Ultralight EV1.
    * For details on originality checking, you must have an non-disclosure agreement (NDA) with the manufacturer who will provide you with the relevant documentation.
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_OriginalityChecking_M

    /** @defgroup Card_Tag_CardFeatures_ISO144434_4_M ISO14443-4 Protocol
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_ISO144434_4_M

    /** @defgroup Card_Tag_CardFeatures_ISO7816_M ISO7816 Protocol
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_ISO7816_M

    /** @defgroup Card_Tag_CardFeatures_GeneralPurposeCrypto_M General purpose cryptographic functions
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_GeneralPurposeCrypto_M

    /** @defgroup Card_Tag_CardFeatures_CryptoHashAlgorithms_M Cryptographic hashing algorithms
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_CryptoHashAlgorithms_M

    /** @defgroup Card_Tag_CardFeatures_DigitalSignatureVerification_M Digital signature verification
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_DigitalSignatureVerification_M

    /** @defgroup Card_Tag_CardFeatures_MRTD_M Machine Readable Travel Documents (MRTD) support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_MRTD_M

    /** @defgroup Card_Tag_CardFeatures_TLS_M TLS 1.2 with TLS/SSL Client Certificate Authentication using Generic Identity Device Specification (GIDS) smart card support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_TLS_M

    /** @defgroup Card_Tag_CardFeatures_EMV_M Europay, Mastercard, Visa (EMV) standard support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_EMV_M

    /** @defgroup Card_Tag_CardFeatures_AntiCollision_M Anti-collision support i.e. multi card reader mode
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_AntiCollision_M

    /** @defgroup Card_Tag_CardFeatures_TransceiveMode_M Transeive mode support
    * @{
    */
    /**@}*/ // end of defgroup Card_Tag_CardFeatures_TransceiveMode_M

    /**@}*/ // end of defgroup Card_Tag_CardFeatures_M

    /**@}*/ // end of defgroup Card_Tag_M

    /** @defgroup Miscellaneous_M Miscellaneous
    * @{
    */
    /**@}*/ // end of defgroup Miscellaneous_M

    /**@}*/ // end of defgroup MultiReader

    /** @defgroup uFR_MDK uFR MDK (Mobile Development Kit)
    * @since uFCoder library version 6.0.0
    * 
    * Using the internal NFC antenna of a mobile device is supported in the uFCoder library through the usage of ReaderOpenEx() with appropriate parameters.
    * It is mandatory to obtain a valid DLogic license to make use of the uFR MDK. 
    * License can be obtained automatically through the ReaderOpenEx() API call. 
    * Or using the GetLicenseRequestData() and our online service found at: https://liblic.d-logic.com/ <br>
    * Refer to @ref LibLic group for details. 
    * 
    * @{
    */ 
        /** @defgroup uFR_MDK_Android Android
        * @brief uFR MDK for Android currently has support for the NTAG2XX, Mifare Classic®, Mifare DESFire® tags and ISO 14443-4 protocol via APDU commands.
        * @{
        */ 
            /** @defgroup uFR_MDK_Android_NTAG2XX NTAG2XX with NDEF support
            * @brief Supported API calls for NTAG2XX (e.g NTAG203/210/213/215/216) cards:
            * 
            * * GetCardIdEx()
            * * GetDlogicCardType()
            * * BlockRead_PK()
            * * BlockInSectorRead_PK()
            * * BlockWrite_PK()
            * * BlockInSectorWrite_PK()
            * * LinearRead_PK()
            * * LinearWrite_PK()
            * * read_ndef_record()
            * * write_ndef_record()
            * * write_ndef_record_mirroring()
            * * write_ndef_record_mirroring_tt()
            * * get_ndef_record_count()
            * * erase_last_ndef_record()
            * * erase_all_ndef_records()
            * * ndef_card_initialization()
            * * WriteNdefRecord_WiFi()
            * * WriteNdefRecord_BT()
            * * WriteNdefRecord_SMS()
            * * WriteNdefRecord_Bitcoin()
            * * WriteNdefRecord_GeoLocation()
            * * WriteNdefRecord_NaviDestination()
            * * WriteNdefRecord_Email()
            * * WriteNdefRecord_Address()
            * * WriteNdefRecord_AndroidApp()
            * * WriteNdefRecord_Text()
            * * WriteNdefRecord_StreetView()
            * * WriteNdefRecord_Skype()
            * * WriteNdefRecord_Whatsapp()
            * * WriteNdefRecord_Viber()
            * * WriteNdefRecord_Contact()
            * * WriteNdefRecord_Phone()
            * * ReadNdefRecord_WiFi()
            * * ReadNdefRecord_Bitcoin()
            * * ReadNdefRecord_GeoLocation()
            * * ReadNdefRecord_NaviDestination()
            * * ReadNdefRecord_Email()
            * * ReadNdefRecord_Address()
            * * ReadNdefRecord_AndroidApp()
            * * ReadNdefRecord_Text()
            * * ReadNdefRecord_StreetView()
            * * ReadNdefRecord_Skype()
            * * ReadNdefRecord_Whatsapp()
            * * ReadNdefRecord_Viber()
            * * ReadNdefRecord_Contact()
            * * ReadNdefRecord_Phone()
            * * ReadNdefRecord_SMS()
            * * ReadNdefRecord_BT()
            * * ParseNdefMessage()
            * @{
            */
            /** @}*/ // end of defgroup uFR_MDK_Android_NTAG2XX

            /** @defgroup uFR_MDK_Android_Mifare Mifare Classic
            * @brief Supported API calls for Mifare Classic cards:
            * 
            * * GetCardIdEx()
            * * GetDlogicCardType()
            * * BlockRead_PK()
            * * BlockInSectorRead_PK()
            * * BlockWrite_PK()
            * * BlockInSectorWrite_PK()
            * * LinearRead_PK()
            * * LinearWrite_PK()
            * * SectorTrailerWrite_PK()
            * * SectorTrailerWriteUnsafe_PK()
            * * ValueBlockRead_PK()
            * * ValueBlockWrite_PK()
            * * ValueBlockInSectorRead_PK()
            * * ValueBlockInSectorWrite_PK()
            * * ValueBlockIncrement_PK()
            * * ValueBlockDecrement_PK()
            * * ValueBlockInSectorIncrement_PK()
            * * ValueBlockInSectorDecrement_PK()
            * * LinearFormatCard_PK()
            * @{
            */
            /** @}*/ // end of defgroup uFR_MDK_Android_Mifare

            /** @defgroup uFR_MDK_Android_Desfire Mifare DESFire
            * @brief Supported API calls for Mifare DESFire® cards:
            * 
            * * DES_to_AES_key_type()
            * * AES_to_DES_key_type()
            * * uFR_int_DesfireFreeMem()
            * * uFR_int_DesfireFormatCard_PK()
            * * uFR_int_DesfireFormatCard_aes_PK()
            * * uFR_int_DesfireCreateStdDataFile_PK()
            * * uFR_int_DesfireCreateStdDataFile_aes_PK()
            * * uFR_int_DesfireCreateStdDataFile_aes_iso_PK()
            * * uFR_int_DesfireCreateStdDataFile_aes_iso_sdm_PK()
            * * uFR_int_DesfireDeleteFile_PK()
            * * uFR_int_DesfireDeleteFile_aes_PK()
            * * uFR_int_DesfireCreateAesApplication_PK()
            * * uFR_int_DesfireCreateAesApplication_aes_PK()
            * * uFR_int_DesfireCreateAesApplication_aes_iso_PK()
            * * uFR_int_DesfireCreateAesApplication_aes_iso_ascd_PK()
            * * uFR_int_DesfireDeleteApplication_PK()
            * * uFR_int_DesfireDeleteApplication_aes_PK()
            * * uFR_int_DesfireGetKeySettings_PK()
            * * uFR_int_DesfireChangeKeySettings_PK()
            * * uFR_int_DesfireChangeKeySettings_aes_PK()
            * * uFR_int_DesfireChangeAesKey_aes_PK()
            * * uFR_int_DesfireChangeMasterKey_PK()
            * * uFR_int_DesfireReadStdDataFile_aes_PK()
            * * uFR_int_DesfireReadStdDataFile_no_auth()
            * * uFR_int_DesfireWriteStdDataFile_aes_PK()
            * * uFR_int_DesfireWriteStdDataFile_no_auth()
            * * uFR_int_DesfireGetStdFileSize_aes_PK()
            * * uFR_int_DesfireGetFileSettings_aes_PK()
            * * uFR_int_DesfireGetFileSettingsSdm_aes_PK()
            * * uFR_int_DesfireChangeFileSettings_aes_PK()
            * * uFR_int_DesfireChangeFileSettingsSdm_PK()
            * * uFR_int_DesfireSetTransactionTimer_aes_PK()
            * @{
            */
            /** @}*/ // end of defgroup uFR_MDK_Android_Desfire

            /** @defgroup uFR_MDK_Android_ISO14443_4 ISO 14443-4 protocol
            * @brief Supported API calls for ISO 14443-4 APDU commands:
            * 
            * * SetISO14443_4_Mode()
            * * APDUHexStrTransceive()
            * * APDUPlainTransceive()
            * * s_block_deselect()
            * @{
            */
            /** @}*/ // end of defgroup uFR_MDK_Android_ISO14443_4

        /** @}*/ // end of defgroup uFR_MDK_Android
        
        /** @defgroup uFR_MDK_iOS iOS
        * @brief uFR MDK for IOS currently has support only for Mifare DESFire® tags and ISO 14443-4 protocol via APDU commands. 
        * 
        * @{
        */ 
            /** @defgroup uFR_MDK_iOS_Desfire Mifare DESFire
            * @brief Supported API calls for Mifare DESFire® cards:
            * 
            * * DES_to_AES_key_type()
            * * AES_to_DES_key_type()
            * * uFR_int_DesfireFreeMem()
            * * uFR_int_DesfireFormatCard_PK()
            * * uFR_int_DesfireFormatCard_aes_PK()
            * * uFR_int_DesfireCreateStdDataFile_PK()
            * * uFR_int_DesfireCreateStdDataFile_aes_PK()
            * * uFR_int_DesfireCreateStdDataFile_aes_iso_PK()
            * * uFR_int_DesfireCreateStdDataFile_aes_iso_sdm_PK()
            * * uFR_int_DesfireDeleteFile_PK()
            * * uFR_int_DesfireDeleteFile_aes_PK()
            * * uFR_int_DesfireCreateAesApplication_PK()
            * * uFR_int_DesfireCreateAesApplication_aes_PK()
            * * uFR_int_DesfireCreateAesApplication_aes_iso_PK()
            * * uFR_int_DesfireCreateAesApplication_aes_iso_ascd_PK()
            * * uFR_int_DesfireDeleteApplication_PK()
            * * uFR_int_DesfireDeleteApplication_aes_PK()
            * * uFR_int_DesfireGetKeySettings_PK()
            * * uFR_int_DesfireChangeKeySettings_PK()
            * * uFR_int_DesfireChangeKeySettings_aes_PK()
            * * uFR_int_DesfireChangeAesKey_aes_PK()
            * * uFR_int_DesfireChangeMasterKey_PK()
            * * uFR_int_DesfireReadStdDataFile_aes_PK()
            * * uFR_int_DesfireReadStdDataFile_no_auth
            * * uFR_int_DesfireWriteStdDataFile_aes_PK()
            * * uFR_int_DesfireWriteStdDataFile_no_auth
            * * uFR_int_DesfireGetStdFileSize_aes_PK()
            * * uFR_int_DesfireGetFileSettings_aes_PK()
            * * uFR_int_DesfireGetFileSettingsSdm_aes_PK()
            * * uFR_int_DesfireChangeFileSettings_aes_PK()
            * * uFR_int_DesfireChangeFileSettingsSdm_PK()
            * * uFR_int_DesfireSetTransactionTimer_aes_PK()
            * @{
            */
            /** @}*/ // end of defgroup uFR_MDK_iOS_Desfire

            
            /** @defgroup uFR_MDK_IOS_ISO14443_4 ISO 14443-4 protocol
            * @brief Supported API calls for ISO 14443-4 APDU commands:
            * 
            * * SetISO14443_4_Mode()
            * * APDUHexStrTransceive()
            * * APDUPlainTransceive()
            * * s_block_deselect()
            * @{
            */
            /** @}*/ // end of defgroup uFR_MDK_IOS_ISO14443_4

        /** @}*/ // end of defgroup uFR_MDK_iOS

    /**@}*/ // end of defgroup uFR_MDK

    //--------------------------------------------------------------------------------------------------
    /**
    * @brief Used to generate license request necessary for obtaing valid uFCoder license separately.
    * 
    * Parameter "license_request" will hold a JSON string value that is to be used for our online front-end service for generating an offline license.
    * The online service is found at: https://liblic.d-logic.com/
    * 
    * @ingroup LibLic
    *
    * @param months Number of months requested for the license
    * @param license_request JSON string formed with licensing parameters
    *
    */
    void DL_API GetLicenseRequestData(uint32_t months, OUT char *license_request);

    /**
    * @brief Used to validate and store an offline Dlogic license for future usage.
    *
    * @ingroup LibLic
    *
    * @param license_str JSON string containing full license data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetLicenseData(c_string license_str);

    /**
    * @brief Opens reader communication port for all µFR devices. You can also use this function to open communication with µFR Online devices.
    * 
    * Using ReaderOpen to open communication with µFR Online devices:
    * If you have only one reader attached to your PC, it will open that reader serial port on 1Mbit/s, or if you have only one reader attached to another power supply (not your PC) it will open that reader based on it’s working mode (TCP or UDP). If you have more than one µFR Online device, ReaderOpen function will open the first one found, for opening another device, use ReaderOpenEx instead.
    * <br>
    * NOTE: On Android, using ReaderOpen() will establish communication with uFR Series readers connected via OTG cable. 
    * 
    * @ingroup ReaderAndLibrary_Communication
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderOpen(void);

    /**
    * @brief Opens a port of connected reader using readers family type. Useful for speed up opening for non uFR basic reader type (e.g. BaseHD with uFR support). 
    * 
    * Do not use this function for opening communication with µFR Online devices.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @param reader_type 0 : auto - same as call ReaderOpen() 1 : uFR type (1 Mbps) 2 : uFR RS232 type (115200 bps) 3 : BASE HD uFR type (250 Kbps)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderOpenByType(uint32_t reader_type);

    enum E_READER_TYPE
    {
        AUTO = 0,
        UFR_TYPE = 1,
        UFR_RS232_TYPE = 2,
        BASEHD_UFR_TYPE = 3,
        UFR_ONLINE_TYPE = 4,
        INTERNAL_NFC = 5
    };

    /**
    * @brief Open reader communication port in several different ways. Can be used for establishing communication with COM port too. 
    * 
    * There is enumeration in uFCoder.h file called E_READER_TYPE with values:
    * enum E_READER_TYPE
    * {
    * AUTO = 0,
    * UFR_TYPE = 1,
    * UFR_RS232_TYPE = 2,
    * BASEHD_UFR_TYPE = 3,
    * UFR_ONLINE_TYPE = 4,
    * INTERNAL_NFC = 5
    * };
    * Values in this enumeration you can pass into ReaderOpenEx function as reader_type parameter. <br>
    * For example, if you pass 4 as reader_type it will only work with µFR Online Series devices, and then as port_name you can pass devices IP address or serial number (ex: “192.168.1.123” or “ON101390”), for port_interface you can pass ‘U’ for UDP, ‘T’ for TCP or 0.
    * If you pass 0, it will automatically search for reader working mode (UDP or TCP) and open it. For argument you can pass 0 or µFR Nano device serial number to open it on 1Mbit/s (ex: “UN123456”).  <br>
    * Using value 5 as reader_type implies usage of internal mobile device NFC. 
    * Upon a call to ReaderOpenEx with this parameter, the library will try to obtain license automatically via HTTP. 
    * On success, a valid license is stored for future use. On failure, it moves to looking up for stored licenses. Results other than UFR_OK status imply a corresponding error that occurred and as such use of internal mobile device NFC will be unavailable.
    * When using 5 as reader_type, additionally you can specify port_interface parameter to decide whether to do online->offline validation or just offline. To use offline-only validation of a previously stored valid DLogic license, set port_interface to 1. 
    * Value 0 is default value for port_interface and implies online->offline license validation. 
    * More examples for port open are given in the “Reader Open Examples” document:
    * https://www.d-logic.com/code/nfc-rfid-reader-sdk/ufr-doc/blob/master/Reader_Open_Examples.pdf
    * Examples:
    * ReaderOpenEx(1, “COM1”, 0, 0)
    * This example will open communication with µFR device attached to COM1 port on 1Mbit/s
    * ReaderOpenEx(1, 0, 0, 0)
    * This example will automatically find COM port and open communication with first µFR device on 1Mbit/s
    * ReaderOpenEx(2, 0, 0, 0)
    * This example will automatically find COM port and open communication with first µFR RS232 device on 115200 bit/s
    * ReaderOpenEx(4, “ON123456”, ‘U’, 0)
    * This example will open communication with µFR Online reader with serial number ON123456 on UDP protocol.
    * ReaderOpenEx(4, “ON123456”, ‘T’, 0)
    * This example will open communication with µFR Online reader with serial number ON123456 on TCP protocol.
    * ReaderOpenEx(4, “192.168.1.123”, ‘U’, 0)
    * This example will open communication with µFR Online reader with IP address 192.168.1.123 on UDP protocol.
    * ReaderOpenEx(4, “192.168.1.123”, ‘T’, 0)
    * This will open communication with µFR Online reader with IP address 192.168.1.123 on TCP protocol.
    * ReaderOpenEx(4, “192.168.1.123”, 0, 0)
    * It will open communication with µFR Online reader with IP address 192.168.1.123 based on its working protocol (UDP or TCP), because we passed 0 as port_interface
    * ReaderOpenEx(4, “ON123456”, 0, 0)
    * It will open communication with µFR Online reader with serial number ON123456 based on its working protocol (UDP or TCP), because we passed 0 as port_interface
    * ReaderOpenEx(4, “ON123456”, 0, “UN654321”)
    * It will open communication with µFR Nano reader on 1Mbit/s with serial number UN654321 which is attached to µFR Online device with serial number ON123456
    * ReaderOpenEx(4, “192.168.1.123”, 0, “UN654321”)
    * It will open communication with µFR Nano reader on 1Mbit/s with serial number UN654321 which is attached to µFR Online device with IP address 192.168.1.123
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @param reader_type 0 : auto - same as call ReaderOpen() 1 : uFR type (1 Mbps) 2 : uFR RS232 type (115200 bps) 3 : BASE HD uFR type (250 Kbps) When uFR Online reader works in BT serial mode or transparent mode, reader_type must be set to 1.
    * @param port_name is c-string type used to open port by given serial name. If you provide NULL or empty string that is AUTO MODE which calls ReaderOpenEx() and all available ports on the system. serial port name, identifier, like "COM3" on Windows or "/dev/ttyS0" on Linux or "/dev/tty.serial1" on OS X or if you select FTDI, reader serial number like "UN123456", if reader have integrated FTDI interface When the UDP interface type is selected, port_name must be provided in “address:port” format. Like "192.168.1.162:8881" IP for UDP I/F
    * @param port_interface type of communication interfaces (define interface which we use while connecting to the printer), supported value's: 0 : auto - first try FTDI than serial if port_name is not defined 1 : try serial / virtual COM port / interfaces 2 : try only FTDI communication interfaces 10 : try to open Digital Logic Shields with RS232 uFReader on Raspberry Pi (serial interfaces with GPIO reset) 84 ('T') : TCP/IP interface 85 ('U') : UDP interface 102 ('B'): BT serial interface. Android library only. 114 ('L'): BLE interface. Android library only. When uFR Online reader works in BT serial mode, port_interface must be set to 0 (Except Android). arg C-string with additional settings delimited with new lines. Settings C-string constant: “UNIT_OPEN_RESET_DISABLE” : do not reset the reader when opening “UNIT_OPEN_RESET_FORCE” : force reset the reader when opening “UNIT_OPEN_RESET_ONLY”: only resets the device and will not send additional commands that are used when establishing communication with the reader. "READER_ACTIVE_ON_RTS_LOW"  : (default) Reset the reader when RTS is high - the reader works when RTS is low "READER_ACTIVE_ON_RTS_HIGH" : Reset the reader when RTS is low - the reader works when RTS is high "RTS_ALWAYS_HIGH"           : not implemented yet "RTS_ALWAYS_LOW"            : not implemented yet "RTS_DISCONNECTED"          : disconnect RTS (RTS is not initiate nor use) When uFR Online reader works in BT serial mode or transparent mode, arg must be set to “UNIT_OPEN_RESET_DISABLE”. Custom baud rates from library version 5.0.28. For all RS232 devices and USB devices from firmware version 5.0.31 "BR_1000000"                                : 1 Mbps "BR_115200"                                        : 115200 bps "BR_250000"                                        : 250000 bps "BR_9600"                                        : 9600 bps "BR_19200"                                        : 19200 bps "BR_38400"                                        : 38400 bps "BR_57600"                                        : 57600 bps "BR_230400"                                        : 234000 bps "BR_460800"                                        : 460800 bps "BR_500000"                                        : 500000 bps
    * @param arg C-string with additional settings delimited with new lines. Settings C-string constant: “UNIT_OPEN_RESET_DISABLE” : do not reset the reader when opening “UNIT_OPEN_RESET_FORCE” : force reset the reader when opening “UNIT_OPEN_RESET_ONLY”: only resets the device and will not send additional commands that are used when establishing communication with the reader. "READER_ACTIVE_ON_RTS_LOW"  : (default) Reset the reader when RTS is high - the reader works when RTS is low "READER_ACTIVE_ON_RTS_HIGH" : Reset the reader when RTS is low - the reader works when RTS is high "RTS_ALWAYS_HIGH"           : not implemented yet "RTS_ALWAYS_LOW"            : not implemented yet "RTS_DISCONNECTED"          : disconnect RTS (RTS is not initiate nor use) When uFR Online reader works in BT serial mode or transparent mode, arg must be set to “UNIT_OPEN_RESET_DISABLE”. Custom baud rates from library version 5.0.28. For all RS232 devices and USB devices from firmware version 5.0.31 "BR_1000000"                                : 1 Mbps "BR_115200"                                        : 115200 bps "BR_250000"                                        : 250000 bps "BR_9600"                                        : 9600 bps "BR_19200"                                        : 19200 bps "BR_38400"                                        : 38400 bps "BR_57600"                                        : 57600 bps "BR_230400"                                        : 234000 bps "BR_460800"                                        : 460800 bps "BR_500000"                                        : 500000 bps
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderOpenEx(uint32_t reader_type, IN c_string port_name, uint32_t port_interface, IN void *arg);

    /**
    * @brief Opens uFR Online device by serial number. 
    * 
    * Function will open communication (UDP or TCP) with device based on its working mode. If function cannot find given serial number, it will open communication on serial port with 1Mbit/s.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @param serial_number Pointer to const char array (c_string) containing devices serial number (ex. “ON101390”).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderOpen_uFROnline(c_string serial_number);

    /**
    * @brief Physical reset of reader communication port.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderReset(void);

    /**
    * @brief Physical reset of reader communication port & tests the communication before returning a UFR_STATUS code.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderResetWait(void);

    /**
    * @brief Close reader communication port.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderClose(void);

    /**
    * @brief This function is used to restart the reader by software. It sets all readers parameters to default values and close RF field which resets all the cards in the field.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderSoftRestart(void);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderHwReset(void);

    /**
    * @brief Returns reader type as a pointer to 4 byte value.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @param lpulReaderType pointer to lpulReaderType variable. “lpulReaderType” as result - please refer to Appendix: DLogic reader type enumeration. E.g. for µFR Nano Classic readers this value is  0xD1180022.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderType(IN uint32_t *lpulReaderType);

    /**
    * @brief Returns reader serial number as a pointer to 4 byte value.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @param lpulSerialNumber pointer to lpulSerialNumber variable. “lpulSerialNumber “ as result holds 4 byte serial number value.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderSerialNumber(IN uint32_t *lpulSerialNumber);

    /**
    * @brief Retrieve info if reader is still connected to host.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @param connected pointer to connected variable “connected” as result: > 0 Reader is connected on system = 0 Reader is not connected on system anymore (or closed) < 0 other error “connected” - Pointer to unsigned int type variable 32 bit long, where the information   about readers availability is written. If the reader is connected on system, function store 1 (true) otherwise, on some error, store zero in that variable.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderStillConnected(VAR uint32_t *connected);

    /**
    * @brief Store a new key or change existing key under provided index parameter.
    * 
    * The keys are in a special area in EEPROM that can not be read anymore which gains protection.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param aucKey Pointer to an array of 6 bytes containing the key. Default key values are always “FF FF FF FF FF FF” hex.
    * @param ucKeyIndex key Index. Possible values ​​are 0 to 31.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderKeyWrite(IN const uint8_t *aucKey, uint8_t ucKeyIndex);

    /**
    * @brief Lock reader’s keys to prevent further changing.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    * @param password pointer to the 8 bytes array containing valid password.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderKeysLock(IN const uint8_t *password);

    /**
    * @brief Unlock reader’s keys if they are locked with previous function.
    * The factory setting is that reader keys are unlocked.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param password pointer to the 8 bytes array containing valid password.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderKeysUnlock(IN const uint8_t *password);

    /**
    * @brief This function turns sound and light reader signals. 
    * 
    * Sound signals are performed by the reader's buzzer and light signals are performed by the reader's LEDs.
    * There are predefined signal values for sound and light:
    *
    * @ingroup ReaderAndLibrary_Signalization
    *
    * @param light_signal_mode 0 - None, 1 - Long Green, 2 - Long Red, 3 - Alternation, 4 - Flash
    * @param beep_signal_mode 0 - None, 1 - Short, 2 - Long, 3 - Double Short, 4 - Triple Short, 5 - Triplet Melody
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderUISignal(uint8_t light_signal_mode, uint8_t beep_signal_mode);

    /**
    * @brief Function sets the duty cycle ratio of the sound signal. Value is in percent (0 - 100%).
    * 
    * Default value is 50%, and this value will be set after the reset of the reader, without using this function.
    *
    * @ingroup ReaderAndLibrary_Signalization
    * @param sound_volume volume in percent 0 - 100 %
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderSoundVolume(uint8_t sound_volume);

    /**
    * @brief Read user data written in device NV memory.
    * 
    * User data is 16 byte long.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param aucData pointer to a 16 bytes array containing user data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadUserData(OUT uint8_t *aucData);

    /**
    * @brief Read user data written in device NV memory.
    * 
    * User data is 32 byte long.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param aucData pointer to a 32 bytes array containing user data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadUserDataExt(OUT uint8_t *aucData);

    /**
    * @brief Write user data into the device's NV memory. 
    * 
    * User data is 16 byte long.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param aucData pointer to a 16 byte array containing user data
    * @return Operation status
    */
    UFR_STATUS DL_API WriteUserData(IN const uint8_t *aucData);

    /**
    * @brief Write user data into the device's NV memory.
    * 
    *  User data is 32 byte long.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param aucData pointer to a 32 byte array containing user data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteUserDataExt(IN const uint8_t *aucData);

    /**
    * @brief Returns card UID as a 4-byte array. This function is deprecated and used only for backward compatibility with older firmware versions (before v2.0). 
    * 
    * We strongly discourage use of this function. This function can’t successfully handle 7 byte UIDS.
    *
    * @ingroup Card_Tag_General
    *
    * @param lpucCardType returns pointer to variable which holds card type according to SAK lpulCardSerial returns pointer to array of card UID bytes, 4 bytes long ONLY
    * @param lpulCardSerial returns pointer to array of card UID bytes, 4 bytes long ONLY
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCardId(VAR uint8_t *lpucCardType, OUT uint32_t *lpulCardSerial);

    /**
    * @brief Function returns ATQA and SAK (ISO 14443-3) of selected card.
    *
    * @ingroup Miscellaneous
    *
    * @param atqa pointer to variable which contain ATQA sak pointer to variable which contain SAK
    * @param sak pointer to variable which contain SAK
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAtqaSak(VAR uint16_t *atqa, VAR uint8_t *sak);

    /**
    * @brief Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.28) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockRead(OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Read particular block using absolute Block address.
    *
    * *only uFR CS with SAM support. 
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.28) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockReadSamKey(OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWrite(IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Write particular block using absolute Block address.
    *
    * *only uFR CS with SAM support. 
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWriteSamKey(IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorRead(OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address, uint8_t auth_mode,
                                        uint8_t key_index);

    /**
    * @brief Read particular block using relative Block in Sector address.
    *
    * *only uFR CS with SAM support.
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorReadSamKey(OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address, uint8_t auth_mode,
                                              uint8_t key_index);

    /**
    * @brief Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWrite(IN const uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address, uint8_t auth_mode,
                                         uint8_t key_index);

    /**
    * @brief Write particular block using relative Block in Sector address.
    *
    * *only uFR CS with SAM support.
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWriteSamKey(IN const uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                               uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. 
    * 
    * When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start reading
    * @param usDataLength Length of data - how many bytes to read
    * @param lpusBytesReturned Pointer to variable holding how many bytes are returned
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearRead(OUT uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength, VAR uint16_t *lpusBytesReturned,
                                 uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. 
    * 
    * When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start reading
    * @param usDataLength Length of data - how many bytes to read
    * @param lpusBytesReturned Pointer to variable holding how many bytes are returned
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearReadSamKey(OUT uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength, VAR uint16_t *lpusBytesReturned,
                                       uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief Read Linear data Address Space. On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * 
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start reading
    * @param usDataLength Length of data - how many bytes to read
    * @param lpusBytesReturned Pointer to variable holding how many bytes are returned
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowRead(OUT uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength, VAR uint16_t *lpusBytesReturned,
                                 uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief These functions are used for writing data to the card using emulation of the linear address space. 
    * 
    * The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start writting
    * @param usDataLength Length of data - how many bytes to write
    * @param lpusBytesWritten Pointer to variable holding how many bytes were written
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWrite(IN const uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength, VAR uint16_t *lpusBytesWritten,
                                  uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief These functions are used for writing data to the card using emulation of the linear address space. 
    * The method for proving authenticity is determined by the suffix in the functions names.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start writting
    * @param usDataLength Length of data - how many bytes to write
    * @param lpusBytesWritten Pointer to variable holding how many bytes were written
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWriteSamKey(IN const uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength,
                                        VAR uint16_t *lpusBytesWritten, uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCard(IN const uint8_t *new_key_A, uint8_t blocks_access_bits, uint8_t sector_trailers_access_bits,
                                       uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B, VAR uint8_t *lpucSectorsFormatted,
                                       uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWrite(uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A, uint8_t block0_access_bits,
                                         uint8_t block1_access_bits, uint8_t block2_access_bits, uint8_t sector_trailer_access_bits,
                                         uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteSamKey(uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A,
                                               uint8_t block0_access_bits, uint8_t block1_access_bits, uint8_t block2_access_bits,
                                               uint8_t sector_trailer_access_bits, uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B,
                                               uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafe(uint8_t addressing_mode, uint8_t address, IN const uint8_t *sector_trailer, uint8_t auth_mode,
                                               uint8_t key_index);

    /**
    * @brief Read particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockRead(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Read particular Value block using absolute Block address.
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorRead(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                             uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Read particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockReadSamKey(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode,
                                           uint8_t key_index);

    /**
    * @brief Read particular Value block using absolute Block address.
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorReadSamKey(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                   uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWrite(int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWriteSamKey(int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWrite(int32_t value, uint8_t value_addr, uint8_t sector_address, uint8_t block_in_sector_address,
                                              uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWriteSamKey(int32_t value, uint8_t value_addr, uint8_t sector_address, uint8_t block_in_sector_address,
                                                    uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Increments particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrement(int32_t increment_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Increments particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrementSamKey(int32_t increment_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Increments particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrement(int32_t increment_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                  uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Increments particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrementSamKey(int32_t increment_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                        uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Decrements particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented sector_address Absolute Sector address block_in_sector_address Block address in Sector auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param block_address Absolute Block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Decrements particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented sector_address Absolute Sector address block_in_sector_address Block address in Sector auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param block_address Absolute Block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Decrements particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrement(int32_t decrement_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                  uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Decrements particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * *only uFR CS with SAM support
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrementSamKey(int32_t decrement_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                        uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.28) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockRead_AKM1(OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWrite_AKM1(IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorRead_AKM1(OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWrite_AKM1(IN const uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                              uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. 
    * 
    * When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearRead_AKM1(OUT uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_returned,
                                      uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Read Linear data Address Space. 
    * 
    * On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowRead_AKM1(OUT uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_returned,
                                      uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) These functions are used for writing data to the card using emulation of the linear address space. 
    * 
    * The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start writing
    * @param length Length of data - how many bytes to write bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param bytes_written  Pointer to variable holding how many bytes are written
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWrite_AKM1(IN const uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_written,
                                       uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once.
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCard_AKM1(IN const uint8_t *new_key_A, uint8_t blocks_access_bits, uint8_t sector_trailers_access_bits,
                                            uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B, VAR uint8_t *lpucSectorsFormatted,
                                            uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer.
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWrite_AKM1(uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A, uint8_t block0_access_bits,
                                              uint8_t block1_access_bits, uint8_t block2_access_bits, uint8_t sector_trailer_access_bits,
                                              uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafe_AKM1(uint8_t addressing_mode, uint8_t address, IN const uint8_t *sector_trailer,
                                                    uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Read particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockWrite Function description Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockWrite(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockWrite_AKM1(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_AKM2(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_PK(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockWriteSamKey(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockRead_AKM1(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Read particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorRead_AKM1(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                  uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Write particular Value block using absolute Block address.
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWrite_AKM1(int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWrite_AKM1(int32_t value, uint8_t value_addr, uint8_t sector_address, uint8_t block_in_sector_address,
                                                   uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Increments particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrement_AKM1(int32_t increment_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Increments particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrement_AKM1(int32_t increment_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                       uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Decrements particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented sector_address Absolute Sector address block_in_sector_address Block address in Sector auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param block_address Absolute Block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 1 (AKM1) Decrements particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrement_AKM1(int32_t decrement_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                       uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.28) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockRead_AKM2(OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWrite_AKM2(IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorRead_AKM2(OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWrite_AKM2(IN const uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                              uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. 
    * 
    * When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearRead_AKM2(OUT uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_returned,
                                      uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Read Linear data Address Space. 
    * 
    * On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowRead_AKM2(OUT uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_returned,
                                      uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) These functions are used for writing data to the card using emulation of the linear address space. 
    * 
    * The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start writing
    * @param length Length of data - how many bytes to write bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param bytes_written Pointer to variable holding how many bytes are written
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWrite_AKM2(IN const uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_written,
                                       uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCard_AKM2(IN const uint8_t *new_key_A, uint8_t blocks_access_bits, uint8_t sector_trailers_access_bits,
                                            uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B, VAR uint8_t *lpucSectorsFormatted,
                                            uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWrite_AKM2(uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A, uint8_t block0_access_bits,
                                              uint8_t block1_access_bits, uint8_t block2_access_bits, uint8_t sector_trailer_access_bits,
                                              uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafe_AKM2(uint8_t addressing_mode, uint8_t address, IN const uint8_t *sector_trailer,
                                                    uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Read particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. 
    * Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockWrite Function description Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockWrite(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockWrite_AKM1(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_AKM2(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_PK(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockWriteSamKey(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockRead_AKM2(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Read particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorRead_AKM2(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                  uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. 
    * 
    * Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWrite_AKM2(int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWrite_AKM2(int32_t value, uint8_t value_addr, uint8_t sector_address, uint8_t block_in_sector_address,
                                                   uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Increments particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrement_AKM2(int32_t increment_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Increments particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrement_AKM2(int32_t increment_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                       uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Decrements particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented sector_address Absolute Sector address block_in_sector_address Block address in Sector auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Automatic Key Mode 2 (AKM2) Decrements particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrement_AKM2(int32_t decrement_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                       uint8_t auth_mode);

    /**
    * @brief Provided Key mode (PK) Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.28) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockRead_PK(OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWrite_PK(IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorRead_PK(OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address, uint8_t auth_mode,
                                           IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWrite_PK(IN const uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address, uint8_t auth_mode,
                                            IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. 
    * 
    * When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearRead_PK(OUT uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_returned,
                                    uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Read Linear data Address Space. 
    * 
    * On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowRead_PK(OUT uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_returned,
                                    uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) These functions are used for writing data to the card using emulation of the linear address space. 
    * 
    * The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start writing
    * @param length Length of data - how many bytes to write bytes_returned Pointer to variable holding how many bytes are returned auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param bytes_written Pointer to variable holding how many bytes are written
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWrite_PK(IN const uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_written,
                                     uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCard_PK(IN const uint8_t *new_key_A, uint8_t blocks_access_bits, uint8_t sector_trailers_access_bits,
                                          uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B, VAR uint8_t *lpucSectorsFormatted,
                                          uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWrite_PK(uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A, uint8_t block0_access_bits,
                                            uint8_t block1_access_bits, uint8_t block2_access_bits, uint8_t sector_trailer_access_bits,
                                            uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. 
    * 
    * It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 key_index Index of reader’s key to be used (RK mode) key Pointer to 6 byte array containing key bytes (PK mode)
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafe_PK(uint8_t addressing_mode, uint8_t address, IN const uint8_t *sector_trailer, uint8_t auth_mode,
                                                  IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Read particular Value block using absolute Block address.
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockWrite Function description Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockWrite(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockWrite_AKM1(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_AKM2(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_PK(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockWriteSamKey(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockWrite Function description Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockWrite(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockWrite_AKM1(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_AKM2(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockWrite_PK(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockWriteSamKey(int32_t *value, uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockRead_PK(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode,
                                        IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Read particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorRead_PK(VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                uint8_t block_in_sector_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWrite_PK(int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Write particular Value block using absolute Block address. 
    * 
    * This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWrite_PK(int32_t value, uint8_t value_addr, uint8_t sector_address, uint8_t block_in_sector_address,
                                                 uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Increments particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrement_PK(int32_t increment_value, uint8_t block_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Increments particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param increment_value value showing how much initial block value will be incremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrement_PK(int32_t increment_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                     uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Decrements particular Value block with specified value using absolute Block address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented sector_address Absolute Sector address block_in_sector_address Block address in Sector auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Decrements particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare
    *
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrement_PK(int32_t decrement_value, uint8_t sector_address, uint8_t block_in_sector_address,
                                                     uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Returns reader hardware version as two byte representation of higher and lower byte.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @param version_major pointer to version major variable
    * @param version_minor pointer to version minor variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderHardwareVersion(VAR uint8_t *version_major, VAR uint8_t *version_minor);

    /**
    * @brief Returns reader firmware version as two byte representation of higher and lower byte.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @param version_major pointer to version major variable
    * @param version_minor pointer to version minor variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderFirmwareVersion(VAR uint8_t *version_major, VAR uint8_t *version_minor);

    /**
    * @brief Function returns a 6 bytes array of uint8_t that represents the current date and time into the device's RTC.
    * 
    * * Byte 0 represent year (current year - 2000)
    * * Byte 1 represent month (1 - 12)
    * * Byte 2 represent day of the month (1 - 31)
    * * Byte 3 represent hour (0 - 23)
    * * Byte 4 represent minute (0 - 59)
    * * Byte 5 represent second (0 - 59)
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RTC
    *
    * @param time pointer to the 6 bytes array containing date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderTime(VAR uint8_t *time);

    /**
    * @brief Function sets the date and time into the device's RTC. 
    * 
    * Function requires the 8 bytes password entry to set  date and time. Date and time are represented into a 6 bytes array in the same way as in the GetReaderTime function. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RTC
    *
    * @param password pointer to the 8 bytes array containing password time pointer to the 6 bytes array containing date and time representation
    * @param time pointer to the 6 bytes array containing date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetReaderTime(IN uint8_t *password, VAR uint8_t *time);

    /**
    * @brief This function is used in Common, Advance and Access Control set of functions.
    * 
    * It defines/changes password which I used for:
    * * Locking/unlocking keys stored into reader
    * * Setting date/time of RTC
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param old_password pointer to the 8 bytes array containing current password
    * @param new_password pointer to the 8 bytes array containing new password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ChangeReaderPassword(IN uint8_t *old_password, IN uint8_t *new_password);

    /**
    * @brief Function writes array of data into EEPROM. Maximal length of array is 128 bytes. 
    * 
    * Function requires password which length is 8 bytes. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param data pointer to array containing data
    * @param address address of first data
    * @param size length of array password pointer to array containing password Functions that works with Mifare Desfire Card  (AES encryption in reader) AES encryption and decryption is performed in the reader. AES keys are stored into reader.
    * @param password pointer to array containing password Functions that works with Mifare Desfire Card  (AES encryption in reader) AES encryption and decryption is performed in the reader. AES keys are stored into reader.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderEepromWrite(IN uint8_t *data, uint32_t address, uint32_t size, IN uint8_t *password);

    /**
    * @brief Function returns array of data read from EEPROM. Maximal length of array is 128 bytes.
    *
    * @ingroup ReaderAndLibrary_EEPROM
    *
    * @param data pointer to array containing data from EEPROM
    * @param address address of first data
    * @param size length of array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderEepromRead(OUT uint8_t *data, uint32_t address, uint32_t size);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API SubscribeSector(uint8_t block_nr, uint32_t admin_serial);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API SubscribeBlock(uint8_t block_nr, uint32_t admin_serial);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API BusAdminCardMake(uint32_t serial, IN uint8_t *password);

    /**
    * @brief Returns reader’s descriptive name as a row of 8 chars.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @param pSerialDescription pointer to pSerialDescription array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderSerialDescription(OUT uint8_t pSerialDescription[8]);

    /**
    * @brief Returns reader firmware build version as one byte representation.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @param build pointer to build variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetBuildNumber(VAR uint8_t *build);

    /**
    * @brief This function returns UID of card actually present in RF field of reader. It can handle all three known types : 4, 7 and 10 byte long UIDs.
    * 
    * This function is recommended for use instead of GetCardId.
    *
    * @ingroup Card_Tag_General
    *
    * @param lpucSak returns pointer to variable which holds card type according to SAK
    * @param aucUid returns pointer to array of card UID bytes, variable length
    * @param lpucUidSize returns pointer to variable holding information about UID length
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCardIdEx(VAR uint8_t *lpucSak, OUT uint8_t *aucUid, VAR uint8_t *lpucUidSize);

    /**
    * @brief This function returns UID of last card which was present in RF field of reader. 
    * 
    * It can handle all three known types : 4, 7 and 10 byte long UIDs. Difference with GetCardIdEx is that card does not be in RF field mandatory, UID value is stored in temporary memory area.
    *
    * @ingroup Card_Tag_General
    *
    * @param lpucSak returns pointer to variable which holds card type according to SAK
    * @param aucUid returns pointer to array of card UID bytes, variable length
    * @param lpucUidSize returns pointer to variable holding information about UID length
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetLastCardIdEx(VAR uint8_t *lpucSak, OUT uint8_t *aucUid, VAR uint8_t *lpucUidSize);

    //------------------------------------------------------------------------------
    // Multi-card (anti collision) mode:
    //------------------------------------------------------------------------------
    /**
    * @brief This function puts the reader in an “anti-collision” mode of operation.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EnableAntiCollision(void);

    /**
    * @brief Exits from “anti-collision” mode of operation i.e. put the reader in to “single card” mode of operation.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DisableAntiCollision(void);

    /**
    * @brief If the reader is in an “anti-collision” mode of operation, this function enumerates cards which are found in the reader field. 
    * 
    * Otherwise the function returns ANTI_COLLISION_DISABLED status code.
    * All the calls to the ListCards(), SelectCard() and DeselectCard() work with UIDs from the actual UID list of the enumerated cards, which is obtained by the last call of this function.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision
    *
    * @param lpucCardsNumber If the function is successfully executed, the memory location on which this pointer points to, will contain a number of the enumerated cards.
    * @param lpucUidListSize If the function is successfully executed, the memory location on which this pointer points to, will contain a UID list of the enumerated cards size in bytes.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EnumCards(VAR uint8_t *lpucCardsNumber, OUT uint8_t *lpucUidListSize); // Card pointer is on the first card in list
    /**
    * @brief For each UID of the cards detected in the reader field, there are 11 “UID record bytes” allocated in the list. 
    * 
    * First of those 11 bytes allocated designate actual UID length immediately followed by the exactly 10 bytes of UID (which is maximum hypothetical UID size). E.g, if the actual UID length is 4 bytes, you should ignore last 6 bytes of the UID record.
    * Before calling this function you have to call EnumCards() first. 
    * @ingroup Card_Tag_CardFeatures_AntiCollision
    *
    * @param aucUidList Pointer to the memory alocated for the UID list. Before calling this function, you should alocate atleast *lpucUidListSize bytes which is returned by the prior call to EnumCards() function.
    * @param ucUidListSize Size (in bytes) of the array alocated on the memory location aucUidList points to.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ListCards(OUT uint8_t *aucUidList, uint8_t ucUidListSize); // Before calling this function you must call EnumCards() first.
    /**
    * @brief Selects one of the cards which UID is on the actual UID list of the enumerated cards. 
    * 
    * If there is any of the cards previously selected calling this function you will get an CARD_ALREADY_SELECTED status code and, in such a case, you should call DeslectCard() function prior using SelectCard(). If UID list of the enumerated cards is empty, you will get an NO_TAGS_ENUMERRATED status code.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision
    *
    * @param aucUid pointer to the byte array containing UID of the card which is to be selected
    * @param ucUidSize actual UID size
    * @param lpucSelctedCardType pointer to byte which will contain DlogicCardType constant of the selected card, in case of successful execution of this function
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SelectCard(IN const uint8_t *aucUid, uint8_t ucUidSize, OUT uint8_t *lpucSelctedCardType);

    /**
    * @brief If the reader is in a “anti-collision” mode of operation, this function deselects currently selected card. 
    * 
    * Otherwise function returns ANTI_COLLISION_DISABLED status code.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DeslectCard(void);

    /**
    * @brief Calling this function you can get current anti-collision status of the reader.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision
    *
    * @param lpcIsAntiCollEnabled pointer to byte which will contain 1 if reader is in a “anti-collision” mode of operation, 0 otherwise
    * @param lpcIsAnyCardSelected pointer to byte which will contain 1 if reader is in a “anti-collision” mode of operation and there is selected card, 0 otherwise
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAntiCollisionStatus(VAR int8_t *lpcIsAntiCollEnabled, VAR int8_t *lpcIsAnyCardSelected);
    //------------------------------------------------------------------------------
    /**
    * @brief This function returns card type according to DlogicCardType enumeration. 
    * 
    * For details, please refer to Appendix: DLogic CardType enumeration.
    * If the card type is not supported, function return the lpucCardType value equal to zero : TAG_UNKNOWN = 0x00
    *
    * @ingroup Card_Tag_General
    *
    * @param lpucCardType pointer to lpucCardType variable. Variable lpucCardType holds returned value of actual card type present in RF field.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetDlogicCardType(VAR uint8_t *lpucCardType);

    /**
    * @brief This function returns 8 bytes of the T2T version. 
    * 
    * All modern T2T chips support this functionality and have in common a total of 8 byte long version response. This function is primarily intended to use with NFC_T2T_GENERIC tags (i.e. tags which return 0x0C in the *lpucCardType parameter of the GetDlogicCardType()).
    *
    * @ingroup Card_Tag_NTAG_2XX
    *
    * @param lpucVersionResponse array containing 8 bytes which will receive raw T2T version.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetNfcT2TVersion(OUT uint8_t lpucVersionResponse[8]);

    /**
    * @brief Function returns  size of user data space on the card (LinearSize), and size of total data space on the card (RawSize). 
    * 
    * The user data space is accessed via functions LinearWrite and LinearRead. Total data space is accessed via functions LinRowWrite and LinRowRead. For example Mifare Classic 1K card have 752 bytes of user data space (sector trailers and block 0 are not included), and 1024 bytes of total data space.
    *
    * @ingroup Card_Tag_General
    *
    * @param lpulLinearSize pointer to variable which contain size of user data space lpulRawSize pointer to variable which contain size of total data space
    * @param lpulRawSize pointer to variable which contain size of total data space
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCardSize(VAR uint32_t *lpulLinearSize, VAR uint32_t *lpulRawSize);

    /**
    * @brief Function provides the information about the tag tamper status which is detected when the NTAG 213 TT is powered by an RF field.
    *
    * @ingroup Miscellaneous
    *
    * @param tt_message 4 byte Tag Tamper message. “0000” is returned, if the NTAG 213 TT has never detected the Tag Tamper as opened during the startup. If the NTAG 213 TT has once detected the tag tamper wire as opened, it returns the data which have been programmed in page 45 (TT_MESSAGE)
    * @param tt_status status of the tag tamper wire detected during startup. “C” if Tag Tamper was closed at current startup “O” if Tag Tamper was open at current startup “I” if Tag Tamper measurement was incorrect
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadTTStatus(OUT uint8_t *tt_message, VAR uint8_t *tt_status);
    //------------------------------------------------------------------------------
    /**
    * @brief Function returns “mobile additional” data if the tag in the reader field is actually the selected HCE application in a mobile phone with the appropriate AID which can be set using the SetMobileUniqueIdAid() API. 
    * 
    * The indication that the HCE application in the mobile phone with the corresponding AID is actually selected is the card type code 0x60 (DL_MOBILE_AID) obtained by the previous call to the GetDlogicCardType() or GetCardIdEx() API.
    *
    * @ingroup Card_Tag
    *
    * @param data Array of bytes that should have at least 32 bytes previously allocated.
    * @param len Pointer to the variable containing actual size of the data array before calling this function and after the successful execution contains size of the data returned by the reader (max. 32 bytes)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetMobileAdditionalData(OUT uint8_t data[32], VAR uint32_t *len);

    /**
    * @brief Function returns reader’s serialized discovery loop structure.
    * 
    * C union (following gcc example):
    * typedef union {
    * __attribute ((packed)) struct {
    * uint16_t flags;
    * uint32_t RFU;
    * };
    * __attribute ((packed)) struct {
    * uint8_t byte0;
    * uint8_t byte1;
    * uint32_t RFU;
    * } bytes;
    * __attribute ((packed)) struct {
    * uint8_t legacy:1;
    * uint8_t enable_type_a:1;
    * uint8_t enable_type_b:1;
    * uint8_t enable_apple_ecp:1;
    * uint8_t enable_hce:1;
    * uint8_t auto_select_dlogic_aid:1;
    * uint8_t auto_select_apple_vas:1;
    * uint8_t auto_select_google_vas:1;
    * uint8_t RFU_flags;
    * uint32_t RFU;
    * } bits;
    * } discovery_loop_setup_t;
    * sizeof (discovery_loop_setup_t) is 6 bytes.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures
    *
    * @param setupStruct Pointer to the array of bytes that should have at least sizeof (discovery_loop_setup_t) i.e. 6 bytes previously allocated.
    * @param len Pointer to the variable containing actual size of the data array before calling this function (at least sizeof (discovery_loop_setup_t) i.e. 6 bytes) and after the successful execution contains size of the data returned by the reader.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetDiscoveryLoopSetup(OUT uint8_t *setupStruct, VAR uint32_t *len);

    /**
    * @brief Function sets the reader’s discovery loop.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures
    *
    * @param setupStruct Pointer to the serialized discovery loop structure.
    * @param len Size of the serialized discovery loop structure. e.g. sizeof (discovery_loop_setup_t) i.e. 6 bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetDiscoveryLoop(IN const uint8_t *setupStruct, uint32_t len);

    /**
    * @brief Function returns the AID set in the reader to retrieve the mobile phone's unique ID. 
    * 
    * If the reader’s AID has never been set using SetMobileUniqueIdAid(), the function returns UFR_READING_ERROR status and the reader uses the default AID which is
    * {0xF0, 0x01, 0x02, 0x03, 0x04, 0x05}.
    * Minimum AID length is 5 bytes. Maximum AID len is 16 bytes.
    * For details, see the example project at the
    * https://www.d-logic.com/code/nfc-rfid-reader-sdk/ufr-aid_for_mobile_unique_id_setup.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures
    *
    * @param aid Pointer to the array of bytes that should have at least 16 bytes previously allocated.
    * @param len Pointer to the variable containing actual size of the data array before calling this function (at least 16) and after the successful execution contains size of the data returned by the reader (max. 16 bytes)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetMobileUniqueIdAid(OUT uint8_t *aid, VAR uint32_t *len);

    /**
    * @brief Function sets the reader’s AID to retrieve the mobile phone's unique ID. 
    * 
    * Minimum AID length is 5 bytes. Maximum AID len is 16 bytes.
    * The default (factory) uFR AID is {0xF0, 0x01, 0x02, 0x03, 0x04, 0x05}.
    * Minimum AID length is 5 bytes. Maximum AID len is 16 bytes.
    * For details, see the example project at the
    * https://www.d-logic.com/code/nfc-rfid-reader-sdk/ufr-aid_for_mobile_unique_id_setup.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures
    *
    * @param aid Pointer to the array of bytes containing the new AID.
    * @param len Size of the new AID in bytes.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetMobileUniqueIdAid(IN const uint8_t *aid, uint32_t len);
    //------------------------------------------------------------------------------

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ATECC608LockConfig(void);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ATECC608LockDataAndOtp(void);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ATECC608LockKeySlot(uint8_t key_slot);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608DefaultSlotsConfiguration(void);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608DefaultKeysConfiguration(void);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608IOSecretKey(void);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608ECCPrivateKeyUnencrypted(uint8_t key_slot, uint8_t pub_key_id[4], uint8_t bool_enabled,
                                                          uint8_t merchant_id[32], uint8_t ecc_priv_key[32]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608ECCPrivateKey(uint8_t key_slot, uint8_t pub_key_id[4], uint8_t bool_enabled,
                                               uint8_t merchant_id[32], uint8_t ecc_priv_key[32]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608ConfigZone(uint8_t config_zone[128]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608OtpZone(uint8_t otp_zone[64]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608ZonesLockStatus(VAR uint8_t *bool_config_zone_locked, VAR uint8_t *bool_otp_zone_locked);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608InfoRevision(uint8_t revision[4]);
    //------------------------------------------------------------------------------

    // uFCoder PRO MODE
    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetReaderProMode(VAR uint32_t *pReaderProMode, OUT uint32_t *pReaderProConfig);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetReaderProMode(const uint32_t ReaderProMode);

    // QR barcode crypt algorithm
    // initialization. with TB serial like 'TB123456'
    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_Initialize(IN const uint8_t *TBSerialString, uint16_t job_number);

    // You must define 25 bytes array in memory for out_card_data[]
    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetNextEncryptedCard(const uint32_t from_timestamp, const uint32_t to_timestamp,
                                                          OUT uint8_t out_card_data[]);

    enum CARD_ENCRYPTION_CODE_TYPE
    {
        CODE_TYPE_STANDARD,
        CODE_TYPE_GROUP,
        CODE_TYPE_DAILY_RANGE, // valid from, but only to_timestamp / every day
    };

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetNext(const uint32_t code_type, const uint32_t from_timestamp, const uint32_t to_timestamp,
                                             const uint32_t additional_data_size, IN const uint8_t additional_data[],
                                             VAR uint32_t *out_card_data_size, OUT uint8_t out_card_data[]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetActualCardSN(OUT uint32_t *ActualCard_SN, VAR uint32_t *ActualCard_SN_LOG);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetJobSN(VAR uint32_t *JobSN);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetSalterSN(OUT uint8_t SalterSN[8], VAR uint8_t *magicByte);

    /**
    * @brief Function returns TNF, type of record, ID and payload from the NDEF record. 
    * 
    * NDEF record shall be elected by the message ordinal and record ordinal in this message.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param record_nr NDEF record ordinal (in message)
    * @param tnf pointer to the variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    *
    * @return Operation status
    */
    UFR_STATUS DL_API read_ndef_record(uint8_t message_nr, uint8_t record_nr, VAR uint8_t *tnf, OUT uint8_t *type_record,
                                       VAR uint8_t *type_length, OUT uint8_t *id, VAR uint8_t *id_length, OUT uint8_t *payload,
                                       VAR uint32_t *payload_length);

    /**
    * @brief Function adds a record to the end of message, if one or more records already exist in this message. If current message is empty, then this empty record will be replaced with the record. 
    * 
    * Parameters of function are: ordinal of message, TNF, type of record, ID, payload. Function also returns pointer to the variable which reported that the card formatted for NDEF using (card does not have a capability container, for example new Mifare Ultralight, or Mifare Classic card).
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param tnf pointer to variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    * @param card_formated pointer to the variable which shows that the card formatted for NDEF using.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API write_ndef_record(uint8_t message_nr, IN uint8_t *tnf, IN uint8_t *type_record, IN uint8_t *type_length, IN uint8_t *id,
                                        IN uint8_t *id_length, IN uint8_t *payload, IN uint32_t *payload_length, VAR uint8_t *card_formated);

    /**
    * @brief This function works the same as the write_ndef_record(), with the additional “UID and / or NFC counter mirror” features support. 
    * 
    * 
    * NTAG 21x family of devices offers these specific features. For details about “ASCII mirror” features refer to http://www.nxp.com/docs/en/data-sheet/NTAG213_215_216.pdf (in Rev. 3.2 from 2. June 2015, page 20) and http://www.nxp.com/docs/en/data-sheet/NTAG210_212.pdf (in Rev. 3.0 from 14. March 2013, page 16).
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param tnf pointer to variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    * @param card_formated pointer to the variable which shows that the card formatted for NDEF using.
    * @param use_uid_ascii_mirror if use_uid_ascii_mirror == 1 then “UID ASCII Mirror” feature is in use. if use_uid_ascii_mirror == 0 then “UID ASCII Mirror” feature is switched off.
    * @param use_counter_ascii_mirror if use_counter_ascii_mirror == 1 then “NFC counter ASCII Mirror” feature is in use. if use_counter_ascii_mirror == 0 then “NFC counter ASCII Mirror” feature is switched off.
    * @param payload_mirroring_pos Defines the starting position of the “ASCII Mirror” into the NDEF record payload.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API write_ndef_record_mirroring(uint8_t message_nr, IN uint8_t *tnf, IN uint8_t *type_record, IN uint8_t *type_length,
                                                  IN uint8_t *id, IN uint8_t *id_length, IN uint8_t *payload, IN uint32_t *payload_length,
                                                  VAR uint8_t *card_formated, int use_uid_ascii_mirror, int use_counter_ascii_mirror, uint32_t payload_mirroring_pos);

    /**
    * @brief This function works the same as the write_ndef_record(), with the additional “UID and / or NFC counter mirror” features support. 
    * 
    * NTAG 21x family of devices offers these specific features. For details about “ASCII mirror” features refer to http://www.nxp.com/docs/en/data-sheet/NTAG213_215_216.pdf (in Rev. 3.2 from 2. June 2015, page 20) and http://www.nxp.com/docs/en/data-sheet/NTAG210_212.pdf (in Rev. 3.0 from 14. March 2013, page 16).
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param tnf pointer to variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    * @param card_formated pointer to the variable which shows that the card formatted for NDEF using.
    * @param use_uid_ascii_mirror if use_uid_ascii_mirror == 1 then “UID ASCII Mirror” feature is in use. if use_uid_ascii_mirror == 0 then “UID ASCII Mirror” feature is switched off.
    * @param use_counter_ascii_mirror if use_counter_ascii_mirror == 1 then “NFC counter ASCII Mirror” feature is in use. if use_counter_ascii_mirror == 0 then “NFC counter ASCII Mirror” feature is switched off. payload_mirroring_pos Defines the starting position of the “ASCII Mirror” into the NDEF record payload.
    * @param use_tt_message_mirror if use_tt_message_mirror == 1 then Tag tamper status mirroring is enabled
    * @param payload_mirroring_pos Defines the starting position of the “ASCII Mirror” into the NDEF record payload.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API write_ndef_record_mirroring_tt(uint8_t message_nr, IN uint8_t *tnf, IN uint8_t *type_record, IN uint8_t *type_length,
                                                     IN uint8_t *id, IN uint8_t *id_length, IN uint8_t *payload, IN uint32_t *payload_length,
                                                     VAR uint8_t *card_formated, int use_uid_ascii_mirror, int use_counter_ascii_mirror,
                                                     int use_tt_message_mirror, uint32_t payload_mirroring_pos);

    /**
    * @brief Function returns the number of NDEF messages that have been read from the card, and number of NDEF records, number of NDEF empty messages. 
    * 
    * Also, function returns array of bytes containing number of messages pairs. First byte of pair is message ordinal, and second byte is number of NDEF records in that message. Message ordinal starts from 1.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_message_cnt pointer to the variable containing number of NDEF messages
    * @param ndef_record_cnt pointer to the variable containing number of NDEF record
    * @param ndef_record_array pointer to the array of bytes containing pairs (message ordinal - number of records)
    * @param empty_ndef_message_cnt pointer to the variable containing number of empty messages
    *
    * @return Operation status
    */
    UFR_STATUS DL_API get_ndef_record_count(VAR uint8_t *ndef_message_cnt, VAR uint8_t *ndef_record_cnt, OUT uint8_t *ndef_record_array,
                                            VAR uint8_t *empty_ndef_message_cnt);

    /**
    * @brief Function deletes the last record of the selected message. If a message contains one record, then it will be written as an empty message.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message_nr NDEF message ordinal (starts form 1)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API erase_last_ndef_record(uint8_t message_nr);

    /**
    * @brief Function deletes all records of the message, then writes an empty message.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message_nr NDEF message ordinal (starts form 1)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API erase_all_ndef_records(uint8_t message_nr);

    /**
    * @brief Function prepares the card for NDEF using.  Function writes Capability Container (CC) if necessary, and writes empty message.
    * 
    * If the card is MIFARE CLASSIC or MIFARE PLUS, then the function writes MAD (MIFARE Application Directory), and default keys and access bits for NDEF using.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ndef_card_initialization(void);
    //---------------------------------------------------------------------
    // Card emulation:
    //---------------------------------------------------------------------
    /**
    * @brief Function stores a message record for NTAG emulation mode into the reader. 
    * 
    * Parameters of the function are: TNF, type of record, ID, payload. Maximum total size for emulated NDEF message is 144 bytes.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @param tnf TNF of the record
    * @param type_record pointer to the array containing record type
    * @param type_length length of the record type
    * @param id pointer to the array containing record ID
    * @param id_length length of the record ID
    * @param payload pointer to the array containing record payload
    * @param payload_length length of the record payload
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteEmulationNdef(uint8_t tnf, IN uint8_t *type_record, uint8_t type_length, IN uint8_t *id, uint8_t id_length,
                                         IN uint8_t *payload, uint8_t payload_length);

    /**
    * @brief This function does the same as WriteEmulationNdef() function with the addition of an AAR embedded in to the NDEF message. 
    * 
    * AAR stands for “Android Application Record”. AAR is a special type of NDEF record that is used by Google’s Android operating system to signify to an NFC phone that an explicitly defined Android Application which should be used to handle an emulated NFC tag. Android App record will be added as the 2nd NDEF record in the NDEF message.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @param tnf TNF of the record type_record pointer to the array containing record type type_length length of the record type id pointer to the array containing record ID id_length length of the record ID payload pointer to the array containing record payload payload_length length of the record payload aar pointer to the array containing AAR record aar_length length of the AAR record TagEmulationStart Function description Put the reader permanently in a NDEF tag emulation mode. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling  TagEmulationStop() function). In this mode, the reader can only answer to the commands issued by a following library functions: TagEmulationStart(), WriteEmulationNdef(), TagEmulationStop(), GetReaderSerialNumber(), GetReaderSerialDescription(), GetReaderHardwareVersion(), GetReaderFirmwareVersion(), GetBuildNumber() Calls to the other functions in this mode returns following error code: FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90
    * @param type_record pointer to the array containing record type
    * @param type_length length of the record type id pointer to the array containing record ID id_length length of the record ID payload pointer to the array containing record payload payload_length length of the record payload aar pointer to the array containing AAR record aar_length length of the AAR record TagEmulationStart Function description Put the reader permanently in a NDEF tag emulation mode. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling  TagEmulationStop() function). In this mode, the reader can only answer to the commands issued by a following library functions: TagEmulationStart(), WriteEmulationNdef(), TagEmulationStop(), GetReaderSerialNumber(), GetReaderSerialDescription(), GetReaderHardwareVersion(), GetReaderFirmwareVersion(), GetBuildNumber() Calls to the other functions in this mode returns following error code: FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90
    * @param id pointer to the array containing record ID
    * @param id_length length of the record ID payload pointer to the array containing record payload payload_length length of the record payload aar pointer to the array containing AAR record aar_length length of the AAR record TagEmulationStart Function description Put the reader permanently in a NDEF tag emulation mode. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling  TagEmulationStop() function). In this mode, the reader can only answer to the commands issued by a following library functions: TagEmulationStart(), WriteEmulationNdef(), TagEmulationStop(), GetReaderSerialNumber(), GetReaderSerialDescription(), GetReaderHardwareVersion(), GetReaderFirmwareVersion(), GetBuildNumber() Calls to the other functions in this mode returns following error code: FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90
    * @param payload pointer to the array containing record payload
    * @param payload_length length of the record payload aar pointer to the array containing AAR record aar_length length of the AAR record TagEmulationStart Function description Put the reader permanently in a NDEF tag emulation mode. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling  TagEmulationStop() function). In this mode, the reader can only answer to the commands issued by a following library functions: TagEmulationStart(), WriteEmulationNdef(), TagEmulationStop(), GetReaderSerialNumber(), GetReaderSerialDescription(), GetReaderHardwareVersion(), GetReaderFirmwareVersion(), GetBuildNumber() Calls to the other functions in this mode returns following error code: FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90
    * @param aar pointer to the array containing AAR record
    * @param aar_length length of the AAR record TagEmulationStart Function description Put the reader permanently in a NDEF tag emulation mode. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling  TagEmulationStop() function). In this mode, the reader can only answer to the commands issued by a following library functions: TagEmulationStart(), WriteEmulationNdef(), TagEmulationStop(), GetReaderSerialNumber(), GetReaderSerialDescription(), GetReaderHardwareVersion(), GetReaderFirmwareVersion(), GetBuildNumber() Calls to the other functions in this mode returns following error code: FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteEmulationNdefWithAAR(uint8_t tnf, IN uint8_t *type_record, uint8_t type_length, IN uint8_t *id, uint8_t id_length,
                                                IN uint8_t *payload, uint8_t payload_length, IN uint8_t *aar, uint8_t aar_length);

    /**
    * @brief Put the reader permanently in a NDEF tag emulation mode. 
    * 
    * Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling TagEmulationStop() function).
    * In this mode, the reader can only answer to the commands issued by a following library functions:
    * TagEmulationStart(),
    * WriteEmulationNdef(),
    * TagEmulationStop(),
    * GetReaderSerialNumber(),
    * GetReaderSerialDescription(),
    * GetReaderHardwareVersion(),
    * GetReaderFirmwareVersion(),
    * GetBuildNumber()
    * Calls to the other functions in this mode returns following error code:
    * FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationStart(void);

    /**
    * @brief Allows the reader permanent exit from a NDEF tag emulation mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationStop(void);

    /**
    * @brief Puts the uFR reader into a permanently periodical switching from “NDEF tag emulation mode” to “tag reader mode”. 
    * 
    * Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling the TagEmulationStop() function).
    * Much better control of the NFC device in a uFR proximity range can be achieved using Ad-Hoc emulation mode, described before.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_CombinedMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API CombinedModeEmulationStart(void);

    /**
    * @brief Put uFR in emulation mode with ad-hoc emulation parameters (see. SetAdHocEmulationParams() and GetAdHocEmulationParams() functions). 
    * 
    * uFR stays in ad-hoc emulation mode until AdHocEmulationStop() is called or reader reset.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AdHocEmulationStart(void);

    /**
    * @brief Terminate uFR ad-hoc emulation mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AdHocEmulationStop(void);

    /**
    * @brief This function returns  current ad-hoc emulation parameters. 
    * 
    * On uFR power on or reset ad-hoc emulation parameters are set back to their default values.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode
    *
    * @param ThresholdMinLevel default value is 15. Could be in range from 0 to 15.
    * @param ThresholdCollLevel default value is 7. Could be in range from 0 to 7
    * @param RFLevelAmp default value is 0. On uFR device should be 0 all the time. (1 for on, 0 for off).
    * @param RxGain Could be in range from 0 to 7.
    * @param RFLevel Could be in range from 0 to 15.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAdHocEmulationParams(VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel, VAR uint8_t *RFLevelAmp,
                                              VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief This command set ad-hoc emulation parameters. 
    * 
    * On uFR power on or reset ad-hoc emulation parameters are set back to their default values.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode
    *
    * @param ThresholdMinLevel default value is 15. Could be in range from 0 to 15
    * @param ThresholdCollLevel default value is 7. Could be in range from 0 to 7
    * @param RFLevelAmp default value is 0. On uFR device should be 0 all the time. (1 for on, 0 for off).
    * @param RxGain Could be in range from 0 to 7.
    * @param RFLevel Could be in range from 0 to 15 CombinedModeEmulationStart Function description Puts the uFR reader into a permanently periodical switching from “NDEF tag emulation mode” to “tag reader mode”. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling the TagEmulationStop() function). Much better control of the NFC device in a uFR proximity range can be achieved using Ad-Hoc emulation mode, described before. Function declaration (C language) UFR_STATUS CombinedModeEmulationStart(void); Function takes no parameters. ________________ Support for ISO14443-4 protocol
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetAdHocEmulationParams(uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp, uint8_t RxGain,
                                              uint8_t RFLevel);

    /**
    * @brief Returns external field state when uFR is in ad-hoc emulation mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode
    *
    * @param is_field_present value representing whehter field is present (1) or not (0)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetExternalFieldState(VAR uint8_t *is_field_present);

    /**
    * @brief Put reader permanently in the mode that use shared RAM. After execution of this function, must be executed function TagEmulationStart().
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EnterShareRamCommMode(void);

    /**
    * @brief The permanent exit from mode that use shared RAM. After execution of this function, must be executed function TagEmulationStop().
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ExitShareRamCommMode(void);

    /**
    * @brief Function allows writing data to the shared RAM.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM
    *
    * @param ram_data pointer to data array
    * @param addr address of first data in an array
    * @param data_len length of array. Address + data_len <= 184
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteShareRam(IN uint8_t *ram_data, uint8_t addr, uint8_t data_len);

    /**
    * @brief Function allows read data from the shared RAM.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM
    * 
    * @param ram_data buffer containing ram data returned
    * @param addr address from which to read reader RAM
    * @param data_len length of data to read from RAM
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadShareRam(OUT uint8_t *ram_data, uint8_t addr, uint8_t data_len);

    /**
    * @brief Function stores a message record for NTAG emulation mode into the reader in the RAM. 
    * 
    * Parameters of the function are: TNF, type of record, ID, payload. Maximum total size for emulated NDEF message is 1008 bytes. Unlike the function WriteEmulationNdef, the data is not written to the EEPROM of the reader, so they cannot be loaded after the reader is reset. This function must be called after reader reset to use the NTAG emulation.
    * From library version 5.0.31, and firmware version 5.0.33
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @param tnf TNF of the record
    * @param type_record pointer to the array containing record type
    * @param type_length length of the record type
    * @param id pointer to the array containing record ID
    * @param id_length length of the record ID
    * @param payload pointer to the array containing record payload
    * @param payload_length length of the record payload
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteEmulationNdefRam(uint8_t tnf, IN uint8_t *type_record, uint8_t type_length,
                                            IN uint8_t *id, uint8_t id_length, IN uint8_t *payload, uint32_t payload_length);

    /**
    * @brief Put the reader permanently in a NDEF tag in RAM emulation mode. 
    * 
    * Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling  TagEmulationStopRam() function), or by reader reset. Use the function GetReaderStatus to check if the reader is still in emulation mode (maybe the reader was reset for some reason).
    * From library version 5.0.31, and firmware version 5.0.31
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationStartRam(void);

    /**
    * @brief Allows the reader permanent exit from a NDEF tag emulation mode.
    * 
    * From library version 5.0.31, and firmware version 5.0.33
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationStopRam(void);

    /**
    * @brief Function enables the 24 bit NFC counter. 
    * 
    * Counter increased by the first valid READ command in the NTAG emulation mode, after the external RF field detected. Counter is represented in 6 bytes of ASCII code, when the NDEF message is read. For example if the counter value is 0x56, it will be represented as 000056, at the end of the NDEF message. Position of the counter mirror start byte must be entered as a function parameter. This is the absolute position in the card emulation data array.
    * Counter value sets to 0.
    *
    * @param mirror_pos Position in the card emulation data array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationMirrorCounterResetEnabled(uint16_t mirror_pos);

    /**
    * @brief Function enables the 24 bit NFC counter. 
    * 
    * Counter increased by the first valid READ command in the NTAG emulation mode, after the external RF field detected. Counter is represented in 6 bytes of ASCII code, when the NDEF message is read. For example if the counter value is 0x56, it will be represented as 000056, at the end of the NDEF message. Position of the counter mirror start byte must be entered as a function parameter. This is the absolute position in the card emulation data array.
    * Counter value stays unchangeable.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @param mirror_pos Position in the card emulation data array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationMirrorCounterNonResetEnabled(uint16_t mirror_pos);

    /**
    * @brief Function disables the NFC counter in the card emulation mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationMirrorCounterDisabled(void);

    //------------------------------------------------------------------------------

    // GetNfcT2TVersion() returns 8 bytes (see T2T documentation):
    typedef struct t2t_version_struct
    {
        uint8_t header;
        uint8_t vendor_id;
        uint8_t product_type;
        uint8_t product_subtype;
        uint8_t major_product_version;
        uint8_t minor_product_version;
        uint8_t storage_size;
        uint8_t protocol_type;
    } t2t_version_t;

    // NfcT2TSafeConvertVersion() returns converts version_record that returned from GetNfcT2TVersion()
    // or GetNfcT2TVersionM(). Conversion is "alignment safe"
    // (you don't need to pay attention on structure byte alignment):
    /**
    * @brief This is a helper function for converting raw array of 8 bytes received by calling GetNfcT2TVersion(). 
    * 
    * All modern T2T chips having same or very similar structure of the T2T version data represented in the uFR API by the structure type t2t_version_t:
    * typedef struct t2t_version_struct {
    * uint8_t header;
    * uint8_t vendor_id;
    * uint8_t product_type;
    * uint8_t product_subtype;
    * uint8_t major_product_version;
    * uint8_t minor_product_version;
    * uint8_t storage_size;
    * uint8_t protocol_type;
    * } t2t_version_t;
    * This function is primarily intended to use with NFC_T2T_GENERIC tags (i.e. tags which return 0x0C in the *lpucCardType parameter of the GetDlogicCardType()). Conversion done by this function is "alignment safe".
    *
    * @ingroup Card_Tag_NTAG_2XX
    *
    * @param version pointer to the structure of the t2t_version_t type which will receive converted T2T version
    * @param version_record pointer to array containing 8 bytes of the raw T2T version acquired using  function GetNfcT2TVersion()
    *
    */
    void DL_API NfcT2TSafeConvertVersion(t2t_version_t *version, const uint8_t *version_record);

    /**
    * @brief This function returns the ECC signature of the card chip UID. Card chip UID is signed using EC private key known only to a manufacturer.
    *
    * @ingroup Card_Tag_CardFeatures_OriginalityChecking
    *
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucUid pointer to a chip UID (in case of successfully executed operation). Returned here for convenience.
    * @param lpucUidLen pointer to variable which will (in case of successfully executed operation) receive true length of the returned UID. (Maximum UID length is 10 bytes but there is three possible UID sizes: 4, 7 and 10).
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadECCSignature(OUT uint8_t lpucECCSignature[ECC_SIG_LEN], OUT uint8_t lpucUid[MAX_UID_LEN], VAR uint8_t *lpucUidLen,
                                       VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief This function returns the ECC signature of the card chip UID. Card chip UID is signed using EC private key known only to a manufacturer.
    * 
    * Unlike the ReadECCSignature function, this function supports ECC with variable length.
    *
    * @ingroup Card_Tag_CardFeatures_OriginalityChecking
    *
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucECCSignatureLen pointer to ECC signature length
    * @param lpucUid pointer to a chip UID (in case of successfully executed operation). Returned here for convenience.
    * @param lpucUidLen pointer to variable which will (in case of successfully executed operation) receive true length of the returned UID. (Maximum UID length is 10 bytes but there is three possible UID sizes: 4, 7 and 10).
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadECCSignatureExt(OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucECCSignatureLen,
                                          OUT uint8_t *lpucUid, VAR uint8_t *lpucUidLen, VAR uint8_t *lpucDlogicCardType);

    //------------------------------------------------------------------------------
    /**
    * @brief This function is used to read one of the three 24-bit one-way counters in Ultralight EV1 chip family. 
    * 
    * Those counters can’t be password protected. In the initial Ultralight EV1 chip state, the counter values are set to 0.
    *
    * @ingroup Card_Tag_NTAG_2XX
    *
    * @param counter_address Address of the target counter. Can be in range 0 to 2. Counters are mapped in a separate address space.
    * @param value Pointer to a uint32_t which will contained counter value after successful function execution. Since counters are 24-bit in length, most significant byte of the *value will be always 0.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadCounter(uint8_t counter_address, VAR uint32_t *value);

    /**
    * @brief This function is used to increment one of the three 24-bit one-way counters in Ultralight EV1 chip family. 
    * 
    * Those counters can’t be password protected. If the sum of the addressed counter value and the increment value is higher than 0xFFFFFF, the tag replies with an error and does not update the respective counter.
    *
    * @ingroup Card_Tag_NTAG_2XX
    *
    * @param counter_address Address of the target counter. Can be in range 0 to 2. Counters are mapped in a separate address space.
    * @param inc_value Increment value. Only the 3 least significant bytes are relevant.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API IncrementCounter(uint8_t counter_address, uint32_t inc_value);

    /**
    * @brief This function is used to read 24-bit NFC counters in NTAG 213, NTAG 215 and NTAG 216 chips without using password authentication. 
    * 
    * If access to the NFC counter is configured to be password protected, this function will return COUNTER_ERROR.
    *
    * @ingroup Card_Tag_NTAG_2XX
    *
    * @param value Pointer to a uint32_t which will contain counter value after successful function execution. Since counter is 24-bit in length, most significant byte of the *value will always be 0.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNFCCounter(VAR uint32_t *value); // Same as ReadCounter(2, &value);

    /**
    * @brief This function is used to read 24-bit NFC counter in NTAG 213, NTAG 215 and NTAG 216 chips using “reader key password authentication”. 
    * 
    * If access to NFC counter is configured to be password protected and PWD-PACK pair stored as a 6-byte key in uFR reader disagrees with PWD-PACK pair configured in tag, this function will return UFR_AUTH_ERROR. If access to NFC counter isn’t configured to be password protected, this function will return UFR_AUTH_ERROR.
    *
    * @ingroup Card_Tag_NTAG_2XX
    *
    * @param value Pointer to a uint32_t which will contain counter value after successful function execution. Since counter is 24-bit in length, most significant byte of the *value will always be 0.
    * @param reader_key_index Index of the 6-byte key (PWD-PACK pair for this type of NFC tags) stored in the uFR reader. Can be in range 0 to 31.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNFCCounterPwdAuth_RK(VAR uint32_t *value, uint8_t reader_key_index);

    /**
    * @brief Provided Key mode (PK) This function is used to read 24-bit NFC counter in NTAG 213, NTAG 215 and NTAG 216 chips using “reader key password authentication”. 
    * 
    * If access to NFC counter is configured to be password protected and PWD-PACK pair stored as a 6-byte key in uFR reader disagrees with PWD-PACK pair configured in tag, this function will return UFR_AUTH_ERROR. If access to NFC counter isn’t configured to be password protected, this function will return UFR_AUTH_ERROR.
    *
    * @ingroup Card_Tag_NTAG_2XX
    *
    * @param value Pointer to a uint32_t which will contain counter value after successful function execution. Since counter is 24-bit in length, most significant byte of the *value will always be 0.
    * @param key ointer to an array contains provided 6-byte key (PWD-PACK pair for this type of NFC tags) for password authentication.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNFCCounterPwdAuth_PK(VAR uint32_t *value, IN const uint8_t *key);

    //------------------------------------------------------------------------------

    /**
    * @brief This function is used for the “Asynchronous UID sending” feature. Returned string contains hexadecimal notation of card ID with one mandatory suffix character and one optional prefix character.
    * 
    * On the uFR Zero USB series there is an option to enable USB HID keyboard simulation. It is needed to set the baud rate to 0. For example, if baud rate is setted to any other value than 0, UID is sent to UART, but if it is setted to 0 UID is sent as keyboard simulation.
    * Example:
    * Card ID is 0xA103C256, prefix is 0x58 ('X'), suffix is 0x59 ('Y')
    * Returned string is “XA103C256Y”
    * Function sets configuration parameters for this feature.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending
    *
    * @param send_enable turn feature on/off (0/1)
    * @param prefix_enable use prefix or not (0/1)
    * @param prefix prefix character
    * @param suffix suffix character
    * @param send_removed_enable Turn feature on/off (0/1). If feature is enabled then Asynchronous UID will also be sent when removing a card from the reader field.
    * @param async_baud_rate baud rate value (e.g. 9600)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetAsyncCardIdSendConfig(uint8_t send_enable, uint8_t prefix_enable, uint8_t prefix, uint8_t suffix,
                                               uint8_t send_removed_enable, uint32_t async_baud_rate);

    /**
    * @brief Function sets the parameters of card ID sending.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending
    *
    * @param send_enable turn feature on/off (0/1)
    * @param prefix_enable use prefix or not (0/1)
    * @param prefix prefix character
    * @param suffix suffix character
    * @param send_removed_enable Turn feature on/off (0/1). If feature is enabled then Asynchronous UID will also be sent when removing a card from the reader field.
    * @param reverse_byte_order Turn feature on/off (0/1). If feature is disabled then the order of bytes (UID) will be as on card. If feature is enabled then the order of bytes will be reversed then the card’s order of bytes.
    * @param decimal_representation Turn feature on/off (0/1). If feature is enabled then the UID will be presented as a decimal number. If feature is disabled then the UID will be presented as a hexadecimal number
    * @param async_baud_rate baud rate value (e.g. 9600)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetAsyncCardIdSendConfigEx(uint8_t send_enable, uint8_t prefix_enable, uint8_t prefix, uint8_t suffix,
                                                 uint8_t send_removed_enable, uint8_t reverse_byte_order, uint8_t decimal_representation,
                                                 uint32_t async_baud_rate);

    /**
    * @brief Returns info about parameters configured with previous function.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending
    *
    * @param send_enable pointer, if feature is on/off (0/1)
    * @param prefix_enable pointer, if prefix is used or not (0/1)
    * @param prefix pointer to variable holding prefix character
    * @param suffix pointer to variable holding suffix character
    * @param send_removed_enable Pointer. If value is 0 then feature is off. Otherwise, feature is on. If feature is enabled then Asynchronous UID is sent when the card is removed from the reader field.
    * @param async_baud_rate pointer to variable holding configured baud rate
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAsyncCardIdSendConfig(VAR uint8_t *send_enable, VAR uint8_t *prefix_enable, VAR uint8_t *prefix, VAR uint8_t *suffix,
                                               VAR uint8_t *send_removed_enable, VAR uint32_t *async_baud_rate);

    /**
    * @brief Function returns the parameters of card ID sending.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending
    *
    * @param send_enable pointer, if feature is on/off (0/1)
    * @param prefix_enable pointer, if prefix is used or not (0/1)
    * @param prefix pointer to variable holding prefix character
    * @param suffix pointer to variable holding suffix character
    * @param send_removed_enable Pointer. If value is 0 then feature is off. Otherwise, feature is on. If feature is enabled then Asynchronous UID is sent when the card is removed from the reader field.
    * @param reverse_byte_order Turn feature on/off (0/1). If feature is disabled then the order of bytes (UID) will be as on card. If feature is enabled then the order of bytes will be reversed then the card’s order of bytes.
    * @param decimal_representation Turn feature on/off (0/1). If feature is enabled then the UID will be presented as a decimal number. If feature is disabled then the UID will be presented as a hexadecimal number
    * @param async_baud_rate pointer to baud rate variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAsyncCardIdSendConfigEx(VAR uint8_t *send_enable, VAR uint8_t *prefix_enable, VAR uint8_t *prefix, VAR uint8_t *suffix,
                                                 VAR uint8_t *send_removed_enable, VAR uint8_t *reverse_byte_order,
                                                 VAR uint8_t *decimal_representation, VAR uint32_t *async_baud_rate);

    /**
    * @brief *uFR Zero series readers only. Function to set custom RGB UI signalization
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl
    *
    * @param idle_mode idle mode value
    * @param card_detection_mode card detection mode value
    * @param idle_color idle color value(RGB)
    * @param card_detection_color card detection color value(RGB)
    * @param enabled enabled flag
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetCustomUiConfig(uint8_t idle_mode, uint8_t card_detection_mode, uint8_t *idle_color, uint8_t *card_detection_color, uint8_t enabled);

    /**
    * @brief *uFR Zero series readers only. Function to get custom RGB UI signalization
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl
    *
    * @param idle_mode pointer to idle mode value
    * @param card_detection_mode pointer to card detection mode value
    * @param idle_color pointer to idle color value(RGB)
    * @param card_detection_color pointer to card detection color value(RGB)
    * @param enabled pointer to enabled flag
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCustomUiConfig(uint8_t *idle_mode, uint8_t *card_detection_mode, uint8_t *idle_color, uint8_t *card_detection_color, uint8_t *enabled);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_number(VAR uint32_t *card_number);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_right_record(uint8_t record_number, uint16_t first_reader_nr, uint16_t last_reader_nr, uint8_t start_hour,
                                           uint8_t start_minute, uint8_t end_hour, uint8_t end_minute, IN uint8_t *days);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_right_record(uint8_t record_number, VAR uint16_t *first_reader_nr, VAR uint16_t *last_reader_nr,
                                           VAR uint8_t *start_hour, VAR uint8_t *start_minute, VAR uint8_t *end_hour, VAR uint8_t *end_minute,
                                           OUT uint8_t *days);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_erase_right_record(uint8_t record_number);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_validate_record(uint8_t begin_year, uint8_t begin_month, uint8_t begin_day, uint8_t begin_hour,
                                              uint8_t begin_minute, uint8_t end_year, uint8_t end_month, uint8_t end_day, uint8_t end_hour,
                                              uint8_t end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_validate_record(VAR uint8_t *begin_year, VAR uint8_t *begin_month, VAR uint8_t *begin_day,
                                              VAR uint8_t *begin_hour, VAR uint8_t *begin_minute, VAR uint8_t *end_year, VAR uint8_t *end_month,
                                              VAR uint8_t *end_day, VAR uint8_t *end_hour, VAR uint8_t *end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_card_type(uint8_t card_type);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_type(VAR uint8_t *card_type);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_card_daily_duration(uint16_t duration);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_daily_duration(VAR uint16_t *duration);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_card_total_duration(uint32_t duration);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_total_duration(VAR uint32_t *duration);

    // swimming pool **************************************************************

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_credit_and_period_validity(VAR int32_t *credit, VAR uint32_t *begin_year, VAR uint32_t *begin_month,
                                                         VAR uint32_t *begin_day, VAR uint32_t *begin_hour,
                                                         VAR uint32_t *begin_minute, //
                                                         VAR uint32_t *end_year, VAR uint32_t *end_month, VAR uint32_t *end_day,
                                                         VAR uint32_t *end_hour, VAR uint32_t *end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_credit_and_period_validity(int32_t credit, uint32_t begin_year, uint32_t begin_month, uint32_t begin_day,
                                                         uint32_t begin_hour,
                                                         uint32_t begin_minute, //
                                                         uint32_t end_year, uint32_t end_month, uint32_t end_day, uint32_t end_hour,
                                                         uint32_t end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_right_type_record(uint8_t record_number, uint8_t right_record_type, IN uint8_t *right_data);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_right_type_record(uint8_t record_number, VAR uint8_t *right_record_type, OUT uint8_t *right_data);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_right_record_type_max_daily_counter(uint8_t record_number, uint16_t first_reader_nr, uint16_t last_reader_nr,
                                                                  uint8_t start_hour, uint8_t start_minute, uint8_t end_hour,
                                                                  uint8_t end_minute, IN uint8_t *days, uint8_t max_daily_counter);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_right_record_type_max_daily_counter(uint8_t record_number, VAR uint16_t *first_reader_nr,
                                                                  VAR uint16_t *last_reader_nr, VAR uint8_t *start_hour,
                                                                  VAR uint8_t *start_minute, VAR uint8_t *end_hour, VAR uint8_t *end_minute,
                                                                  OUT uint8_t *days, VAR uint8_t *max_daily_counter);

    //=============================================================================

    /**
    * @brief Electric strike switches when the function is called. Pulse duration determined by function.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR
    *
    * @param pulse_duration pulse_duration is strike switch on period in ms
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrXrcLockOn(uint16_t pulse_duration);

    /**
    * @brief Function switches relay.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR
    *
    * @param state if the state is 1, then relay is switch on, and if state is 0, then relay is switch off
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrXrcRelayState(uint8_t state);

    /**
    * @brief Function returns states of 3 IO pins.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR
    *
    * @param intercom shows that there is voltage at the terminals for intercom connection, or notss
    * @param door shows that the door's magnetic switch opened or closed
    * @param relay_state is 1 if relay switch on, and 0 if relay switch off
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrXrcGetIoState(VAR uint8_t *intercom, VAR uint8_t *door, VAR uint8_t *relay_state);

    /**
    * @brief Function controls the output pin on the reader.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR
    *
    * @param output_nr ordinal number of hardware specific output pin
    * @param invert 1 output is inverted, 0 output is normal
    * @param cycle_nr Number of on-off cycles. If the cycle number is 0, the output state will be infinite, or until this will be changed with the next function call (output state is 1 if the invert is 0, and 0 if invert is 1).
    * @param on_duration On duration in ms. If the invert is 0 output state is 1, and if invert is 1 output state is 0.
    * @param off_duration Off duration in ms. If the invert is 0 output state is 0, and if invert is 1 output state is 1. This state of the output pin remains after the completion of the on-off cycle.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrOutControl(uint8_t output_nr, uint8_t invert, uint8_t cycle_nr, uint8_t on_duration, uint8_t off_duration);

    /**
    * @brief Function gets the state of the input pin on the reader.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR
    *
    * @param input_nr ordinal number of hardware specific input pin input_state input state 1 or 0.
    * @param input_state input state 1 or 0.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrGetInputState(uint8_t input_nr, VAR uint8_t *input_state);

    /**
    * @brief This function turns Red LED only.
    * If “light_status” value is 1, red light will be constantly turned on until receive “light_status “ value 0.
    *
    * @ingroup ReaderAndLibrary_Signalization
    *
    * @param light_status value 0 or 1
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRedLightControl(uint8_t light_status);

    /**
    * @brief For classic uFR PLUS devices only. The function prohibits the blinking of the green diode (if this option is set), and sets color on RGB diodes. 
    * 
    * This color stays on diodes until this function sets the parameter "enable"  to 0.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization
    *
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    * @param intensity value of color intensity in percent (0 - 100)
    * @param enable 1 - enable 0 - disable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbLightControl(uint8_t red, uint8_t green, uint8_t blue, uint8_t intensity, uint8_t enable);

    /**
    * @brief Sets the color of the RGB diodes. 
    * 
    * This color stays on the RGB diodes until the function GreenLedBlinkingTurnOn() is called. Intensity of light is defined by a parameter stored using the function SetRgbIntensity().
    * Before this function call, the function GreenLedBlinkingTurnOff() must be called, or the reader is already in mode of blocking automatic signalization. 
    * @ingroup ReaderAndLibrary_RGBSignalization
    *
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbControl(uint8_t red, uint8_t green, uint8_t blue);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbExtLightControl(uint8_t enable);

    /**
    * @brief The function sets color on the RGB diodes. 
    * 
    * This setting will appear when the reader is in sleep mode. Function adjusts the period, and duration of impulse of light. The period is a product of approximately two seconds (2s, 4s, 6s, 8s,...). Maximal duration of impulse of light is 2000 ms.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization
    *
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    * @param intensity value of color intensity in percent (0 - 100)
    * @param period number of the 2 seconds period. (1 = 2s, 2 = 4s, 3 = 6s, …)
    * @param duration duration of impulse of light in ms.
    * @param enable 1 - enable 0 - disable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbLightControlSleep(uint8_t red, uint8_t green, uint8_t blue, uint8_t intensity,
                                              uint8_t period, uint16_t duration, uint8_t enable);

    /**
    * @brief The function sets color on the RGB diodes, period of inactivity NFC RF and RGB, and duration of activity NFC RF and RGB. 
    * 
    * In the inactivity period NFC RF is off, and RGB light is off. In the activity period NFC RF is on, and RGB may be on. 
    * Function also sets the number of omitted activity periods, when the RGB light is off. 
    * For example if the inactivity period is 400ms, activity duration is 50ms, and number of omitted activity periods is 5, RGB lights will be on 50ms at every 2250ms.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization
    *
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    * @param intensity value of color intensity in percent (0 - 100)
    * @param period inactivity period in ms
    * @param duration duration of activity period in ms
    * @param rgb_omitted_cnt number of omitted activity periods
    * @param enable 1 - enable 0 - disable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbLightControlRfPeriod(uint8_t red, uint8_t green, uint8_t blue, uint8_t intensity,
                                                 uint16_t period, uint16_t duration, uint8_t rgb_omitted_cnt, uint8_t enable);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbIdleSet(uint8_t red, uint8_t green, uint8_t blue);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbIdleDefault(void);

    /**
    * @brief The function allows you to set the number of unsuccessful card selections before it can be considered that the card is not placed on the reader. 
    * 
    * Period between two card selections is approximately 10ms. Default value of this parameter is 20 i.e. 200ms. This parameter can be set in the range of 0 to 254.
    * This is useful for asynchronous card ID transmission, if parameter send_removed_enable in function SetAsyncCardIdSendConfig is set. Then you can set a lower value of the number of unsuccessful card selections,  in order to send information to the card removed was faster.
    * A small value of this parameter may cause a false report that the card is not present, and immediately thereafter true report that the card is present.
    *
    * @ingroup ReaderAndLibrary
    *
    * @param bad_select_nr_max number of unsuccessful card selections
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrSetBadSelectCardNrMax(uint8_t bad_select_nr_max);

    /**
    * @brief The function returns value of maximal unsuccessful card selections, which is set in reader.
    *
    * @ingroup ReaderAndLibrary
    *
    * @param bad_select_nr_max pointer to number of unsuccessful card selections
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrGetBadSelectCardNrMax(VAR uint8_t *bad_select_nr_max);

    /**
    * @brief Turn the device into Sleep mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrEnterSleepMode(void);

    /**
    * @brief Wake up device from Sleep mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrLeaveSleepMode(void);

    /**
    * @brief Turn the device into Sleep mode after a certain amount of time.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep
    *
    * @param seconds_wait variable holding value of seconds to wait before entering into sleep. If the parameter is 0x00, the AutoSleep feature is turned off (default state).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AutoSleepSet(uint8_t seconds_wait);

    /**
    * @brief Get status of AutoSleep mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep
    *
    * @param seconds_wait variable holding value of seconds to wait before entering into sleep. If the parameter is 0x00, the AutoSleep feature is turned off (default state).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AutoSleepGet(VAR uint8_t *seconds_wait);

    /**
    * @brief This function is used for setting communication speed between reader and ISO144443-4 cards. For other card types, a default speed of 106 kbps is in use.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param tx_speed setup value for transmit speed
    * @param rx_speed setup value for receive speed
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetSpeedPermanently(unsigned char tx_speed, unsigned char rx_speed);

    /**
    * @brief Returns baud rate configured with previous function.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param tx_speed pointer to variable, returns configured value for transmit speed
    * @param rx_speed pointer to variable, returns configured value for receive speed
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetSpeedParameters(VAR unsigned char *tx_speed, VAR unsigned char *rx_speed);

    /**
    * @brief Function enables sending data to the display. A string of data contains information about the intensity of color in each cell of the display.
    * 
    * Each cell has three LED (red, green and blue). For each cell of the three bytes is necessary. 
    * The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. 
    * For example, if the display has 16 cells, an array contains 48 bytes. Value of intensity is in range from 0 to 255.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl
    *
    * @param display_data pointer to data array
    * @param data_length number of data into array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetDisplayData(IN uint8_t *display_data, uint8_t data_length);

    /**
    * @brief Function has the same functionality as the function SetDisplayData(). New feature is the RGB port selection. 
    * 
    * Internal port uses RGB diodes on the reader PCB. Card size reader has two diodes. XL reader has four diodes. External port uses LED RING with RGB diodes.
    * Before the function calls, the function GreenLedBlinkingTurnOff must be called, or the reader is already in mode of blocking automatic signalization. Function sets the color of the RGB diodes. This color stays on the RGB until the function GreenLedBlinkingTurnOn is called. Intensity of light is defined by a parameter stored using the function SetRgbIntensity.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization
    *
    * @param display_data pointer to data array
    * @param data_length number of data into array
    * @param port_name EXTERNAL_RGB_PORT INTERNAL_RGB_PORT
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRgbData(IN uint8_t *display_data, uint8_t data_length, uint8_t port_name);

    /**
    * @brief This function plays constant sound of “frequency” Hertz.
    *
    * @ingroup ReaderAndLibrary_Signalization
    *
    * @param frequency frequency in Hz To stop playing sound, send 0 value for “frequency”.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetSpeakerFrequency(uint16_t frequency);

    /**
    * @brief Function sets the intensity of light on the display. 
    * 
    * Value of intensity is in the range 0 to 100.  This value writes into the reader's EEPROM, and it loads when the reader starts up.
    * SetRgbIntensity()(alias from version 5.0.55)
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl
    *
    * @param intensity value of intensity (0 - 100)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetDisplayIntensity(uint8_t intensity);

    /**
    * @brief Function gets the intensity of light on the display.
    * GetRgbIntensity (alias from version 5.0.55)
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl
    *
    * @param intensity value of intensity (0 - 100)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetDisplayIntensity(VAR uint8_t *intensity);

    /**
    * @brief Function sets the intensity of light on the display.
    * 
    * Value of intensity is in the range 0 to 100.  This value writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization
    *
    * @param intensity value of intensity (0 - 100)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRgbIntensity(uint8_t intensity);

    /**
    * @brief Function gets the intensity of light on the display.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization
    *
    * @param intensity value of intensity (0 - 100)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRgbIntensity(VAR uint8_t *intensity);
    // DESFIRE functions **************************************************************

    /**
    * @brief Call SetISO14443_4_Mode() or SetISO14443_4_Mode_GetATS(). ISO 14443-4 tag in a field will be selected and RF field polling will be stopped.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetISO14443_4_Mode(void);

    /**
    * @brief Call SetISO14443_4_Mode() or SetISO14443_4_Mode_GetATS(). ISO 14443-4 tag in a field will be selected and RF field polling will be stopped.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param ats After successful function execution, buffer on which this pointer points to will contain ATS returned from the TAG (historical bytes included). Before calling this function, you have to allocate MAX_ATS_LEN bytes for the ats buffer. MAX_ATS_LEN macro is defined in uFCoder.h (#define MAX_ATS_LEN 25).
    * @param ats_len After successful function execution, variable on which this pointer points to will contain actual ATS length.
    * @param uid After successful call to this function, buffer on which this pointer points to will contain TAG UID. Before calling this function, you have to allocate MAX_UID_LEN bytes for the ats buffer. MAX_UID_LEN macro is defined in uFCoder.h (#define MAX_UID_LEN 10).
    * @param uid_len After successful function execution, variable on which this pointer points to will contain actual UID length.
    * @param sak After successful function execution, variable on which this pointer points to will contain SAK (Select Acknowledge) of the TAG in field.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetISO14443_4_Mode_GetATS(OUT uint8_t ats[MAX_ATS_LEN], VAR uint8_t *ats_len,
                                                OUT uint8_t uid[MAX_UID_LEN], VAR uint8_t *uid_len, VAR uint8_t *sak);

    /**
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetISO14443_4_DLStorage(void);

    /**
    * @brief DEPRECATED
    */
    UFR_STATUS DL_API uFR_i_block_transceive(uint8_t chaining, uint8_t timeout, uint8_t block_length, IN uint8_t *snd_data_array,
                                             VAR size_t *rcv_length, OUT uint8_t *rcv_data_array, VAR uint32_t *ufr_status);

    /**
    * @brief Used to transmit C-APDU and receive R-APDU packets per defined parameters
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param cls APDU CLA (class byte)
    * @param ins APDU command code (instruction byte)
    * @param p1 parameter byte
    * @param p2 parameter byte
    * @param data_out APDU command data field. Use NULL if data_out_len is 0
    * @param data_out_len number of bytes in the APDU command data field (Lc field)
    * @param data_in buffer for receiving APDU response. There should be allocated at least (send_le + 2) bytes before function call.
    * @param max_data_in_len size of the receiving buffer. If the APDU response exceeded size of buffer, then function returns error
    * @param response_len value of the Le fied if send_le is not 0. After successful execution location pointed by the response_len will contain number of bytes in the APDU response.
    * @param send_le if this parameter is 0 then APDU Le field will not be sent. Otherwise Le field will be included in the APDU message. Value response_len pointed to, before function call will be value of the Le field.
    * @param apdu_status APDU error codes SW1 and SW2 in 2 bytes array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_APDU_Transceive(uint8_t cls, uint8_t ins, uint8_t p1, uint8_t p2, IN uint8_t *data_out, uint8_t data_out_len,
                                          OUT uint8_t *data_in, uint32_t max_data_in_len, VAR uint32_t *response_len, uint8_t send_le,
                                          OUT uint8_t *apdu_status);

    /**
    * @brief Sends C–APDU in the c_string (zero terminated) format, containing pairs of the hexadecimal digits. 
    * 
    * Pairs of the hexadecimal digits can be delimited by any of the punctuation characters or white space.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param c_apdu C-APDU hexadecimal c_string
    * @param r_apdu Received R-APDU as a hexadecimal c_string
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUHexStrTransceive(IN const char *c_apdu, OUT char **r_apdu);

    /**
    * @brief
    * Binary alternative function to the APDUHexStrTransceive(). C-APDU and R-APDU are sent and receive in the form of the byte arrays. 
    * 
    * There is obvious need for a c_apdu_len and *r_apdu_len parameters which represents length of the *c_apdu and *r_apdu byte arrays, respectively
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    * 
    * @param c_apdu Array containing the C-APDU
    * @param c_apdu_len length of the c_apdu array
    * @param r_apdu Array containing received R-APDU
    * @param r_apdu_len length of the received r_apdu array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUPlainTransceive(IN const uint8_t *c_apdu, uint32_t c_apdu_len, OUT uint8_t *r_apdu, VAR uint32_t *r_apdu_len);

    /**
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    * @ingroup UNDOCUMENTED
    *
    * @param c_apdu array containing C_APDU
    * @param c_apdu_len length of C_APDU
    * @param r_apdu buffer that will store R_APDU
    * @param r_apdu_len returns length of R_APDU 
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUPlainTransceiveToHeap(IN const uint8_t *c_apdu, uint32_t c_apdu_len, VAR uint8_t **r_apdu, VAR uint32_t *r_apdu_len);

    /**
    * @brief This is “exploded binary” alternative function intended for support APDU commands in ISO 14443-4A tags. 
    * APDUTransceive() receives separated parameters which are an integral part of the C– APDU. There are parameters cls, ins, p0, p1 of the uint8_t type.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param cls cls
    * @param ins ins
    * @param p1 p1
    * @param p2 p2
    * @param data_out data_out
    * @param Nc Nc
    * @param data_in data_in
    * @param Ne Ne
    * @param send_le send_le
    * @param apdu_status apdu_status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUTransceive(uint8_t cls, uint8_t ins, uint8_t p1, uint8_t p2, IN const uint8_t *data_out, uint32_t Nc,
                                     OUT uint8_t *data_in, VAR uint32_t *Ne, uint8_t send_le, OUT uint8_t *apdu_status);

    /**
    * @brief I-block used to convey information for use by the application layer
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param chaining 1 - chaining in use, 0 - no chaining
    * @param timeout timeout for card reply
    * @param block_length inf block length
    * @param snd_data_array pointer to array of data that will be send
    * @param rcv_length length of received data
    * @param rcv_data_array pointer to array of data that will be received
    * @param rcv_chained 1 received packet is chained, 0 received packet is not chained
    * @param ufr_status card operation status
    *
    *
    * @return Operation status
    */
    UFR_STATUS DL_API i_block_trans_rcv_chain(uint8_t chaining, uint8_t timeout, uint8_t block_length, IN uint8_t *snd_data_array,
                                              VAR uint8_t *rcv_length, OUT uint8_t *rcv_data_array, VAR uint8_t *rcv_chained,
                                              VAR uint32_t *ufr_status);

    /**
    * @brief R-block used to convey positive or negative acknowledgements. An R-block never contains an INF field. The acknowledgement relates to the last received block.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param ack 1 ACK, 0 NOT ACK
    * @param timeout timeout for card reply
    * @param rcv_length length of received data
    * @param rcv_data_array pointer to array of data that will be received
    * @param rcv_chained 1 received packet is chained, 0 received packet is not chained
    * @param ufr_status card operation status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API r_block_transceive(uint8_t ack, uint8_t timeout, VAR uint8_t *rcv_length, OUT uint8_t *rcv_data_array,
                                         VAR uint8_t *rcv_chained, VAR uint32_t *ufr_status);

    /**
    * @brief Used to deselect tag and restore RF field polling. This call is mandatory after using SetISO14443_4_Mode() and its variants.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4
    *
    * @param timeout timeout in [ms]
    *
    * @return Operation status
    */
    UFR_STATUS DL_API s_block_deselect(uint8_t timeout);

    /**
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode
    * @ingroup UNDOCUMENTED
    *
    * @param card_activate card_activate
    * @param card_halted card_halted
    * @param tx_crc hardware RF TX crc using (1 - yes, 0 - no)
    * @param rx_crc hardware RF RX crc using (1 - yes, 0 - no)
    * @param crypto1 crypto1
    * @param timeout timeout
    * @param tx_data tx_data
    * @param tx_data_len tx_data_len
    * @param rx_data rx_data
    * @param rx_data_len rx_data_len
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_transceive(uint8_t card_activate, uint8_t card_halted, uint8_t tx_crc, uint8_t rx_crc, uint8_t crypto1,
                                      uint32_t timeout, IN uint8_t *tx_data, uint8_t tx_data_len, OUT uint8_t *rx_data,
                                      VAR uint8_t *rx_data_len);

    /**
    * @brief Function sets the parameters for transceive mode. 
    * 
    * If the hardware CRC option is used, then only command bytes are sent to the card (hardware will add two bytes of CRC to the end of the RF packet). If this option did not use, then command bytes and two bytes of CRC sent to card  (i.e. ISO14443 typeA CRC). Timeout for card response in us sets.
    * Card is selected and waiting for commands.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode
    *
    * @param tx_crc hardware RF TX crc using (1 - yes, 0 - no
    * @param rx_crc hardware RF RX crc using (1 - yes, 0 - no)
    * @param rf_timeout timeout for card response in us
    * @param uart_timeout timeout for UART response in ms
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_transceive_mode_start(uint8_t tx_crc, uint8_t rx_crc, uint32_t rf_timeout, uint32_t uart_timeout);

    /**
    * @brief The function returns the reader to normal mode.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_transceive_mode_stop(void);

    /**
    * @brief Function enables normal working mode of reader, after leaving the transceive working mode with blocking card HALT command in the main loop.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_halt_enable(void);

    /**
    * @brief The function sends data through the serial port to the card.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode
    *
    * @param send_data pointer to data array for sending to card
    * @param send_len number of bytes for sending rcv_data pointer to data array received from card bytes_to_receive expected number of bytes received from card rcv_len number of bytes received from card
    * @param rcv_data pointer to data array received from card
    * @param bytes_to_receive expected number of bytes received from card rcv_len number of bytes received from card
    * @param rcv_len number of bytes received from card
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uart_transceive(IN uint8_t *send_data, uint8_t send_len, OUT uint8_t *rcv_data, uint32_t bytes_to_receive,
                                      VAR uint32_t *rcv_len);

    /**
    * @brief Function activates the smart card and returns an ATR (Answer To Reset) array of bytes from the smart card.
    * 
    * After the successfully executed function, the same APDU commands as for ISO14443-4 tags can be used, but not at the same time.
    * Note. This function is used for NXP SAM AV2 activation, and unlocking if SAM is locked.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816
    *
    * @param atr_data pointer to array containing ATR
    * @param atr_len pointer to ATR length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API open_ISO7816_interface(OUT uint8_t *atr_data, VAR uint8_t *atr_len);

    /**
    * @brief Function activates the smart card and returns an ATR (Answer To Reset) array of bytes from the smart card.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816
    *
    * @param atr_data pointer to array containing ATR
    * @param atr_len pointer to ATR length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API Open_ISO7816_Generic(OUT uint8_t *atr_data, VAR uint8_t *atr_len);

    /**
    * @brief Function switches the use of APDU to ISO7816 interface. The smart card must be in the active state.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDU_switch_to_ISO7816_interface(void);

    /**
    * @brief Function deactivates the smart card. APDU commands are not used.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @return Operation status
    */
    UFR_STATUS DL_API close_ISO7816_interface_no_APDU(void);

    /**
    * @brief Function deactivates the smart card. APDU commands are used by ISO 14443-4 tags. Tag must already be in ISO 14443-4 mode.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816
    *
    * @return Operation status
    */
    UFR_STATUS DL_API close_ISO7816_interface_APDU_ISO14443_4(void);

    /**
    * @brief Function switches the use APDU to ISO14443-4 tags. The smart card stays in active state. Tag must already be in ISO 14443-4 mode.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDU_switch_to_ISO14443_4_interface(void);

    /**
    * @brief APDU commands are not used. The smart card stays in active state.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDU_switch_off_from_ISO7816_interface(void);

    //==============================================================================
    /**
    * @brief Using this function you can select the appropriate application on the card. 
    * 
    * For the DLSigner JCApp AID should be 'F0 44 4C 6F 67 69 63 00 01'. For the DLStorage JCApp AID should be 'F0 44 4C 6F 67 69 63 01 01'. Before calling this function, the NFC tag must be in ISO 14443-4 mode. For entering ISO 14443-4 mode use the SetISO14443_4_Mode() or SetISO14443_4_Mode_GetATS() function.
    *
    * @param aid Pointer to array containing AID (Application ID) i.e: "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01" for the DLSigner or "\xF0\x44\x4C\x6F\x67\x69\x63\x01\x01" for the DLStorage JCApp.
    * @param aid_len Length of the AID in bytes (9 for the DLSigner or DLStorage JCApps).
    * @param selection_response On Application successful selection, the card returns 16 bytes. In the current version only the first of those bytes (i.e. byte with index 0) is relevant and contains JCApp card type which is 0xA0 for actual revision.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSelectByAid(IN const uint8_t *aid, uint8_t aid_len, OUT uint8_t selection_response[16]);

    /**
    * @brief In JCApp cards you can put two types of asymmetric crypto keys. 
    * 
    * Those are RSA and ECDSA private keys, three of each. Before you can use a JCApp card for digital signing you have to put an appropriate private key in it. There is no way to read out private keys from the card.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This feature is disabled in the regular DLSigner JCApp. To acquire cards with this feature enabled you have to contact your supplier with a special request.
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param key_type 0 for RSA private key and 1 for ECDSA private key.
    * @param key_index For each of the card types there are 3 different private keys that you can set. Their indexes are from 0 to 2.
    * @param key Pointer to array containing key bytes.
    * @param key_bit_len Key length in bits.
    * @param key_param Reserved for future use (RFU). Use null for this parameter.
    * @param key_parm_len Reserved for future use (RFU). Use 0 for this parameter.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPutPrivateKey(uint8_t key_type, uint8_t key_index, IN const uint8_t *key, uint16_t key_bit_len,
                                         const IN uint8_t *key_param, uint16_t key_parm_len);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGenerateKeyPair(uint8_t key_type, uint8_t key_index, uint8_t key_designator, uint16_t key_bit_len,
                                           IN const uint8_t *params, uint16_t params_size);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppDeleteRsaKeyPair(uint8_t key_index);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppDeleteEcKeyPair(uint8_t key_index);

    /**
    * @brief Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param cipher 0 for the RSA private key and 1 for the ECDSA.
    * @param digest 0 for none digest (not supported with ECDSA) and 1 for SHA1
    * @param padding 0 for none (not supported with RSA) and 1 for pads the digest according to the PKCS#1 (v1.5) scheme.
    * @param key_index For each of the card types there are 3 different private keys that you can set. Their indexes are from 0 to 2.
    * @param chunk Pointer to array containing first chunk of data.
    * @param chunk_len Length of the first chunk of data (max. 255).
    * @param alg_param Reserved for future use (RFU). Use null for this parameter.
    * @param alg_parm_len Reserved for future use (RFU). Use 0 for this parameter.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSignatureBegin(uint8_t cipher, uint8_t digest, uint8_t padding, uint8_t key_index, IN const uint8_t *chunk,
                                          uint16_t chunk_len, IN const uint8_t *alg_param, uint16_t alg_parm_len);

    /**
    * @brief Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param chunk Pointer to an array containing one of the chunks of data.
    * @param chunk_len Length of the current one of the remaining chunks of data (max. 255).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSignatureUpdate(IN const uint8_t *chunk, uint16_t chunk_len);

    /**
    * @brief Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param sig_len Pointer to a 16-bit value in which you will get length of the signature in case of a successful executed chain of function calls, described in the introduction of this topic.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSignatureEnd(VAR uint16_t *sig_len);

    /**
    * @brief This function virtually combines three successive calls of functions JCAppSignatureBegin(), JCAppSignatureUpdate() and JCAppSignatureEnd() and can be used in case your data for signing have 255 bytes or less.
    * 
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * Prior to calling this function you have to be logged in with a User PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param cipher 0 for the RSA private key and 1 for the ECDSA.
    * @param digest 0 for none digest (not supported with ECDSA) and 1 for SHA1
    * @param padding 0 for none (not supported with RSA) and 1 for pads the digest according to the PKCS#1 (v1.5) scheme.
    * @param key_index For each of the card types there are 3 different private keys that you can set. Their indexes are from 0 to 2.
    * @param plain_data Pointer to array containing data for signing.
    * @param plain_data_len Length of the data for signing (max. 255).
    * @param sig_len Pointer to a 16-bit value in which you will get the length of the signature in case of successful execution.
    * @param alg_param Reserved for future use (RFU). Use null for this parameter.
    * @param alg_parm_len Reserved for future use (RFU). Use 0 for this parameter.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGenerateSignature(uint8_t cipher, uint8_t digest, uint8_t padding, uint8_t key_index, IN const uint8_t *plain_data,
                                             uint16_t plain_data_len, VAR uint16_t *sig_len, IN const uint8_t *alg_param, uint16_t alg_parm_len);

    /**
    * @brief Finally, to get a signature, you have to call JCAppGetSignature().
    * 
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * Prior calling of this function you have to be logged in with an User PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param sig Pointer to an array of “sig_len” bytes length. Value of the “sig_len” you've got as a parameter of the JCAppSignatureEnd() or JCAppGenerateSignature() functions. You have to allocate those bytes before calling this function.
    * @param sig_len Length of the allocated bytes in a sig array.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetSignature(OUT uint8_t *sig, uint16_t sig_len);

    /**
    * @brief Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * 
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param obj Pointer to an array containing an object (certificate).
    * @param obj_size Length of the object (certificate).
    * @param id Pointer to an array containing object id. Object id is a symbolic value and has to be unique on the card.
    * @param id_size Length of the object id. Minimum object id length can be 1 and maximum 253.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPutObj(uint8_t obj_type, uint8_t obj_index, IN uint8_t *obj, int16_t obj_size, IN uint8_t *id, uint8_t id_size);

    /**
    * @brief Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * 
    * Prior to calling of this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param subject Pointer to an array containing subject. Subject is a symbolic value linked to an appropriate certificate by the same obj_type and index.
    * @param size Length of the subject. Maximum subject length is 255.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPutObjSubject(uint8_t obj_type, uint8_t obj_index, IN uint8_t *subject, uint8_t size);

    /**
    * @brief Using this function you can delete certificate objects from a card. 
    * 
    * This includes subjects linked to a certificate.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppInvalidateCert(uint8_t obj_type, uint8_t obj_index);

    /**
    * @brief This function you always have to call 2 times. 
    * 
    * Before the first call you have to set parameter id to null and you will get the id_size of the obj_type at obj_index. Before the second call you have to allocate an array of the returned id_size bytes and pass that array using parameter id. Before second call, *id_size should be set to a value of the exact bytes allocated.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param id When id == NULL, the function returns id_size.
    * @param id_size Before second call, *id_size should be set to a value of the exact bytes allocated.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetObjId(uint8_t obj_type, uint8_t obj_index, OUT uint8_t *id, VAR uint16_t *id_size); // when id == NULL returns size
    /**
    * @brief This function you always have to call 2 times. 
    * 
    * Before the first call you have to set the parameter subject to null and you will get the size of the obj_type at obj_index. Before the second call you have to allocate an array of returned size bytes and pass that array using parameter subject. Before second call, *size should be set to a value of the exact bytes allocated.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param subject When subject == NULL, function returns size.
    * @param size Before second call, *size should be set to a value of the exact bytes allocated.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetObjSubject(uint8_t obj_type, uint8_t obj_index, OUT uint8_t *subject, VAR uint16_t *size); // when subject == NULL returns size
    /**
    * @brief This function you always have to call 2 times. 
    * 
    * Before the first call you have to set parameter id to null and you will get the id_size of the obj_type at obj_index. Before the second call you have to allocate an array of the returned id_size bytes and pass that array using parameter id. Before second call, *id_size should be set to a value of the exact bytes allocated.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    *
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param obj When obj == NULL, function returns size.
    * @param size Before second call, *size should be set to a value of the exact bytes allocated.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetObj(uint8_t obj_type, uint8_t obj_index, OUT uint8_t *obj, int16_t size); // when obj == NULL returns size
    /**
    *
    * @ingroup Card_Tag_JavaCardApplication
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    c_string DL_API JCAppGetErrorDescription(UFR_STATUS apdu_error_status);

    /**
    * @brief This function is used to login to the JCApp with an appropriate PIN code. 
    * 
    * Every time you deselect the JCApp tag either by calling s_block_deselect(), ReaderReset(), ReaderClose() or because of the loss of the NFC field, in order to communicate with the same tag you have to select JCApp and login again, using this function.
    * Every successful login resets the incorrectly entered PIN code counter for the PIN code specified by the SO parameter.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common
    *
    * @param SO If this parameter has value 0 function will try to login as a User. If this parameter has a value different then 0, the function will try to login as a Security Officer (SO).
    * @param pin Pointer to the array of bytes which contains PIN code.
    * @param pinSize Effective size of the array of bytes which contains PIN code. JCAppGetPinTriesRemaining Function description This function is used to get how many of the unsuccessful login attempts remain before specified PIN or PUK code will be blocked. This function have parameter of the type dl_sec_code_t which is defined as: typedef enum { USER_PIN = 0, SO_PIN, USER_PUK, SO_PUK } dl_sec_code_t;
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppLogin(uint8_t SO, IN uint8_t *pin, uint8_t pinSize);

    /**
    * @brief This function is used to get how many of the unsuccessful login attempts remain before specified PIN or PUK code will be blocked.
    * 
    * This function have parameter of the type dl_sec_code_t which is defined as:
    * typedef enum {
    * USER_PIN = 0,
    * SO_PIN,
    * USER_PUK,
    * SO_PUK
    * } dl_sec_code_t;
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common
    *
    * @param secureCodeType Specifies the PIN code type (see the dl_sec_code_t type definition above, in the text)
    * @param triesRemaining Pointer to the 16-bit unsigned integer which will contain the number of the unsuccessful login attempts remains before specified PIN code will be blocked, in case of successful function execution. If this value is 0 then the specified PIN code is blocked.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetPinTriesRemaining(dl_sec_code_t secureCodeType, VAR uint16_t *triesRemaining);

    /**
    * @brief This function is used to change the PIN or PUK code which type is specified with secureCodeType parameter of type dl_sec_code_t.
    * 
    * Which is defined as:
    * typedef enum {
    * USER_PIN = 0,
    * SO_PIN,
    * USER_PUK,
    * SO_PUK
    * } dl_sec_code_t;
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common
    *
    * @param secureCodeType Specifies the PIN or PUK code type you wish to change (see the dl_sec_code_t type definition above, in the text)
    * @param newPin Pointer to the array of bytes which contains a new code.
    * @param newPinSize Effective size of the array of bytes which contains a new code.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinChange(dl_sec_code_t secureCodeType, IN uint8_t *newPin, uint8_t newPinSize);

    /**
    * @brief This function is used to unblock PIN code which is specified by the SO parameter.
    * 
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common
    *
    * @param SO If this parameter has value 0 function will try to unblock User PIN code. If this parameter has a value different then 0, the function will try to unblock SO PIN code.
    * @param puk Pointer to the array of bytes which contains PUK code.
    * @param pukSize Effective size of the array of bytes which contains PUK code.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinUnblock(uint8_t SO, IN uint8_t *puk, uint8_t pukSize);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_Common
    * @ingroup UNDOCUMENTED
    *
    * @param SO SO
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinEnable(uint8_t SO);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_Common
    * @ingroup UNDOCUMENTED
    *
    * @param SO SO
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinDisable(uint8_t SO);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    * @ingroup UNDOCUMENTED
    *
    * @param key_index key_index
    * @param modulus modulus
    * @param modulus_size modulus_size
    * @param exponent exponent
    * @param exponent_size exponent_size
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetRsaPublicKey(uint8_t key_index, OUT uint8_t *modulus, VAR uint16_t *modulus_size, OUT uint8_t *exponent,
                                           VAR uint16_t *exponent_size); // when modulus == NULL, returns sizes and exponent ignored
    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    * @ingroup UNDOCUMENTED
    *
    * @param key_index key_index
    * @param keyW keyW
    * @param keyWSize keyWSize
    * @param field field
    * @param field_size field_size
    * @param ab ab 
    * @param ab_size ab_size
    * @param g g
    * @param g_size g_size
    * @param r r
    * @param r_size r_size
    * @param k k
    * @param key_size_bits key_size_bits
    * @param key_designator key_designator
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetEcPublicKey(
        uint8_t key_index, OUT uint8_t *keyW,
        VAR uint16_t *keyWSize, // when keyW == NULL, returns size
        OUT uint8_t *field, VAR uint16_t *field_size, OUT uint8_t *ab, VAR uint16_t *ab_size, OUT uint8_t *g, VAR uint16_t *g_size,
        OUT uint8_t *r, VAR uint16_t *r_size, VAR uint16_t *k, VAR uint16_t *key_size_bits, VAR uint16_t *key_designator);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature
    * @ingroup UNDOCUMENTED
    *
    * @param key_index key_index
    * @param key_size_bits key_size_bits
    * @param key_designator key_designator
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetEcKeySizeBits(uint8_t key_index, VAR uint16_t *key_size_bits, VAR uint16_t *key_designator);
    //------------------------------------------------------------------------------
    /**
    * @brief This function has to be called before JCStorageListFiles() to acquire the size of the array of bytes needed to be allocated for the list of currently existing files on the DLStorage card.
    * 
    * Maximum files on the DLStorage card is 16.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param list_size ointer to the 32-bit unsigned integer which will contain the size of the array of bytes needed to be allocated prior to calling the JCStorageListFiles() function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageGetFilesListSize(VAR uint32_t *list_size);

    /**
    * @brief After calling the JCStorageGetFilesListSize() function and getting the size of the list of the currently existing files on the DLStorage card, and if the list size is greater than 0, you can allocate a convenient array of bytes and then call this function. 
    * 
    * On successful function execution, the array pointed by the list parameter will contain indexes of the existing files on the card. Maximum files on the DLStorage card is 16. Each byte of the array pointed by the list parameter contains a single index of the existing file on the DLStorage card.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param list Pointer to the allocated array of bytes of the size acquired by the previous call to JCStorageGetFilesListSize() function.
    * @param list_bytes_allocated Size of the array of bytes pointed by the list parameter. Have to be equal to the value of the *list_size acquired by the previous call to JCStorageGetFilesListSize() function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageListFiles(OUT uint8_t *list, uint32_t list_bytes_allocated);

    /**
    * @brief This function returns file size indexed by the parameter card_file_index, on successful execution. 
    * 
    * Returned file size is in bytes. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. You have to know file size to allocate an appropriate amount of data prior to calling the JCStorageReadFile() function.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param card_file_index It should contain an index of the file which size we want to get.
    * @param file_size Pointer to the 32-bit unsigned integer which will contain size in bytes of the file having card_file_index.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageGetFileSize(uint8_t card_file_index, VAR uint32_t *file_size);

    /**
    * @brief
    * After calling the JCStorageGetFileSize() function and getting the size of the file on the DLStorage card you can allocate a convenient array of bytes and then call this function. 
    * 
    * On successful function execution, the array pointed by the data parameter will contain file content. If the file with the index defined by the card_file_index parameter does not exist, the function will return UFR_APDU_SW_FILE_NOT_FOUND (0x000A6A82) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param card_file_index It should contain an index of the file we want to read.
    * @param data Pointer to the allocated array of bytes of the size acquired by the previous call to JCStorageGetFileSize() function.
    * @param data_bytes_allocated  Size of the array of bytes pointed by the data parameter. Have to be equal to the value of the *file_size acquired by the prior calling JCStorageGetFileSize() function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageReadFile(uint8_t card_file_index, OUT uint8_t *data, uint32_t data_bytes_allocated);

    /**
    * @brief This function reads a file from the DLStorage card directly to the new file on the host file-system.
    * 
    * If the file on the host file system already exists, it will be overwritten. If the file with the index defined by the card_file_index parameter does not exist, the function will return UFR_APDU_SW_FILE_NOT_FOUND (0x000A6A82) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param card_file_index It should contain an index of the file we want to read.
    * @param file_system_path_name Pointer to the null-terminated string that should contain path and the name of the new file on the host file-system which will contain the data read from the file on the card in case of successful function execution.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageReadFileToFileSystem(uint8_t card_file_index, IN const char *file_system_path_name);

    /**
    * @brief This function creates a file on the DLStorage card and writes an array of bytes pointed by the data parameter to it. 
    * 
    * Parameter data_size defines the amount of data to be written in the file on the DLStorage card. 
    * If the file with the index defined by the card_file_index parameter already exists on the card, the function will return UFR_APDU_SW_ENTITY_ALREADY_EXISTS (0x000A6A89) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. If there is an error during the writing procedure, for example because of the loss of the NFC field and the file is only partially written (tearing event), a corrupted file on the DLStorage card should be deleted and then written again. Therefore we suggest you to always do verification of the data written to the card.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param card_file_index It should contain an index of the file we want to create and write data to it.
    * @param data Pointer to the data i.e. array of bytes to be written into the new file on the card.
    * @param data_size Size, in bytes, of the data to be written into the file on the card.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageWriteFile(uint8_t card_file_index, IN const uint8_t *data, uint32_t data_size);

    /**
    * @brief This function writes file content from the host file-system to the new file on the DLStorage card. 
    * 
    * If the file with the index defined by the card_file_index parameter already exists on the card, the function will return UFR_APDU_SW_ENTITY_ALREADY_EXISTS (0x000A6A89) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. If there is an error during the writing procedure, for example because of the loss of the NFC field and the file is only partially written (tearing event), a corrupted file on the DLStorage card should be deleted and then written again. Therefore we suggest you to always do verification of the data written to the card.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param card_file_index It should contain an index of the file on the card we want to create and write content of the file from the host file-sistem to it.
    * @param file_system_path_name  Pointer to the null-terminated string that should contain path and the name of the file from the host file-sistem whose content we want to transfer to the new file on the card.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageWriteFileFromFileSystem(uint8_t card_file_index, IN const char *file_system_path_name);

    /**
    * @brief After successful call to this function, the file on the DLStorage card will be deleted.
    * 
    * Maximum files on the card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. If a file with index defined by the file_index parameter does not exist, the function will return UFR_APDU_SW_FILE_NOT_FOUND (0x000A6A82) error code.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage
    *
    * @param file_index It should contain an index of the file we want to delete.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageDeleteFile(uint8_t file_index);
    //------------------------------------------------------------------------------
    /**
    * @brief This function is used to get hash output length in bytes for specified hash algorithms.
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param hash_algo Hash designator for which we want to get output length in bytes. Use values declared in E_HASH_ALGS enumeration.
    * @param out_byte_len After successful function execution, the variable on which this pointer points to, will contain output hash length in bytes for specified hash algorithm.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DLGetHashOutputByteLength(uint32_t hash_algo, VAR uint32_t *out_byte_len);

    /**
    * @brief This function returns pointer to a null terminated string constant which contains the name of the hash algorithm designated by the input function parameter.
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param hash_algo Hash designator. Use values declared in E_HASH_ALGS enumeration
    * @param in Input buffer of which hash is calculated.
    * @param in_len Input buffer length in bytes. Maximum buffer length is 32 KB. If you have more data, use the chunked hashing method (see usage instructions of the DLHashInitChunked(), DLHashUpdateChunked() and DLHashFinishChunked() functions)
    * @param hash After successful function execution, the variable on which this pointer points to, will contain output of the hashing sequence.
    * @param hash_alocated This parameter should contain the number of bytes previously allocated in the hash buffer. This parameter have to be greater or equal to the output length of the hash algorithm which is specified by the hash_algo parameter passed in the previous call to the DLHashInitChunked(), in the beginning of the hashing sequence.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DLGetHash(uint32_t hash_algo, IN const uint8_t *in, uint32_t in_len, OUT uint8_t *hash, uint32_t hash_alocated);

    /**
    * @brief This function calculates and returns the hash of the data in the buffer pointed by the “in” function parameter.
    * 
    * Hash algorithm is specified by the hash_algo function parameter.
    * If output bytes don't match with hash_alocated function parameter function returns CRYPTO_SUBSYS_WRONG_HASH_OUTPUT_LENGTH status.
    * GetHashToHeap() automatically allocates memory, which *hash parameter will point to after successful execution. User is obligated to cleanup allocated memory space, occupied by the *hash, after use (e.g. by calling DLFree() or directly free() from the C/C++ code).
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param hash_algo Hash designator which specifies the hash algorithm used for calculation. Use values declared in E_HASH_ALGS enumeration.
    * @param in Input buffer of which hash is calculated.
    * @param in_len Input buffer length in bytes. Maximum buffer length is 32 KB. If you have more data, use the chunked hashing method (see usage instructions of the DLHashInitChunked(), DLHashUpdateChunked() and DLHashFinishChunked() functions).
    * @param hash After successful function execution, the variable on which this pointer points to, will contain the pointer to the output hash.
    * @param hash_len After successful function execution, the variable on which this pointer points to, will contain output hash length.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DLGetHashToHeap(uint32_t hash_algo, IN const uint8_t *in, uint32_t in_len, VAR uint8_t **hash, VAR uint32_t *hash_len);

    /**
    * @brief This function is used in conjunction with DLHashUpdateChunked() and DLHashFinishChunked() or DLHashFinishChunkedToHeap() functions.
    * 
    * These functions have the same result as the single call to DLGetHash() or DLGetHashToHeap() functions but they are used for larger amounts of data to hash.
    * These functions have to be called in the specific sequence. Disruption of the calling sequence leads to unpredictable results. In every hashing sequence, DLHashInitChunked() has to be called exactly once, in the beginning of the sequence. After successful hashing sequence initialization, there can be as many as needed DLHashUpdateChunked() calls. Chunk sizes may vary throughout the sequence. At the end of the sequence there can be exactly one call to either DLHashFinishChunked() or DLHashFinishChunkedToHeap() function. These two functions differ only in that the DLHashFinishChunkedToHeap() automatically allocates space for a resulting hash while the DLHashFinishChunked() expects to store the result in an already allocated memory on the heap. Calling one of DLHashFinishChunked() or DLHashFinishChunkedToHeap() functions finishes the current hashing sequence.
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param hash_algo Hash designator which specifies the hash algorithm used in the following hashing sequence. Use values declared in E_HASH_ALGS enumeration.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DLHashInitChunked(uint32_t hash_algo);

    /**
    * @brief This function is used in conjunction with DLHashInitChunked() and DLHashFinishChunked() or DLHashFinishChunkedToHeap() functions.
    * 
    * These functions have the same result as the single call to DLGetHash() or DLGetHashToHeap() functions but they are used for larger amounts of data to hash.
    * These functions have to be called in the specific sequence. Disruption of the calling sequence leads to unpredictable results. In every hashing sequence, DLHashInitChunked() have to be called exactly once, in the beginning of the sequence. After successful hashing sequence initialization, there can be as many as needed DLHashUpdateChunked() calls. Chunk sizes may vary throughout the sequence. At the end of the sequence there can be exactly one call to either DLHashFinishChunked() or DLHashFinishChunkedToHeap() function. These two functions differ only in that the DLHashFinishChunkedToHeap() automatically allocates space for a resulting hash while the DLHashFinishChunked() expects to store the result in an already allocated memory on the heap. Calling one of DLHashFinishChunked() or DLHashFinishChunkedToHeap() functions finishes current hashing sequence.
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param in One of the chunks of data of which hash is calculated.
    * @param in_len Chunk length in bytes.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DLHashUpdateChunked(IN const uint8_t *in, uint32_t in_len);

    /**
    * @brief This function is used in conjunction with DLHashInitChunked() and DLHashUpdateChunked() functions.
    * 
    * These functions have the same result as the single call to DLGetHash() or DLGetHashToHeap() functions but they are used for larger amounts of data to hash.
    * These functions have to be called in the specific sequence. Disruption of the calling sequence leads to unpredictable results. In every hashing sequence, DLHashInitChunked() have to be called exactly once, in the beginning of the sequence. After successful hashing sequence initialization, there can be as many as needed DLHashUpdateChunked() calls. Chunk sizes may vary throughout the sequence. At the end of the sequence there can be exactly one call to either DLHashFinishChunked() or DLHashFinishChunkedToHeap() function. These two functions differ only in that the DLHashFinishChunkedToHeap() automatically allocates space for a resulting hash while the DLHashFinishChunked() expects to store the result in an already allocated memory on the heap. Calling one of DLHashFinishChunked() or DLHashFinishChunkedToHeap() functions finishes the current hashing sequence.
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param hash After successful function execution, the variable on which this pointer points to, will contain output of the hashing sequence.
    * @param hash_alocated This parameter should contain the number of bytes previously allocated in the hash buffer. This parameter have to be greater or equal to the output length of the hash algorithm which is specified by the hash_algo parameter passed in the previous call to the DLHashInitChunked(), in the beginning of the hashing sequence.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DLHashFinishChunked(OUT uint8_t *hash, uint32_t hash_alocated);
    /**
    * @brief This function is used in conjunction with DLHashInitChunked() and DLHashUpdateChunked() functions.
    * 
    * These functions have the same result as the single call to DLGetHash() or DLGetHashToHeap() functions but they are used for larger amounts of data to hash.
    * These functions have to be called in the specific sequence. Disruption of the calling sequence leads to unpredictable results. In every hashing sequence, DLHashInitChunked() have to be called exactly once, in the beginning of the sequence. After successful hashing sequence initialization, there can be as many as needed DLHashUpdateChunked() calls. Chunk sizes may vary throughout the sequence. At the end of the sequence there can be exactly one call to either DLHashFinishChunked() or DLHashFinishChunkedToHeap() function. These two functions differ only in that the DLHashFinishChunkedToHeap() automatically allocates space for a resulting hash while the DLHashFinishChunked() expects to store the result in an already allocated memory on the heap. Calling one of DLHashFinishChunked() or DLHashFinishChunkedToHeap() functions finishes the current hashing sequence.
    * DLHashFinishChunkedToHeap() automatically allocates memory, which *hash parameter will point to, after successful execution. User is obligated to cleanup allocated memory space, occupied by the *hash, after use (e.g. by calling DLFree(cert) or directly free(cert) from the C/C++ code).
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param hash After successful function execution, the variable on which this pointer points to, will contain output of the hashing sequence.
    * @param hash_alocated This parameter should contain the number of bytes previously allocated in the hash buffer. This parameter have to be greater or equal to the output length of the hash algorithm which is specified by the hash_algo parameter passed in the previous call to the DLHashInitChunked(), in the beginning of the hashing sequence.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DLHashFinishChunkedToHeap(OUT uint8_t **hash, VAR uint32_t *hash_alocated);

    /**
    * @brief This function is used to verify the digital signature of the pre-hashed value or some relatively short plain text message. 
    * 
    * If there is no errors during the verification process and digital signature correspond to the "To Be Signed" (TBS) data array and public cryptographic key, the function returns UFR_OK status. "To Be Signed" is just a colloquial term for already signed data, which is the origin of the digital signature.
    * In case of wrong digital signature, function returns CRYPTO_SUBSYS_WRONG_SIGNATURE status.
    * Function can return following status codes in case of various errors:
    * * CRYPTO_SUBSYS_NOT_INITIALIZED
    * * CRYPTO_SUBSYS_INVALID_HASH_ALGORITHM
    * * CRYPTO_SUBSYS_INVALID_PADDING_ALGORITHM
    * * CRYPTO_SUBSYS_INVALID_CIPHER_ALGORITHM
    * * CRYPTO_SUBSYS_INVALID_SIGNATURE_PARAMS
    * * CRYPTO_SUBSYS_INVALID_RSA_PUB_KEY
    * * CRYPTO_SUBSYS_INVALID_ECC_PUB_KEY
    * * CRYPTO_SUBSYS_INVALID_ECC_PUB_KEY_PARAMS
    * * CRYPTO_SUBSYS_UNKNOWN_ECC_CURVE
    * * CRYPTO_SUBSYS_SIGNATURE_VERIFICATION_ERROR
    * For digest_alg use one of the values declared in E_SIGNER_DIGESTS enumeration:
    * enum E_SIGNER_DIGESTS {
    * ALG_NULL = 0,
    * ALG_SHA,
    * ALG_SHA_256,
    * ALG_SHA_384,
    * ALG_SHA_512,
    * ALG_SHA_224,
    * ALG_SHA_512_224,
    * ALG_SHA_512_256,
    * SIG_DIGEST_MAX_SUPPORTED
    * };
    * ALG_SHA is the designator for the SHA-1 algorithm.
    * For padding_alg use one of the values declared in E_SIGNER_RSA_PADDINGS enumeration:
    * enum E_SIGNER_RSA_PADDINGS {
    * PAD_NULL = 0,
    * PAD_PKCS1_V1_5,
    * PAD_PKCS1_PSS,
    * SIG_PAD_MAX_SUPPORTED
    * };
    * PAD_PKCS1 is an alias of the PAD_PKCS1_V1_5 padding algorithm:
    * #define PAD_PKCS1   PAD_PKCS1_V1_5
    * For cipher_alg use one of the values declared in E_SIGNER_CIPHERS enumeration:
    * enum E_SIGNER_CIPHERS {
    * SIG_CIPHER_RSA = 0,
    * SIG_CIPHER_ECDSA,
    * SIG_CIPHER_MAX_SUPPORTED
    * };
    * When the signer cipher algorithm is SIG_CIPHER_ECDSA, padding_alg is ignored and you can freely use PAD_NULL i.e. value 0 as a padding_alg. ECDSA data alignment in use is described in RFC6979 (section 2.3. - Integer Conversions).
    *
    * @ingroup Card_Tag_CardFeatures_DigitalSignatureVerification
    *
    * @param digest_alg in the E_SIGNER_DIGESTS enumeration.
    * @param padding_alg in the E_SIGNER_RSA_PADDINGS enumeration. When the signer cipher algorithm is SIG_CIPHER_ECDSA, padding_alg is ignored and you can freely use PAD_NULL i.e. value 0 as a padding_alg. ECDSA data alignment in use is described in RFC6979 (section 2.3. - Integer Conversions).
    * @param cypher_alg in the E_SIGNER_CIPHERS enumeration. tbs Pointer to the “To Be Signed“ data array i.e. hash or relatively short plain text message whose digital signature is being verified. "To Be Signed" is just a colloquial term for already signed data, which is the origin of the digital signature. tbs_len Length of the “To Be Signed“ array (in bytes). signature Pointer to the signature array. signature_len Length of the signature array (in bytes). sig_params Pointer to the additional signature parameters. Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this pointer should point to the unsigned 4-byte integer containing the value of the cryptographic salt length. sig_params_len Length of the additional signature parameters (in bytes). Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this value should be 4 i.e. size of unsigned 4-byte integer. In other cases this parameter is ignored. pub_key Pointer to the public key array. In the case of the RSA public key, this array should contain key modulus (‘N’). pub_key_len Length of the public key parameter pub_key (in bytes). pub_key_params Pointer to the additional public key parameters. In the case of the RSA public key, this array should contain a public key exponent array (‘e’). In the case of the ECC public key, this array should contain an elliptic curve definition array. To set an elliptic curve definition array you can use SetEllipticCurveByIndex() or SetEllipticCurveByName() functions. pub_key_params_len Length of the additional public key parameters (in bytes).
    * @param tbs Pointer to the “To Be Signed“ data array i.e. hash or relatively short plain text message whose digital signature is being verified. "To Be Signed" is just a colloquial term for already signed data, which is the origin of the digital signature.
    * @param tbs_len Length of the “To Be Signed“ array (in bytes). signature Pointer to the signature array. signature_len Length of the signature array (in bytes). sig_params Pointer to the additional signature parameters. Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this pointer should point to the unsigned 4-byte integer containing the value of the cryptographic salt length. sig_params_len Length of the additional signature parameters (in bytes). Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this value should be 4 i.e. size of unsigned 4-byte integer. In other cases this parameter is ignored. pub_key Pointer to the public key array. In the case of the RSA public key, this array should contain key modulus (‘N’). pub_key_len Length of the public key parameter pub_key (in bytes). pub_key_params Pointer to the additional public key parameters. In the case of the RSA public key, this array should contain a public key exponent array (‘e’). In the case of the ECC public key, this array should contain an elliptic curve definition array. To set an elliptic curve definition array you can use SetEllipticCurveByIndex() or SetEllipticCurveByName() functions. pub_key_params_len Length of the additional public key parameters (in bytes).
    * @param signature Pointer to the signature array.
    * @param signature_len Length of the signature array (in bytes). sig_params Pointer to the additional signature parameters. Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this pointer should point to the unsigned 4-byte integer containing the value of the cryptographic salt length. sig_params_len Length of the additional signature parameters (in bytes). Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this value should be 4 i.e. size of unsigned 4-byte integer. In other cases this parameter is ignored. pub_key Pointer to the public key array. In the case of the RSA public key, this array should contain key modulus (‘N’). pub_key_len Length of the public key parameter pub_key (in bytes). pub_key_params Pointer to the additional public key parameters. In the case of the RSA public key, this array should contain a public key exponent array (‘e’). In the case of the ECC public key, this array should contain an elliptic curve definition array. To set an elliptic curve definition array you can use SetEllipticCurveByIndex() or SetEllipticCurveByName() functions. pub_key_params_len Length of the additional public key parameters (in bytes).
    * @param sig_params Pointer to the additional signature parameters. Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this pointer should point to the unsigned 4-byte integer containing the value of the cryptographic salt length.
    * @param sig_params_len Length of the additional signature parameters (in bytes). Additional signature parameters are in use only when padding_alg is PAD_PKCS1_PSS and in that case this value should be 4 i.e. size of unsigned 4-byte integer. In other cases this parameter is ignored. pub_key Pointer to the public key array. In the case of the RSA public key, this array should contain key modulus (‘N’). pub_key_len Length of the public key parameter pub_key (in bytes). pub_key_params Pointer to the additional public key parameters. In the case of the RSA public key, this array should contain a public key exponent array (‘e’). In the case of the ECC public key, this array should contain an elliptic curve definition array. To set an elliptic curve definition array you can use SetEllipticCurveByIndex() or SetEllipticCurveByName() functions. pub_key_params_len Length of the additional public key parameters (in bytes).
    * @param pub_key Pointer to the public key array. In the case of the RSA public key, this array should contain key modulus (‘N’).
    * @param pub_key_len Length of the public key parameter pub_key (in bytes). pub_key_params Pointer to the additional public key parameters. In the case of the RSA public key, this array should contain a public key exponent array (‘e’). In the case of the ECC public key, this array should contain an elliptic curve definition array. To set an elliptic curve definition array you can use SetEllipticCurveByIndex() or SetEllipticCurveByName() functions. pub_key_params_len Length of the additional public key parameters (in bytes).
    * @param pub_key_params Pointer to the additional public key parameters. In the case of the RSA public key, this array should contain a public key exponent array (‘e’). In the case of the ECC public key, this array should contain an elliptic curve definition array. To set an elliptic curve definition array you can use SetEllipticCurveByIndex() or SetEllipticCurveByName() functions.
    * @param pub_key_params_len Length of the additional public key parameters (in bytes).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DigitalSignatureVerifyHash(uint32_t digest_alg, uint32_t padding_alg, uint32_t cypher_alg, IN const uint8_t *tbs,
                                                 uint32_t tbs_len, IN const uint8_t *signature, uint32_t signature_len,
                                                 IN const void *sig_params, uint32_t sig_params_len, IN const uint8_t *pub_key,
                                                 uint32_t pub_key_len, IN const void *pub_key_params, uint32_t pub_key_params_len);

    /**
    * @brief This function returns pointer to a null terminated string constant which contains the name of the hash algorithm designated by the input function parameter.
    *
    * @ingroup Card_Tag_CardFeatures_GeneralPurposeCrypto
    *
    * @param hash_algo Hash designator. Use values declared in E_HASH_ALGS enumeration.
    *
    * @return Operation status
    */
    c_string DL_API DLGetHashName(uint32_t hash_algo);

    /**
    * @brief This function returns pointer to a null terminated string constant which contains the name of the ECC curve designated by the input function parameter.
    *
    * @ingroup Card_Tag_CardFeatures_GeneralPurposeCrypto
    *
    * @param eccCurve ECC curve designator. Use values declared in E_ECC_CURVES enumeration.
    *
    * @return Operation status
    */
    c_string DL_API DLGetEccCurveName(uint32_t eccCurve);

    /**
    * @brief This function returns pointer to a null terminated string constant which contains the name of the signature scheme (signature algorithm) designated by the input function parameter.
    *
    * @ingroup Card_Tag_CardFeatures_GeneralPurposeCrypto
    *
    * @param signatureScheme Signature scheme (signature algorithm) designator. Use values declared in E_SIGNATURE_SCHEMES enumeration.
    *
    * @return Operation status
    */
    c_string DL_API DLGetSignatureSchemeName(uint32_t signatureScheme);

    /**
    * @brief Release the memory allocated from some of the library functions previously called making it available again for further allocations. 
    * 
    * Use to deallocate i.e. cleanup memory on the heap allocated. This function is a so-called helper for programming languages other than C/C++ where you can use a free(ptr) instead. Use only after calling the library functions for which it is explicitly indicated in this manual. Function returns nothing. After successful function execution ptr will point to NULL.
    *
    * @ingroup Card_Tag_CardFeatures_CryptoHashAlgorithms
    *
    * @param ptr Pointer to the memory allocated on the heap which you want to release. If ptr does not point to a block of memory allocated with the library functions, it causes undefined behavior. If ptr is NULL, the function does nothing. Digital signature verification Enumerations, types and structures for use with DigitalSignatureVerifyHash function enum E_ECC_CURVE_DEFINITION_TYPES { ECC_CURVE_INDEX, ECC_CURVE_NAME, ECC_CURVE_DOMAIN_PARAMETERS, ECC_CURVE_DEFINITION_TYPES_NUM };
    *
    */
    void DL_API DLFree(void *ptr);
    //------------------------------------------------------------------------------
    /**
    * @brief Use this function to authenticate to the eMRTD NFC tag using BAC. This function establishes a security channel for communication. Security channel is maintained using send_sequence_cnt parameter and channel session keys are ksenc (for encryption) and ksmac (for calculating MAC).
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param mrz_proto_key MRZ proto-key acquired using prior call to MRTD_MRZDataToMRZProtoKey() or MRTD_MRZSubjacentToMRZProtoKey() function.
    * @param ksenc This array must have allocated at least 16 bytes prior to calling this function. This array will contain a session encryption key after successful function execution.
    * @param ksmac This array must have allocated at least 16 bytes prior to calling this function. This array will contain a session key for calculating MAC after successful function execution.
    * @param send_sequence_cnt After successful execution of this function, the pointer to this 64-bit value should be saved and forwarded at every subsequent call to MRTDFileReadBacToHeap() and/or other functions for reading eMRTD.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDAppSelectAndAuthenticateBac(IN const uint8_t mrz_proto_key[25], OUT uint8_t ksenc[16], OUT uint8_t ksmac[16],
                                                      VAR uint64_t *send_sequence_cnt);

    /**
    * @brief Use this function to read files from the eMRTD NFC tag. 
    * 
    * You can call this function only after successfully established security channel by the previously called
    * MRTDAppSelectAndAuthenticateBac() function. Session keys ksenc and ksmac, and also parameter send_sequence_cnt are acquired by the previously called
    * MRTDAppSelectAndAuthenticateBac() function. After the successful call to this function, *output points to the file data read from an eMRTD file specified by the file_index parameter. Buffer, in which the data is stored, is automatically allocated on the memory heap during function execution. Maximum amount of data allocated can be 32KB. User is obligated to cleanup allocated data space, occupied by the *output, after use (e.g. by calling DLFree() or directly free() from the C/C++ code).
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param file_index Parameter that specifies the file we want to read from the eMRTD. This is a pointer to byte array containing exactly two bytes designating eMRTD file. Those two bytes are file identificator (FID) and there is a list of FIDs: EF.COM = {0x01, 0x1E} EF.DG1 = {0x01, 0x01} EF.DG2 = {0x01, 0x02} EF.DG3 = {0x01, 0x03} EF.DG4 = {0x01, 0x04} EF.DG5 = {0x01, 0x05} EF.DG6 = {0x01, 0x06} EF.DG7 = {0x01, 0x07} EF.DG8 = {0x01, 0x08} EF.DG9 = {0x01, 0x09} EF.DG10 = {0x01, 0x0A} EF.DG11 = {0x01, 0x0B} EF.DG12 = {0x01, 0x0C} EF.DG13 = {0x01, 0x0D} EF.DG14 = {0x01, 0x0E} EF.DG15 = {0x01, 0x0F} EF.DG16 = {0x01, 0x10} EF.SOD = {0x01, 0x1D}
    * @param output After the successful call to this function, this pointer will point to the pointer on the file data read from an eMRTD file specified by the file_index parameter. Buffer, in which the data is stored, is automatically allocated during function execution. Maximum amount of data allocated can be 32KB. There is a programmer responsibility to cleanup allocated data (e.g. by calling DLFree(cert) or directly free(cert) from the C/C++ code).
    * @param output_length After the successful call to this function, this pointer is pointed to the size of the file data read from an eMRTD file specified by the file_index parameter.
    * @param ksenc Session encryption key acquired using prior call to MRTDAppSelectAndAuthenticateBac() function.
    * @param ksmac Session key for calculating MAC acquired using prior call to MRTDAppSelectAndAuthenticateBac() function.
    * @param send_sequence_cnt This pointer should point to a 64-bit value initialized by the previously successful call to MRTDAppSelectAndAuthenticateBac() function. Pointer to this 64-bit value should be saved and forwarded at every subsequent call to this function and/or other functions used for reading eMRTD.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDFileReadBacToHeap(IN const uint8_t file_index[2], VAR uint8_t **output, OUT uint32_t *output_length,
                                            IN const uint8_t ksenc[16], IN const uint8_t ksmac[16], VAR uint64_t *send_sequence_cnt);

    /**
    * @brief This function validates data groups read from the eMRTDocument. 
    * 
    * All the elements needed for a validation are recorded into the eMRTD and additional CSCA certificate (Country Signing Certificate Authority). During function execution, hash values of the data groups are validated. Data groups hash values have to be the same as those values embedded in the SOD file which is signed by the private key corresponding to the DS certificate. The DS certificate has to be included in the SOD file too. SOD content is a special case of the PKCS#7 ASN.1 DER encoded structure. Finally, DS certificate signature is validated by the external CSCA certificate which is proof of the valid certificates chain of thrust.
    * The countries provided their CSCA certificates on the specialized Internet sites. CSCA certificates can be in PEM (base64 encoded) or binary files (there having extensions such as PEM, DER, CER, CRT…). Some countries have Master List files that include certificates from other countries with which they have bilateral agreements. Those Master List files have an “.ml” file extension. Additionally, the ICAO Public Key Directory (PKD) is a central repository for exchanging the information required to authenticate ePassports. For more details you can visit the ICAO PKD web site.
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param cert_storage_folder Pointer to the zero terminated string which should contains path to the folder containing CSCA certificates and/or ICAO Master List files.
    * @param out_str After successful function execution, this pointer will point to the pointer on the zero terminated string containing verbose printout of the validation steps. Various printout details are determined by the value of the verbose_level function parameter.
    * @param endln Pointer to the zero terminated string which contains the new line escape sequence for the target system. In the general case it should be "\n" but on some systems can be "\r" or "\r\n".
    * @param verbose_level One of the values defined in the E_PRINT_VERBOSE_LEVELS enumeration: enum E_PRINT_VERBOSE_LEVELS { PRINT_NONE, PRINT_ESSENTIALS, PRINT_DETAILS, PRINT_ALL_PLUS_STATUSES, };
    * @param ksenc Session encryption key acquired using prior call to MRTDAppSelectAndAuthenticateBac() function.
    * @param ksmac Session key for calculating MAC acquired using prior call to MRTDAppSelectAndAuthenticateBac() function.\
    * @param send_sequence_cnt This pointer should point to a 64-bit value initialized by the previously successful call to MRTDAppSelectAndAuthenticateBac() function. Pointer to this 64-bit value should be saved and forwarded at every subsequent call to this function and/or other functions used for reading eMRTD.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDValidate(IN const char *cert_storage_folder, VAR char **out_str, IN const char *endln, uint32_t verbose_level,
                                   OUT uint8_t ksenc[16], OUT uint8_t ksmac[16], VAR uint64_t *send_sequence_cnt);

    /**
    * @brief In order to get the MRZ Proto Key needed in subsequent steps, you can  call this function and pass it null terminated strings containing document number, document holder date of birth and document expiration date.
    * 
    * After successful function execution MRZ Proto Key will be stored in a mrz_proto_key 25-byte array.
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param doc_number Pointer to a null terminated string containing exactly 9 characters document number.
    * @param date_of_birth Pointer to a null terminated string containing exactly 6 characters representing the date of birth in the “YYMMDD” format.
    * @param date_of_expiry Pointer to a null terminated string containing exactly 6 characters representing expiration date in the “YYMMDD” format.
    * @param mrz_proto_key This byte array will contain a calculated MRZ proto-key after successful function execution. This array must have allocated at least 25 bytes prior to calling this function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTD_MRZDataToMRZProtoKey(IN const char *doc_number, IN const char *date_of_birth, IN const char *date_of_expiry,
                                                OUT uint8_t mrz_proto_key[25]);

    /**
    * @brief In order to get the MRZ Proto Key needed in subsequent steps, in the case of the TD3 MRZ format (88 totally character long), you can call this function and pass it a null terminated string containing the MRZ subjacent row. 
    * 
    * Example of the TD3 MRZ format printed on the eMRTD document looks like this:
    * P<UTOERIKSSON<<ANNA<MARIA<<<<<<<<<<<<<<<<<<<
    * L898902C36UTO7408122F1204159ZE184226B<<<<<10
    * This function should receive a pointer to a null terminated string containing MRZ subjacent row
    * i.e. “L898902C36UTO7408122F1204159ZE184226B<<<<<10”.
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param mrz Pointer to a null terminated string containing MRZ data. According to ICAO Doc 9303-10, there it has three MRZ data formats: TD1,TD2 or TD3 formats. TD1 contains exactly 90 characters, TD2 contains exactly 72 characters and TD3 contains exactly 88 characters
    * @param mrz_proto_key This byte array will contain a calculated MRZ proto-key after successful function execution. This array must have allocated at least 25 bytes prior to calling this function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTD_MRZSubjacentToMRZProtoKey(IN const char mrz[44], OUT uint8_t mrz_proto_key[25]);

    /**
    * @brief This function checks the subjacent row of a MRZ data integrity. 
    * 
    * Integrity check uses a special check digits calculation. The check digits permit readers to verify that data in the MRZ is correctly interpreted. If all of the check digits and composite check digit passed the verification process, this function returns UFR_OK status. Otherwise the function returns
    * MRTD_MRZ_CHECK_ERROR status.
    *
    *
    * @param mrz Pointer to a null terminated string containing MRZ data. According to ICAO Doc 9303-10, there it has three MRZ data formats: TD1,TD2 or TD3 formats. TD1 contains exactly 90 characters, TD2 contains exactly 72 characters and TD3 contains exactly 88 characters.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTD_MRZSubjacentCheck(const char mrz[44]);

    /**
    * @brief Use this function to get verbose “printout” string containing MRZ (Machine Readable Zone) parsed data from the content of the EF.DG1 MRTD file. 
    * 
    * Function supports TD1, TD2 and TD3 Data Group 1 formats as defined in the ICAO Doc 9303-10 (seventh edition, 2015).
    * Function automatically allocates memory on the heap, which *sbuffer parameter will point to after successful execution. User is obligated to cleanup allocated memory space, occupied by the *sbuffer, after use (e.g. by calling DLFree(sbuffer) or directly free(sbuffer) from the C/C++ code).
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param sbuffer After successful function execution, this pointer will point to the pointer on the zero terminated string containing verbose printout of the parsed EF.DG1 data
    * @param newln Pointer to the zero terminated string which contains the new line escape sequence for the target system. In the general case it should be "\n" but on some systems can be "\r" or "\r\n".
    * @param dg1 Pointer to the buffer containing EF.DG1 content.
    * @param dg1_len Length of the EF.DG1 content.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDParseDG1ToHeap(VAR char **sbuffer, IN const char *newln, IN const uint8_t *dg1, uint8_t dg1_len);

    /**
    * @brief Use this function to extract the facial image from the EF.DG2 content. 
    * 
    * This function receives EF.DG2 content through *dg2 parameter, parse it and searches for facial image data. Pointer *image points to facial image data within *dg2 memory buffer, after successful function execution.
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param dg2 Pointer to the buffer containing EF.DG2 content.
    * @param dg2_size Length of the EF.DG2 content.
    * @param image After successful function execution, this pointer will point to the pointer on the image data which is physically located in the dg2 buffer.
    * @param image_size After successful function execution, the variable on which this pointer points to, will contain image data length.
    * @param img_type After successful function execution, the variable on which this pointer points to, will contain image type. Image type can be one of the values defined in the E_MRTD_IMG_TYPE enumeration: enum E_MRTD_IMG_TYPE { MRTD_IMG_JPEG = 0, MRTD_IMG_JP2 = 1, MRTD_IMG_JPEG2000 = 1, // Alias for the MRTD_IMG_JP2
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDGetImageFromDG2(IN const uint8_t *dg2, uint32_t dg2_size, VAR uint8_t **image, VAR uint32_t *image_size,
                                          VAR uint32_t *img_type);

    /**
    * @brief Use this function to extract facial image from the EF.DG2 content and save it to file on the file system. 
    * 
    * This function receives EF.DG2 content through *dg2 parameter, parse it and searches for facial image data. After successful function execution, file with path and name specified with an file_name_without_extension parameter is saved. File extension is determined automatically according to the image type.
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param dg2 Pointer to the buffer containing EF.DG2 content.
    * @param dg2_size Length of the EF.DG2 content.
    * @param file_name_without_extension Pointer to the zero terminated string containing file path and name without an extension which is automatically determined according to the image type.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDGetImageFromDG2ToFile(IN const uint8_t *dg2, uint32_t dg2_size, IN const char *file_name_without_extension);

    /**
    * @brief Use this function to get an index of the data groups from EF.DG1 to DG16 i.e. 1 to 16. For EF.COM, EF.SOD and invalid tag function returns 0.
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param dg_tag Data Group tag: * tag of the EF.COM is 0x60 * tag of the EF.DG1 is 0x61 * tag of the EF.DG2 is 0x75 * tag of the EF.DG3 is 0x63 * tag of the EF.DG4 is 0x76 * tag of the EF.DG5 is 0x65 * tag of the EF.DG6 is 0x66 * tag of the EF.DG7 is 0x67 * tag of the EF.DG8 is 0x68 * tag of the EF.DG9 is 0x69 * tag of the EF.DG10 is 0x6a * tag of the EF.DG11 is 0x6b * tag of the EF.DG12 is 0x6c * tag of the EF.DG13 is 0x6d * tag of the EF.DG14 is 0x6e * tag of the EF.DG15 is 0x6f * tag of the EF.DG16 is 0x70 * tag of the EF.SOD is 0x77
    *
    * @return Operation status
    */
    uint32_t DL_API MRTDGetDgIndex(uint8_t dg_tag);

    /**
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param com Pointer to the buffer containing EF.COM content.
    * @param com_len Length of the EF.COM content.
    * @param dg_list After the successful call to this function, this pointer will point to the pointer on the dg_list.
    * @param dg_list_cnt  After successful function execution, this pointer will point to the variable containing the size of the dg_list in bytes i.e. data groups count.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDGetDGTagListFromCOM(IN const uint8_t *com, uint32_t com_len, VAR uint8_t **dg_list, VAR uint8_t *dg_list_cnt);

    /**
    * @brief Use this function to get a name of the data group. Function returns pointer to the zero terminated string ("EF.COM", “EF.DG1”, “EF.DG2”, … , “EF.SOD”). For invalid tag function returns zero terminated string “NOT DEFINED”.
    *
    * @ingroup Card_Tag_CardFeatures_MRTD
    *
    * @param dg_tag Data Group tag: * tag of the EF.COM is 0x60 * tag of the EF.DG1 is 0x61 * tag of the EF.DG2 is 0x75 * tag of the EF.DG3 is 0x63 * tag of the EF.DG4 is 0x76 * tag of the EF.DG5 is 0x65 * tag of the EF.DG6 is 0x66 * tag of the EF.DG7 is 0x67 * tag of the EF.DG8 is 0x68 * tag of the EF.DG9 is 0x69 * tag of the EF.DG10 is 0x6a * tag of the EF.DG11 is 0x6b * tag of the EF.DG12 is 0x6c * tag of the EF.DG13 is 0x6d * tag of the EF.DG14 is 0x6e * tag of the EF.DG15 is 0x6f * tag of the EF.DG16 is 0x70 * tag of the EF.SOD is 0x77
    *
    * @return Operation status
    */
    c_string DL_API MRTDGetDgName(uint8_t dg_tag);
    //==============================================================================

    /**
    * @brief Although we do not recommend the use of software digital signing during TLS/SSL client certificate authentication, the uFCoder library still allows its use.
    * 
    * If you use X509_PEM as a parameter of the DL_TLS_SetClientCertificate() function call, you have to invoke this function thereafter.
    *
    * @ingroup Card_Tag_CardFeatures_TLS
    *
    * @param cert_type for this parameter you can use one of two enumerated: X509_PEM = 0 or X509_GIDS_NFC = 3.
    * @param cert pointer to certificate
    * @param cert_len certificate len
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DL_TLS_SetClientCertificate(uint32_t cert_type, IN const char *cert, uint32_t cert_len);

    /**
    * @brief Although we do not recommend the use of software digital signing during TLS/SSL client certificate authentication, the uFCoder library still allows its use.
    *
    * @ingroup Card_Tag_CardFeatures_TLS
    *
    * @param priv_key pointer to the private key in PEM format, base64 encoded beginning with “-----BEGIN RSA PRIVATE KEY-----” string and ending with “-----END RSA PRIVATE KEY-----” string. Base64 encoded values should be separated with CR and/or LF ASCII characters on every 64 characters, as stated in the X.509 specification.
    * @param key_bytes_len PEM key size in bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DL_TLS_SetClientX509PrivateKey_PEM(IN const char *priv_key, uint32_t key_bytes_len);

    /**
    * @brief This function transceive HTTPS GET request over TLS 1.2 secure connection implementing TLS/SSL user certificate authentication on server request. 
    * 
    * Request doesn’t contain HTTP body and use minimal of the HTTP headers:
    * GET resource_path HTTP/1.1
    * Host: url:port
    * Accept: *&#47;&#42;
    * Connection: close
    * Important: Once this method completes the request, the library does not use HTTPS any further. The result, if successfully received - can be used at the user's discretion.
    * Any other operation with the result received, requiring HTTP/HTTPS, needs to be implemented separately in the user’s software, uFCoder library does not provide any other methods in our API for this purpose.
    *
    * @ingroup Card_Tag_CardFeatures_TLS
    *
    * @param read_buffer Pointer to char pointer which will, after successful function execution, points to a HTTP response, including HTTP response headers and content. In case of request failure *read_buffer will have NULL value. User is obligated to cleanup allocated memory space, occupied by the *read_buffer, after use (e.g. by calling DLFree(sbuffer) or directly free(sbuffer) from the C/C++ code).
    * @param received_len Length of the HTTP response after successful function execution. In case of request failure *received_len will be 0.
    * @param url  Char pointer to the zero terminated string, contains request URL. e.g. “certificates.d-logic.com”.
    * @param resource_path Char pointer to the zero terminated string, contains a request path to the resource e.g. “/” or “/favicon.ico”.
    * @param port TCP port, 443 in general for HTTPS protocol PIN In case of GIDS smart card in use, this char pointer should point to a string containing GIDS applet ASCII encoded PIN code. Otherwise, this char pointer should have NULL value. PIN_len In case of GIDS smart card applet is in use, this parameter should contain PIN code size. Otherwise, this parameter should be 0.
    * @param PIN In case of GIDS smart card in use, this char pointer should point to a string containing GIDS applet ASCII encoded PIN code. Otherwise, this char pointer should have NULL value.
    * @param PIN_len In case of GIDS smart card applet is in use, this parameter should contain PIN code size. Otherwise, this parameter should be 0.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DL_TLS_Request(VAR char **read_buffer, VAR uint32_t *received_len, IN const char *url, IN const char *resource_path, uint16_t port, IN char *PIN, uint8_t PIN_len);
    //==============================================================================

    /**
    * @brief Function allows you to change the card master key type from DES to AES.
    * 
    * Factory setting for the DESFIRE card master key is the DES key type, and the value is 0x0000000000000000. Because the reader uses AES keys, you must change the type key on AES. New AES key is 0x00000000000000000000000000000000.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DES_to_AES_key_type(void);

    /**
    * @brief Function allow to change the card master key type from AES to DES. 
    * 
    * Set master AES key before use this function to 0x00000000000000000000000000000000. New DES key will be 0x0000000000000000 as in factory settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AES_to_DES_key_type(void);

    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    /**
    * @ingroup Card_Tag_Mifare_Desfire
    */
    enum KEY_TYPE
    {
        AES_KEY_TYPE,
        DES3K_KEY_TYPE,
        DES_KEY_TYPE,
        DES2K_KEY_TYPE
    };

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID).
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                            VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * 128 bit AES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * 64 bit DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    *  128 bit 2K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                   VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    *  192 bit 3K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                   VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Provided Key mode (PK)
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                               VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * 128 bit AES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                   VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * 64 bit DES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                   VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * 128 bit 2K3DES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                      VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * 192 bit 3K3DES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                      VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUidAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                   VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUid3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                      VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUidDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                   VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUid2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                      VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns the available bytes on the card.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param free_mem_byte pointer to free memory variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFreeMem(VAR uint32_t *free_mem_byte, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard(uint8_t aes_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 128 bit AES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_aes(uint8_t aes_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 64 bit DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_des(uint8_t des_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 128 bit 2K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_2k3des(uint8_t des2k_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 192 bit 3K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_3k3des(uint8_t des3k_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Provided Key mode (PK)
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_PK(IN uint8_t *aes_key_ext, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 128 bit AES key provided key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_aes_PK(IN uint8_t *aes_key_ext, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 64 bit DES key provided key
    *
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_des_PK(IN uint8_t *des_key_ext, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 128 bit 2K3DES key provided key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_2k3des_PK(IN uint8_t *des2k_key_ext, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * 192 bit 3K3DES key provided key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_3k3des_PK(IN uint8_t *des3k_key_ext, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCardAesAuth(uint8_t aes_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCard3k3desAuth(uint8_t des3k_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCardDesAuth(uint8_t des3k_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCard2k3desAuth(uint8_t des3k_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. 
    * The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                       uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                       uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * 128 bit AES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                           uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                           uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * 64 bit DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                           uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                           uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * 128 bit 2K3DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * 192 bit 3K3DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Provided Key mode (PK)
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                          uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                          uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    *  128 bit AES key provided key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * 64 bit DES key provided key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * 128 bit 2K3DES key provided key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * 192 bit 3K3DES key provided key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * No authentication
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_no_auth(uint32_t aid, uint8_t file_id, uint32_t file_size, uint8_t read_key_no,
                                                               uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                               uint8_t communication_settings, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_iso(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                               uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication 	communication settings value is 0x00
    * - plain communication secured by MACing 	communication settings value is 0x01
    * - fully enciphered communication		communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 – 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    * Secure Dynamic Message can be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_iso_sdm(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                   uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, uint16_t iso_file_id,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_des_iso(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                               uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3des_iso(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                  uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3des_iso(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                  uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Provided Key mode (PK)
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_iso_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                  uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication 	communication settings value is 0x00
    * - plain communication secured by MACing 	communication settings value is 0x01
    * - fully enciphered communication		communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 – 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    * Secure Dynamic Message can be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [i]
    * @param write_key_no key for writing [j]
    * @param read_write_key_no key for reading and writing [k]
    * @param change_key_no key for changing this setting [l]
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_iso_sdm_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                      uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, uint16_t iso_file_id, uint16_t VAR *card_status, uint16_t VAR *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Provided Key mode (PK)
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_des_iso_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                  uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Provided Key mode (PK)
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3des_iso_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                     uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                     uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Provided Key mode (PK)
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3des_iso_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                     uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                     uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileAesAuthIso(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Desfire EV3 only.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication 	communication settings value is 0x00
    * - plain communication secured by MACing 	communication settings value is 0x01
    * - fully enciphered communication		communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 – 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    * Secure Dynamic Message can be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileAesAuthIsoSdm(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings. 
    * Communication settings define communication mode between reader and card. The communication modes are: 
    * - plain communication communication settings value is 0x00 
    * - plain communication secured by MACing communication settings value is 0x01 
    * - fully enciphered communication communication settings value is 0x03 
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile3k3desAuthIso(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings. 
    * Communication settings define communication mode between reader and card. The communication modes are: 
    * - plain communication communication settings value is 0x00 
    * - plain communication secured by MACing communication settings value is 0x01 
    * - fully enciphered communication communication settings value is 0x03 Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileDesAuthIso(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings. 
    * Communication settings define communication mode between reader and card. The communication modes are: 
    * - plain communication communication settings value is 0x00 
    * - plain communication secured by MACing communication settings value is 0x01 
    * - fully enciphered communication communication settings value is 0x03 Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile2k3desAuthIso(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_no_auth_iso(uint32_t aid, uint8_t file_id, uint32_t file_size, uint8_t read_key_no,
                                                                   uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 128 bit AES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 64 bit DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                              uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 128 bit 2K3DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 192 bit 3K3DES key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * Provided Key mode (PK)
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                             uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                             uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 128 bit AES key provided key
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 64 bit DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 128 bit 2K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * 192 bit 3K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * 
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card.
    * 
    * No authentication
    * From library version 5.0.96, and firmware version 5.0.79.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_no_auth(uint32_t aid, uint8_t file_id, uint32_t file_size, uint8_t read_key_no,
                                                                  uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                  uint8_t communication_settings, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    *
    *  128 bit AES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * 64 bit DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * 128 bit 2K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * 192 bit 3K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Provided Key mode (PK)
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * 128 bit AES key provided key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * 64 bit DES key provided key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * 128 bit 2K3DES key provided key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * 192 bit 3K3DES key provided key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * No authentication
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be deleted (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_no_auth(uint32_t aid, uint8_t file_id, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * 128 bit AES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * 128 bit AES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit AES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 192 bit 3K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 192 bit 3K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 192 bit 3K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit 2K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit 2K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit 2K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 64 bit DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_des(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 64 bit DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_des(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 64 bit DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_des(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * Provided Key mode (PK)
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit AES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit AES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit AES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 192 bit 3K3DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting,
                                                                    uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 192 bit 3K3DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting,
                                                                       uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 192 bit 3K3DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting,
                                                                    uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit 2K3DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting,
                                                                    uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit 2K3DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting,
                                                                       uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 128 bit 2K3DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting,
                                                                    uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 64 bit DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 64 bit DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * 64 bit DES key provided key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * No authentication
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_no_auth(uint32_t aid, uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * No authentication
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_no_auth(uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * No authentication
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_no_auth(uint32_t aid, uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_iso(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                  uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aes_iso(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aes_iso(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                  uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3des_iso(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3des_iso(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3des_iso(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3des_iso(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr rdinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3des_iso(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr rdinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3des_iso(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_des_iso(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                  uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_des_iso(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_des_iso(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                  uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_iso_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aes_iso_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aes_iso_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3des_iso_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3des_iso_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                           uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3des_iso_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3des_iso_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3des_iso_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                           uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3des_iso_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_des_iso_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_des_iso_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_des_iso_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationAesAuthIso(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationAesAuthIso(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationAesAuthIso(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication3k3desAuthIso(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication3k3desAuthIso(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication3k3desAuthIso(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationDesAuthIso(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationDesAuthIso(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationDesAuthIso(uint8_t des_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication2k3desAuthIso(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication2k3desAuthIso(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication2k3desAuthIso(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_no_auth_iso(uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_no_auth_iso(uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                         uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that creates (3 bytes long 0x000000 to 0xFFFFFF)
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_no_auth_iso(uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    * Application specific Capability data enabled.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name ISO/IEC 7816-4 DF (Dedicated File) name
    * @param iso_df_name_len DF name length
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_iso_ascd_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name ISO/IEC 7816-4 DF (Dedicated File) name
    * @param iso_df_name_len DF name length
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_iso_ascd(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card.
    * 
    * From library version 5.0.97, and firmware version 5.0.81.
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name ISO/IEC 7816-4 DF (Dedicated File) name
    * @param iso_df_name_len DF name length
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationAesAuthIsoAscd(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                        uint16_t iso_file_id, uint8_t *iso_df_name, uint8_t iso_df_name_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication(uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_aes(uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_des(uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_2k3des(uint8_t des2k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_3k3des(uint8_t des3k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Provided Key mode (PK)
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_PK(IN uint8_t *aes_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 128 bit AES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 64 bit DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_des_PK(IN uint8_t *des_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 128 bit 2K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 192 bit 3K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplicationAesAuth(uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplicationDesAuth(uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_aes(uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_des(uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_2k3des(uint8_t des2k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_3k3des(uint8_t des3k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Provided Key mode (PK)
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_PK(IN uint8_t *aes_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * 128 bit AES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * 64 bit DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_des_PK(IN uint8_t *des_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * 128 bit 2K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * 192 bit 3K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_AesAuth(uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_DesAuth(uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key
    * @param aid ID of application that deletes (3 bytes long 0x000000 to 0xFFFFFF)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration(uint8_t aes_key_nr, uint8_t random_uid, uint8_t format_disable, VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 128 bit AES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_aes(uint8_t aes_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 64 bit DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_des(uint8_t des_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 128 bit 2K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_2k3des(uint8_t des2k_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 192 bit 3K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_3k3des(uint8_t des3k_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Provided Key mode (PK)
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_PK(IN uint8_t *aes_key_ext, uint8_t random_uid, uint8_t format_disable,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 128 bit AES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_aes_PK(IN uint8_t *aes_key_ext, uint8_t random_uid, uint8_t format_disable,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 64 bit DES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_des_PK(IN uint8_t *des_key_ext, uint8_t random_uid, uint8_t format_disable,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 128 bit 2K3DES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_2k3des_PK(IN uint8_t *des2k_key_ext, uint8_t random_uid, uint8_t format_disable,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * 192 bit 3K3DES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_3k3des_PK(IN uint8_t *des3k_key_ext, uint8_t random_uid, uint8_t format_disable,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfigurationAesAuth(uint8_t aes_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfiguration3k3desAuth(uint8_t des3k_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfigurationDesAuth(uint8_t des_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfiguration2k3desAuth(uint8_t des2k_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings(uint8_t aes_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 128 bit AES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_aes(uint8_t aes_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 64 bit DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_des(uint8_t des_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 128 bit 2K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_2k3des(uint8_t des2k_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 192 bit 3K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_3k3des(uint8_t des3k_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Provided Key mode (PK)
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_PK(IN uint8_t *aes_key_ext, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 128 bit AES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, VAR uint8_t *setting,
                                                           VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 64 bit DES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_des_PK(IN uint8_t *des_key_ext, uint32_t aid, VAR uint8_t *setting,
                                                           VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 128 bit 2K3DES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, VAR uint8_t *setting,
                                                              VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * 192 bit 3K3DES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, VAR uint8_t *setting,
                                                              VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettingsAesAuth(uint8_t aes_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettings3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettingsDesAuth(uint8_t des_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettings2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * No authentication
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_no_auth(uint32_t aid, VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 128 bit AES key
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_des(uint8_t des_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Provided Key mode (PK)
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 128 bit 2K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettingsAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettings3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettingsDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to key settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettings2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t setting, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card. 
    * 
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key 16 bytes array that represent AES key
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key 16 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_no_auth, IN uint8_t new_aes_key[16],
                                                  uint8_t aid_key_no, IN uint8_t old_aes_key[16], VAR uint16_t *card_status,
                                                  VAR uint16_t *exec_time);
    /**
    * @brief Function allows you to change any AES key on the card. 
    * 
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key_nr ordinal number of authentication AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey_A(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_no_auth, uint8_t new_aes_key_nr,
                                                    uint8_t aid_key_no, uint8_t old_aes_key_nr, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card.
    * 
    * 128 bit AES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key_nr ordinal number of authentication AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_no_auth, uint8_t new_aes_key_nr,
                                                      uint8_t aid_key_no, uint8_t old_aes_key_nr, VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * 64 bit DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr ordinal number of authentication AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr ordinal number of authentication AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_des(uint8_t auth_des_key_nr, uint32_t aid, uint8_t aid_key_no_auth, uint8_t new_des_key_nr,
                                                      uint8_t aid_key_no, uint8_t old_des_key_nr, VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * 64 bit DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key_nr ordinal number of authentication AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key_nr ordinal number of authentication AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_des(uint8_t auth_des_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                         uint8_t new_2k3des_key_nr, uint8_t aid_key_no, uint8_t old_2k3des_key_nr,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des2k_key_nr auth_des2k_key_nr
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr ordinal number of authentication AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr ordinal number of authentication AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_2k3des(uint8_t auth_des2k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                         uint8_t new_des_key_nr, uint8_t aid_key_no, uint8_t old_des_key_nr,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des2k_key_nr auth_des2k_key_nr
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key_nr ordinal number of authentication AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key_nr ordinal number of authentication AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_2k3des(uint8_t auth_des2k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                            uint8_t new_2k3des_key_nr, uint8_t aid_key_no, uint8_t old_2k3des_key_nr,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 3K3DES key on the card.
    * 
    * 192 bit 3K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des3k_key_nr ordinal number of authentication 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_3k3des_key_nr ordinal number of authentication AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_3k3des_key_nr ordinal number of authentication AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange3K3DesKey_3k3des(uint8_t auth_des3k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                            uint8_t new_3k3des_key_nr, uint8_t aid_key_no, uint8_t old_3k3des_key_nr,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change master key of the card from any type to any type. 
    * 
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_nr ordinal number of key in the reader
    * @param auth_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param new_key_nr ordinal number of authentication AES key in the reader
    * @param new_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeMasterKey(uint8_t auth_key_nr, uint8_t auth_key_type, uint8_t new_key_nr, uint8_t new_key_type,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card. 
    * 
    * Provided Key mode (PK)
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key 16 bytes array that represent AES key
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key 16 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_no_auth,
                                                     IN uint8_t new_aes_key[16], uint8_t aid_key_no, IN uint8_t old_aes_key[16],
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card.
    * 
    * 128 bit AES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key 16 bytes array that represent AES key
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key 16 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_no_auth,
                                                         IN uint8_t new_aes_key[16], uint8_t aid_key_no, IN uint8_t old_aes_key[16],
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * 64 bit DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des_key pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key 8 bytes array that represent DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key 8 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_des_PK(IN uint8_t *auth_des_key, uint32_t aid, uint8_t aid_key_no_auth,
                                                         IN uint8_t new_des_key[8], uint8_t aid_key_no, IN uint8_t old_des_key[8],
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * 64 bit DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des_key pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key 16 bytes array that represent 2K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key 16 bytes array that represent current 2K3DES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_des_PK(IN uint8_t *auth_des_key, uint32_t aid, uint8_t aid_key_no_auth,
                                                            IN uint8_t new_2k3des_key[16], uint8_t aid_key_no, IN uint8_t old_2k3des_key[16],
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * 128 bit 2K3DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des2k_key ordinal number of authentication 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key 8 bytes array that represent DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key 8 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_2k3des_PK(IN uint8_t *auth_des2k_key, uint32_t aid, uint8_t aid_key_no_auth,
                                                            IN uint8_t new_des_key[8], uint8_t aid_key_no, IN uint8_t old_des_key[8],
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * 128 bit 2K3DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des2k_key ordinal number of authentication 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key 16 bytes array that represent 2K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key 16 bytes array that represent current 2K3DES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_2k3des_PK(IN uint8_t *auth_des2k_key, uint32_t aid, uint8_t aid_key_no_auth,
                                                               IN uint8_t new_2k3des_key[16], uint8_t aid_key_no, IN uint8_t old_2k3des_key[16],
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 3K3DES key on the card.
    * 
    * 192 bit 3K3DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_des3k_key pointer to 32 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_3k3des_key 24 bytes array that represent 3K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_3k3des_key 24 bytes array that represent current 3K3DES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange3K3DesKey_3k3des_PK(IN uint8_t *auth_des3k_key, uint32_t aid, uint8_t aid_key_no_auth,
                                                               IN uint8_t new_3k3des_key[24], uint8_t aid_key_no, IN uint8_t old_3k3des_key[24],
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change master key of the card from any type to any type.
    * 
    * Provided Key mode (PK)
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key pointer to array contained AES key
    * @param auth_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param new_key pointer to array contained new AES key
    * @param new_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeMasterKey_PK(IN uint8_t *auth_key, uint8_t auth_key_type, IN uint8_t *new_key, uint8_t new_key_type,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key_nr ordinal number of AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeAesKey_AesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_no_auth, uint8_t new_aes_key_nr,
                                                          uint8_t aid_key_no, uint8_t old_aes_key_nr, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 3K3DES key on the card.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChange3k3desKey_3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                                uint8_t new_des3k_key_nr, uint8_t aid_key_no, uint8_t old_des3k_key_nr,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr ordinal number of 3K3DES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeDesKey_DesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_no_auth, uint8_t new_des_key_nr,
                                                          uint8_t aid_key_no, uint8_t old_des_key_nr, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr ordinal number of DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChange2k3desKey_DesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                             uint8_t new_des2k_key_nr, uint8_t aid_key_no, uint8_t old_des_key_nr,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr ordinal number of DES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeDesKey_2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                             uint8_t new_des_key_nr, uint8_t aid_key_no, uint8_t old_des2k_key_nr,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Function allows you to change any AES key on the card. Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @param des2k_key_nr  ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChange2k3desKey_2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                                uint8_t new_des2k_key_nr, uint8_t aid_key_no, uint8_t old_des2k_key_nr,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change master key of the card from any type to any type.
    * 
    * *only uFR CS with SAM support
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_nr ordinal number of key in the reader
    * @param auth_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param new_key_nr ordinal number of key in the reader
    * @param new_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeMasterKey(uint8_t auth_key_nr, uint8_t auth_key_type, uint8_t new_key_nr, uint8_t new_key_type,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function writes AES key (16 bytes) into reader.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_no ordinal number of AES key in the reader (0 - 15)
    * @param aes_key pointer to 16 byte array containing the AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteAesKey(uint8_t aes_key_no, IN uint8_t *aes_key);

    /**
    * @brief Function writes AES key (16 bytes) into reader.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param key_no ordinal number of key in the reader (0 - 15)
    * @param key pointer to array containing the key
    * @param key_type enumerated key type (0 - 3)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteKey(uint8_t key_no, IN uint8_t *key, uint8_t key_type);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                     uint16_t data_length, uint8_t communication_settings, OUT uint8_t *data,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                         uint16_t data_length, uint8_t communication_settings, OUT uint8_t *data,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                         uint16_t data_length, uint8_t communication_settings, OUT uint8_t *data,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                            uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                            OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                            uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                            OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Provided Key mode (PK)
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                        OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 128 bit AES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                            uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                            OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 64 bit DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                            uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                            OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 128 bit 2K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                               OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * 192 bit 3K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                               OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                            uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                            OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                               OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                            uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                            OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                               OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * No authentication
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                             uint16_t data_length, uint8_t communication_settings, OUT uint8_t *data,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                      uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                          IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                          IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * Provided Key mode (PK)
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                         uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                         IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * 128 bit AES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * 192 bit 3K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File. 
    * 
    * 64 bit DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * 128 bit 2K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * No authentication
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                              uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 128 bit AES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 192 bit 3K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 64 bit DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                             IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 128 bit 2K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 128 bit AES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 192 bit 3K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                   IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 64 bit DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * 128 bit 2K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                   IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * 
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * 
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                   IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * 
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * 
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                   IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * No authentication
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                                 uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                     int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled, uint8_t read_key_no,
                                                     uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                     uint8_t communication_settings, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                         int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                         uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                         uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                         int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                         uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                         uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                            int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                            uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                            int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                            uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * Provided Key mode (PK)
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                        int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled, uint8_t read_key_no,
                                                        uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                        uint8_t communication_settings, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                            int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                            uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                            int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                            uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                               int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                               uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                               int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                               uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                            int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                            uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                               int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                               uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                            int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                            uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                               int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                               uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * No authentication
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_no_auth(uint32_t aid, uint8_t file_id, int32_t lower_limit, int32_t upper_limit,
                                                             int32_t value, uint8_t limited_credit_enabled, uint8_t read_key_no,
                                                             uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                             uint8_t communication_settings, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                   uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                       uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                       uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Provided Key mode (PK)
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                      uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * No authentication
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint8_t communication_settings,
                                                           VAR int32_t *value, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                       uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Provided Key mode (PK)
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * No authentication
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                    uint8_t communication_settings, uint32_t value,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                    uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                    VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                    uint8_t communication_settings, uint32_t value,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                    uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                    VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_AesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_DesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                           uint8_t communication_settings, uint32_t value,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                           uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                           VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                           uint8_t communication_settings, uint32_t value,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                           uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                           VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          uint8_t communication_settings, uint32_t value,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          uint8_t communication_settings, uint32_t value,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * No authentication
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                       uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_3k3des(uint8_t des3_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Provided Key mode (PK)
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                          uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit AES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 64 bit DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit 2K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 192 bit 3K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * No authentication
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                    uint8_t communication_settings, uint32_t value,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                    uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                    VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                    uint8_t communication_settings, uint32_t value,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                    uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                    VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_AesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_DesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                           uint8_t communication_settings, uint32_t value,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                           uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                           VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                           uint8_t communication_settings, uint32_t value,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                           uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                           VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit AES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 64 bit DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       uint8_t communication_settings, uint32_t value,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 128 bit 2K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          uint8_t communication_settings, uint32_t value,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * 192 bit 3K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value         (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          uint8_t communication_settings, uint32_t value,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * No authentication
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds(uint8_t aes_key_nr, OUT uint32_t *application_ids, VAR uint8_t *number_of_aplication_ids,
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 128 bit AES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_aes(uint8_t aes_key_nr, OUT uint32_t *application_ids,
                                                           VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 64 bit DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_des(uint8_t des_key_nr, OUT uint32_t *application_ids,
                                                           VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_2k3des(uint8_t des2k_key_nr, OUT uint32_t *application_ids,
                                                              VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_3k3des(uint8_t des3k_key_nr, OUT uint32_t *application_ids,
                                                              VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIdsAesAuth(uint8_t aes_key_nr, OUT uint32_t *application_ids,
                                                              VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIds3k3desAuth(uint8_t des3k_key_nr, OUT uint32_t *application_ids,
                                                                 VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIdsDesAuth(uint8_t des_key_nr, OUT uint32_t *application_ids,
                                                              VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIds2k3desAuth(uint8_t des2k_key_nr, OUT uint32_t *application_ids,
                                                                 VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Provided Key mode (PK)
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_PK(IN uint8_t *aes_key_ext, OUT uint32_t *application_ids,
                                                          VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 128 bit AES key provided key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_aes_PK(IN uint8_t *aes_key_ext, OUT uint32_t *application_ids,
                                                              VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 64 bit DES key provided key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_des_PK(IN uint8_t *des_key_ext, OUT uint32_t *application_ids,
                                                              VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 128 bit 2K3DES key provided key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_2k3des_PK(IN uint8_t *des2k_key_ext, OUT uint32_t *application_ids,
                                                                 VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * 192 bit 3K3DES key provided key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_3k3des_PK(IN uint8_t *des3k_key_ext, OUT uint32_t *application_ids,
                                                                 VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * No authentication
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_no_auth(OUT uint32_t *application_ids, VAR uint8_t *number_of_aplication_ids,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit AES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 64 bit DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit 2K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 192 bit 3K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                      uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                      uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                      uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                      uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit AES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                   uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 64 bit DES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                   uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit 2K3DES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id,
                                                                      uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                      uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 192 bit 3K3DES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id,
                                                                      uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                      uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * No authentication
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_no_auth(uint32_t aid, uint8_t file_id, uint32_t record_size, uint32_t max_rec_no,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit AES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 64 bit DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_des(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit 2K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 192 bit 3K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFileAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFile3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                      uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                      uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFileDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                   uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFile2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                      uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                      uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit AES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                   uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 64 bit DES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                   uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 128 bit 2K3DES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id,
                                                                      uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                      uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * 192 bit 3K3DES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id,
                                                                      uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                      uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * No authentication
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_no_auth(uint32_t aid, uint8_t file_id, uint32_t record_size, uint32_t max_rec_no,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                     uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                     uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecordAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                        uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                           IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecordDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                        uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                           IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit AES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 64 bit DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit 2K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                           IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 192 bit 3K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                           IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * No authentication
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                         uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                              uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                              OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                              uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                              uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                              OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                 uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                 OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                 uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                 OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_AesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                  uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                  uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                  OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_DesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                  uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                  uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                  OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                     uint16_t offset, uint16_t data_length,
                                                                     uint8_t communication_settings, IN uint8_t *data,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                     uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                     OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_3k3desAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                     uint16_t offset, uint16_t data_length,
                                                                     uint8_t communication_settings, IN uint8_t *data,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                     uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                     OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit AES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                 uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                 OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 64 bit DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                 uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                 OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit 2K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                    uint16_t offset, uint16_t data_length,
                                                                    uint8_t communication_settings, IN uint8_t *data,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                    uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                    OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * 192 bit 3K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                    uint16_t offset, uint16_t data_length,
                                                                    uint8_t communication_settings, IN uint8_t *data,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                    uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                    OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * No authentication
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the  Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                  uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                  uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                  OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                     uint16_t number_of_records, uint16_t record_size, uint8_t communication_settings,
                                                     OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_des(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                     uint16_t number_of_records, uint16_t record_size, uint8_t communication_settings,
                                                     OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                        uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                        uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecordsAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                        uint16_t number_of_records, uint16_t record_size, uint8_t communication_settings,
                                                        OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecords3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                           uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecordsDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                        uint16_t number_of_records, uint16_t record_size, uint8_t communication_settings,
                                                        OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecords2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                           uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit AES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                        uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 64 bit DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                        uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                        uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 128 bit 2K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                           uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * 192 bit 3K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                           uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                           uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * No authentication
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_no_auth(uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                         uint16_t number_of_records, uint16_t record_size, uint8_t communication_settings,
                                                         OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile(
        uint8_t aes_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aes(
        uint8_t aes_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_des(
        uint8_t des_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3des(
        uint8_t des2k_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3des(
        uint8_t des3k_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFileAesAuth(
        uint8_t aes_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile3k3desAuth(
        uint8_t des3k_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFileDesAuth(
        uint8_t des_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile2k3desAuth(
        uint8_t des2k_key_nr,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Provided Key mode (PK)
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_PK(
        IN uint8_t *aes_key_ext,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit AES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aes_PK(
        IN uint8_t *aes_key_ext,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 64 bit DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_des_PK(
        IN uint8_t *des_key_ext,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit 2K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3des_PK(
        IN uint8_t *des2k_key_ext,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 192 bit 3K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3des_PK(
        IN uint8_t *des3k_key_ext,
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * No authentication
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_no_auth(
        uint32_t aid,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aes_2(
        uint8_t aes_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_des_2(
        uint8_t des_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3des_2(
        uint8_t des2k_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3des_2(
        uint8_t des3k_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFileAesAuth_2(
        uint8_t aes_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile3k3desAuth_2(
        uint8_t des3k_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFileDesAuth_2(
        uint8_t des_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile2k3desAuth_2(
        uint8_t des2k_key_nr,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit AES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aes_PK_2(
        IN uint8_t *aes_key_ext,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 64 bit DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_des_PK_2(
        IN uint8_t *des_key_ext,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit 2K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3des_PK_2(
        IN uint8_t *des2k_key_ext,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 192 bit 3K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3des_PK_2(
        IN uint8_t *des3k_key_ext,
        uint32_t aid,
        uint8_t aid_key_nr,
        uint8_t file_id,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_aes(
        uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_des(
        uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_2k3des(
        uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_3k3des(
        uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_AesAuth(
        uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_DesAuth(
        uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_2k3desAuth(
        uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_3k3desAuth(
        uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit AES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_aes_PK(
        IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 64 bit DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_des_PK(
        IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 128 bit 2K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_2k3des_PK(
        IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * 192 bit 3K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_3k3des_PK(
        IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * No authentication
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_no_auth(
        uint32_t aid, uint8_t file_id,
        VAR uint16_t *card_status, VAR uint16_t *exec_time,
        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_aes(
        uint8_t aes_key_nr,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_des(
        uint8_t des_key_nr,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_2k3des(
        uint8_t des2k_key_nr,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_3k3des(
        uint8_t des3k_key_nr,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_aes_PK(
        IN uint8_t *aes_key_ext,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_des_PK(
        IN uint8_t *des_key_ext,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 128 bit 2K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_2k3des_PK(
        IN uint8_t *des2k_key_ext,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_3k3des_PK(
        IN uint8_t *des3k_key_ext,
        uint32_t aid,
        uint8_t file_id,
        uint8_t read_key_no,
        uint8_t commit_reader_id_key_no,
        uint8_t change_key_no,
        uint8_t communication_settings,
        IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status,
        VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFileAesAuth(
        uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
        uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
        uint8_t communication_settings, IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFileDesAuth(
        uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
        uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
        uint8_t communication_settings, IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFile2k3desAuth(
        uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
        uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
        uint8_t communication_settings, IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFile3k3desAuth(
        uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
        uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
        uint8_t communication_settings, IN uint8_t *trans_mac_key,
        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_des_PK(IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 128 bit 2K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_2k3des_PK(IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_3k3des_PK(IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * No authentication
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_no_auth(uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_des(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_2k3des(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_3k3des(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSizeAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSize3k3desAuth(uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSizeDesAuth(uint8_t des_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSize2k3desAuth(uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_aes_PK(IN uint8_t *aes_key_ext,
                                                            uint32_t aid, uint8_t file_id,
                                                            VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                            VAR uint32_t *file_size,
                                                            VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                            VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                            VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_des_PK(IN uint8_t *des_key_ext,
                                                            uint32_t aid, uint8_t file_id,
                                                            VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                            VAR uint32_t *file_size,
                                                            VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                            VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                            VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 128 bit 2K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_2k3des_PK(IN uint8_t *des2k_key_ext,
                                                               uint32_t aid, uint8_t file_id,
                                                               VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                               VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                               VAR uint32_t *file_size,
                                                               VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                               VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                               VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_3k3des_PK(IN uint8_t *des3k_key_ext,
                                                               uint32_t aid, uint8_t file_id,
                                                               VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                               VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                               VAR uint32_t *file_size,
                                                               VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                               VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                               VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * No authentication
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_no_auth(
        uint32_t aid, uint8_t file_id,
        VAR uint8_t *file_type, VAR uint8_t *communication_mode,
        VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
        VAR uint32_t *file_size,
        VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
        VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
        VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_aes(uint8_t aes_key_nr,
                                                         uint32_t aid, uint8_t file_id,
                                                         VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                         VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                         VAR uint32_t *file_size,
                                                         VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                         VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                         VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_des(uint8_t des_key_nr,
                                                         uint32_t aid, uint8_t file_id,
                                                         VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                         VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                         VAR uint32_t *file_size,
                                                         VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                         VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                         VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_2k3des(uint8_t des2k_key_nr,
                                                            uint32_t aid, uint8_t file_id,
                                                            VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                            VAR uint32_t *file_size,
                                                            VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                            VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                            VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_3k3des(uint8_t des3k_key_nr,
                                                            uint32_t aid, uint8_t file_id,
                                                            VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                            VAR uint32_t *file_size,
                                                            VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                            VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                            VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettingsAesAuth(uint8_t aes_key_nr,
                                                            uint32_t aid, uint8_t file_id,
                                                            VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                            VAR uint32_t *file_size,
                                                            VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                            VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                            VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettingsDesAuth(uint8_t des_key_nr,
                                                            uint32_t aid, uint8_t file_id,
                                                            VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                            VAR uint32_t *file_size,
                                                            VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                            VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                            VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettings2k3desAuth(uint8_t des2k_key_nr,
                                                               uint32_t aid, uint8_t file_id,
                                                               VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                               VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                               VAR uint32_t *file_size,
                                                               VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                               VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                               VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettings3k3desAuth(uint8_t des3k_key_nr,
                                                               uint32_t aid, uint8_t file_id,
                                                               VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                               VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                               VAR uint32_t *file_size,
                                                               VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                               VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                               VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param sdm_enable Secure Dynamic Messaging enable status
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettingsSdm_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                               VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                               VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                               VAR uint32_t *file_size, VAR uint8_t *sdm_enable,
                                                               VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                               VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                               VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                               VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param sdm_enable Secure Dynamic Messaging enable status
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettingsSdm_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                            VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                            VAR uint32_t *file_size, VAR uint8_t *sdm_enable,
                                                            VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                            VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                            VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                            VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param sdm_enable Secure Dynamic Messaging enable status
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettingsSdmAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                               VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                               VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                               VAR uint32_t *file_size, VAR uint8_t *sdm_enable,
                                                               VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                               VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                               VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                               VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_aes(uint8_t aes_key_nr,
                                                            uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_des(uint8_t des_key_nr,
                                                            uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_2k3des(uint8_t des2k_key_nr,
                                                               uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_3k3des(uint8_t des3k_key_nr,
                                                               uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_aes_PK(IN uint8_t *aes_key_ext,
                                                               uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_des_PK(IN uint8_t *des_key_ext,
                                                               uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_2k3des_PK(IN uint8_t *des2k_key_ext,
                                                                  uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_3k3des_PK(IN uint8_t *des3k_key_ext,
                                                                  uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * *only uFR CS with SAM support
    * Function allows changing of file settings
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettingsAesAuth(uint8_t aes_key_nr,
                                                               uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * *only uFR CS with SAM support
    * Function allows changing of file settings
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettingsDesAuth(uint8_t des_key_nr,
                                                               uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * *only uFR CS with SAM support
    * Function allows changing of file settings
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettings2k3desAuth(uint8_t des2k_key_nr,
                                                                  uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * *only uFR CS with SAM support
    * Function allows changing of file settings
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param des3k_key_nr ordinal number of 3k3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettings3k3desAuth(uint8_t des3k_key_nr,
                                                                  uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                  uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * Security Dynamic Messaging settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param communication_settings communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettingsSdm(uint8_t aes_key_nr,
                                                           uint32_t aid, uint8_t file_no, uint8_t communication_settings,
                                                           uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                           uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                           uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                           uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                           uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * Desfire EV3 only.
    * Security Dynamic Messaging settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param communication_settings communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettingsSdm_PK(IN uint8_t *aes_key_ext,
                                                              uint32_t aid, uint8_t file_no, uint8_t communication_settings,
                                                              uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                              uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                              uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                              uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                              uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Desfire EV3 only.
    * *only uFR CS with SAM support
    * Security Dynamic Messaging settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param communication_settings communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettingsSdm(uint8_t aes_key_nr,
                                                           uint32_t aid, uint8_t file_no, uint8_t communication_settings,
                                                           uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                           uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                           uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                           uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                           uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function set value of application transaction timer.
    * 
    * Desfire EV3 only.
    * At the current application specific capability data option must be enabled.
    * Application must be created by function uFR_int_DesfireCreateAesApplication_aes_iso_ascd.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param transaction_timer 0 - disabled, 1 - 1 - 3 seconds, 2 - 10 - 30 seconds, 3 - 100 - 300 seconds
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetTransactionTimer_aes_PK(IN uint8_t *aes_key_ext, uint32_t aid, uint8_t transaction_timer, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function set value of application transaction timer.
    * 
    * Desfire EV3 only.
    * At the current application specific capability data option must be enabled.
    * Application must be created by function uFR_int_DesfireCreateAesApplication_aes_iso_ascd.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param transaction_timer 0 - disabled, 1 - 1 - 3 seconds, 2 - 10 - 30 seconds, 3 - 100 - 300 seconds
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetTransactionTimer_aes(uint8_t aes_key_nr, uint32_t aid, uint8_t transaction_timer, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function set value of application transaction timer.
    * 
    * *only uFR CS with SAM support
    * Desfire EV3 only.
    * At the current application specific capability data option must be enabled.
    * Application must be created by function uFR_int_DesfireCreateAesApplication_aes_iso_ascd.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param transaction_timer 0 - disabled, 1 - 1 - 3 seconds, 2 - 10 - 30 seconds, 3 - 100 - 300 seconds
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetTransactionTimerAesAuth(uint8_t aes_key_nr, uint32_t aid, uint8_t transaction_timer, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 64 bit DES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param lpucECCSignature 56 bytes ECC signature
    * @param card_uid 7 bytes length card UID
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireUidReadECCSignature(OUT uint8_t *lpucECCSignature, OUT uint8_t *card_uid, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 64 bit DES key provided key
    * Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_des_PK(IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit 2K3DES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_2k3des_PK(IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                   OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 192 bit 3K3DES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_3k3des_PK(IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                   OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit AES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_aes_PK(IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 64 bit DES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_des(uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                             OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit 2K3DES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_2k3des(uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 192 bit 3K3DES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_3k3des(uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit AES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_aes(uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                             OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function used to create and initialize necessary application/files for storing NDEF message 
    * 
    * The procedure involves following steps:
    * * Tries switching card master key from factory DES key to new AES key (16 bytes 0x00)
    * * Wipes the card data, complete format with new default AES key (16 bytes 0x00)
    * * Creates AES Application with AID 1, maximum key number 1, app settings 0x0F
    * * In AID 1 creates two new file for the purpose of NDEF message
    * * CC File: Stored in AID 1, File ID 1, File size: 16, Access rights: 'Read' is free (no auth), writing/changing file settings  will require authentication with AID key 0 of the NDEF application (AID 1, key 0)
    * * NDEF File: Stored in AID 1, File ID 2, File size: Provided by 'ndef_file_size, Access rights: 'Read' is free (no auth),  writing/changing file settings  will require authentication with AID key 0 of the NDEF application (AID 1, key 0)
    * * Writes necessary data to the CC file
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param ndef_file_size Defines maximum size for the newly created NDEF file that will store NDEF message, if set as '0' function checks free memory on the card and uses all of it for the NDEF file
    * @param write_mode Defines whether NDEF files (CC and NDEF file) that will be created, can be written to freely, or require application master key for the write operation. Value 0 - free mode, Value 1 - will require application master key for writing to files.
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireNDEFFormat(uint32_t ndef_file_size, uint8_t write_mode);

    /**
    * @brief Function used to write NDEF message to the Desfire card 
    * 
    * Writes data directly to the NDEF File previously created by the uFR_int_DesfireNDEFFormat() function
    * And such it addresses the AID 1 -> File 2, and overwrites the contents with data provided
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param data Array containing NDEF message data stored in a buffer to be written
    * @param data_length length of the data to be written
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteNDEFMessage(IN uint8_t *data, uint32_t data_length);

    /**
    * @brief Function used to read the whole NDEF message stored on the Desfire card
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param message pointer to array that will hold message data
    * @param message_length length of the message that was read if successfull 
    * 
    * @return Operation status
    */

    UFR_STATUS DL_API uFR_int_DesfireReadNDEFMessage(OUT uint8_t* message, uint32_t *message_length);
    /**
    * @brief Function used to extract the payload of the NDEF message stored on the Desfire card
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    *
    * @param payload_str pointer to buffer that will hold payload data
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadNDEFPayload(OUT char* payload_str);

    /**
    * @brief Function used to write the payload of the NDEF message on the Desfire card
    * 
    * @ingroup Card_Tag_Mifare_Desfire
    * 
    * The function takes in only c-string URI, and sets it's uri_identifier to 0 so it is not prefixed by anything when read.
    *
    * @param payload_str pointer to buffer that will hold message data
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteNDEFPayload(IN c_string payload_str);
    
    /////////////////////////////////////////////////////////////////////

    /**
    * @brief The function allows the blinking of the green diode independently of the user's signaling command (default setting).
    * 
    * This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_Signalization
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GreenLedBlinkingTurnOn(void);

    /**
    * @brief The function prohibits the blinking of the green diode independently of the user's signaling command.
    * 
    * LED and sound signaling occurs only on the user command. This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_Signalization
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GreenLedBlinkingTurnOff(void);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbInternalTurnOn(void);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbInternalTurnOff(void);

    /////////////////////////////////////////////////////////////////////

    /**
    * @brief Allow user to adjust the value of several registers on PN512.
    * 
    * These are registers: RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeA(uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp, uint8_t RxGain,
                                                uint8_t RFLevel);

    /**
    * @brief Allow user to adjust the value of several registers on PN512.
    * 
    * These are registers: RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeB(uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp, uint8_t RxGain,
                                                uint8_t RFLevel);

    /**
    * @brief Allow user to adjust the value of several registers on PN512.
    * 
    * These are registers: RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_212(uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp,
                                                       uint8_t RxGain, uint8_t RFLevel);

    /**
    * @brief Allow user to adjust the value of several registers on PN512.
    * 
    * These are registers: RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_424(uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp,
                                                       uint8_t RxGain, uint8_t RFLevel);

    /**
    * @brief The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeADefault(void);

    /**
    * @brief The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeBDefault(void);

    /**
    * @brief The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_212Default(void);

    /**
    * @brief The functions set the factory default settings of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_424Default(void);

    /**
    * @brief The functions read the value of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg RxGain
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeA(VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel, VAR uint8_t *RFLevelAmp,
                                                VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief The functions read the value of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg RxGain
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeB(VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel, VAR uint8_t *RFLevelAmp,
                                                VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief The functions read the value of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg RxGain
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersISO14443_212(VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel, VAR uint8_t *RFLevelAmp,
                                                       VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief The functions read the value of the registers RFCfgReg and RxThresholdReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    * 
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersISO14443_424(VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel, VAR uint8_t *RFLevelAmp,
                                                       VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief Functions allow adjusting values of registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg. 
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param CWGsNOff value in range 0 - 15, part of GsNOffReg
    * @param ModGsNOff value in range 0 - 15, part of GsNOffReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeATrans(uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp, uint8_t RxGain,
                                                     uint8_t RFLevel, uint8_t CWGsNOn, uint8_t ModGsNOn, uint8_t CWGsP, uint8_t CWGsNOff,
                                                     uint8_t ModGsNOff);

    /**
    * @brief Functions allow adjusting values of registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg. 
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param ModGsP value of ModGsPReg (0 - 47)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeBTrans(uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp, uint8_t RxGain,
                                                     uint8_t RFLevel, uint8_t CWGsNOn, uint8_t ModGsNOn, uint8_t CWGsP, uint8_t ModGsP);

    /**
    * @brief The functions read the value of the registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param CWGsNOff value in range 0 - 15, part of GsNOffReg
    * @param ModGsNOff value in range 0 - 15, part of GsNOffReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeATrans(VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel, VAR uint8_t *RFLevelAmp,
                                                     VAR uint8_t *RxGain, VAR uint8_t *RFLevel, VAR uint8_t *CWGsNOn, VAR uint8_t *ModGsNOn,
                                                     VAR uint8_t *CWGsP, VAR uint8_t *CWGsNOff, VAR uint8_t *ModGsNOff);

    /**
    * @brief The functions read the value of the registers RFCfgReg, RxThresholdReg, GsNOnReg, GsNOffReg, CWGsPReg, ModGsPReg.
    * 
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings
    *
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param ModGsP value of ModGsPReg (0 - 47)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeBTrans(VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel, VAR uint8_t *RFLevelAmp,
                                                     VAR uint8_t *RxGain, VAR uint8_t *RFLevel, VAR uint8_t *CWGsNOn, VAR uint8_t *ModGsNOn,
                                                     VAR uint8_t *CWGsP, VAR uint8_t *ModGsP);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API FastFlashCheck(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API DefaultBaudrateFlashCheck(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API GetReaderParameters(OUT uint8_t *mui, OUT uint8_t *serial_nr, VAR uint8_t *hw_type, VAR uint8_t *hw_ver,
                                          VAR uint8_t *device_type, VAR uint8_t *fw_ver_major, VAR uint8_t *fw_ver_minor,
                                          VAR uint8_t *fw_ver_build);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API GetReaderParametersDefaultBaudrate(OUT uint8_t *mui, OUT uint8_t *serial_nr, VAR uint8_t *hw_type, VAR uint8_t *hw_ver,
                                                         VAR uint8_t *device_type, VAR uint8_t *fw_ver_major, VAR uint8_t *fw_ver_minor,
                                                         VAR uint8_t *fw_ver_build);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API GetReaderParametersPN7462(OUT uint8_t *die_id, OUT uint8_t *serial_nr, VAR uint8_t *hw_type, VAR uint8_t *hw_ver,
                                                VAR uint8_t *device_type, VAR uint8_t *fw_ver_major, VAR uint8_t *fw_ver_minor, VAR uint8_t *fw_ver_build);

    // SAM
    /**
    * @brief Function returns manufacturing related data of the MIFARE SAM. For more information refer to  NXP documentation.
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param data pointer to array containing version data
    * @param length pointer to length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_get_version_raw(OUT uint8_t *data, VAR uint8_t *length);

    /**
    * @brief Function returns manufacturing related data of the MIFARE SAM. For more information refer to  NXP documentation.
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param sam_type pointer to SAM type variable
    * @param sam_uid pointer to array containing 7 bytes UID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_get_version(VAR SAM_HW_TYPE *sam_type, OUT uint8_t *sam_uid);

    /**
    * @brief Function allows reading the contents of the key entry specified in the parameter key_no. For more information refer to  NXP documentation.
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_no key reference number (0 - 127)
    * @param key_entry pointer to array containing key entry data
    * @param key_length pointer to key entry length variable
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_get_key_entry_raw(uint8_t key_no, OUT uint8_t *key_entry, VAR uint8_t *key_length, OUT uint8_t *apdu_sw);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @param key_no key_no
    * @param key_v key_v
    * @param des_key des_key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_authenticate_host_no_div_des(uint8_t key_no, uint8_t key_v, IN uint8_t *des_key);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @param aes_key_ver_a aes_key_ver_a
    * @param ver_a ver_a
    * @param aes_key_ver_b aes_key_ver_b
    * @param ver_b ver_b
    * @param aes_key_ver_c aes_key_ver_c
    * @param ver_c ver_c
    * @param apdu_sw apdu_sw
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_pre_pesonalization_master_AES128_key(IN uint8_t *aes_key_ver_a, uint8_t ver_a, IN uint8_t *aes_key_ver_b,
                                                               uint8_t ver_b, IN uint8_t *aes_key_ver_c, uint8_t ver_c, OUT uint8_t *apdu_sw);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @param master_aes_key master_aes_key
    * @param key_version key_version
    * @param apdu_sw apdu_sw
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_pre_personalization_switch_to_AV2_mode(IN uint8_t *master_aes_key, uint8_t key_version, OUT uint8_t *apdu_sw);

    /**
    * @brief Function is used to run a mutual 3-pass authentication between the MIFARE SAM AV2 and PC.
    * 
    * A host authentication is required to:
    * • Load or update keys into the MIFARE SAM AV2
    * • Activate the MIFARE SAM AV2 after reset (if configured accordingly in the configuration settings of master key key_no 00h)
    * The communication in this process is plain, so key will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param host_aes_key pointer to array containing 16 bytes AES key
    * @param key_nr key reference number (0 - 127)
    * @param key_version key version (0 - 255)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_authenticate_host_AV2_plain(IN uint8_t *host_aes_key, uint8_t key_nr, uint8_t key_version, OUT uint8_t *apdu_sw);

    /**
    * @brief Function allows changing KST containing two Crypto 1 keys (KeyA and KeyB) for authentication to Mifare Classic or Mifare Plus card in SL1 mode.
    * 
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_entry_no key reference number (1 - 127)
    * @param keyA pointer to array containing 6 bytes Crypto 1 key A
    * @param keyB pointer to array containing 6 bytes Crypto 1 key B
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_mifare_AV2_plain_one_key(uint8_t key_entry_no, IN uint8_t *keyA, IN uint8_t *keyB,
                                                                    uint8_t key_no_CEK, uint8_t key_v_CEK, uint8_t ref_no_KUC,
                                                                    OUT uint8_t *apdu_sw);

    /**
    * @brief Function allows changing KST containing AES key for authentication to Mifare Desfire or Mifare Plus card in SL3 mode.
    * 
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_entry_no key reference number (1 - 127)
    * @param key pointer to array containing 16 bytes of AES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_AES_AV2_plain_one_key(uint8_t key_entry_no, IN uint8_t *key, uint8_t key_no_CEK, uint8_t key_v_CEK,
                                                                 uint8_t ref_no_KUC, OUT uint8_t *apdu_sw);

    /**
    * @brief Function allows changing KST containing 3K3DES key for authentication to Mifare Desfire card.
    * 
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_entry_no key reference number (1 - 127)
    * @param key pointer to array containing 24 bytes of 3K3DES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_3K3DES_AV2_plain_one_key(uint8_t key_entry_no, IN uint8_t *key, uint8_t key_no_CEK,
                                                                    uint8_t key_v_CEK, uint8_t ref_no_KUC, OUT uint8_t *apdu_sw);

    /**
    * @brief Function allows changing KST containing 2K3DES key for authentication to Ultralight C card.
    * 
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_entry_no key reference number (1 - 127)
    * @param key pointer to array containing 16 bytes of 2K3DES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_2K3DES_ULC_AV2_plain_one_key(uint8_t key_entry_no, IN uint8_t *key, uint8_t key_no_CEK,
                                                                        uint8_t key_v_CEK, uint8_t ref_no_KUC, OUT uint8_t *apdu_sw);

    /**
    * @brief Function allows changing KST containing 2K3DES key for authentication to Mifare Desfire card.
    * 
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_entry_no key reference number (1 - 127)
    * @param key pointer to array containing 16 bytes of 2K3DES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_2K3DES_desfire_AV2_plain_one_key(uint8_t key_entry_no, IN uint8_t *key, uint8_t key_no_CEK,
                                                                            uint8_t key_v_CEK, uint8_t ref_no_KUC, OUT uint8_t *apdu_sw);

    /**
    * @brief Function allows changing KST containing DES key for authentication to Mifare Desfire card.
    * 
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_entry_no key reference number (1 - 127)
    * @param key pointer to array containing 8 bytes of DES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_DES_AV2_plain_one_key(uint8_t key_entry_no, IN uint8_t *key, uint8_t key_no_CEK, uint8_t key_v_CEK,
                                                                 uint8_t ref_no_KUC, OUT uint8_t *apdu_sw);

    /**
    * @brief Function allows changing KST (Key Storage Table) containing 3 AES-128 keys, and their versions.
    * 
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_entry_no key reference number (0 - 127)
    * @param aes_key_ver_a pointer to array containing 16 bytes of first  AES key
    * @param ver_a key version of first key (0 - 255)
    * @param aes_key_ver_b pointer to array containing 16 bytes of second AES key
    * @param ver_b key version of second key (0 - 255)
    * @param aes_key_ver_c pointer to array containing 16 bytes of third AES key
    * @param ver_c key version of third key (0 - 255)
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param sam_lock_unlock SAM lock/unlock ability. If key_entry_no = 0 (master key), then the SAM will be locked after power up or reset, and minimal set of commands will be available.
    * @param sam_auth_host Host authentication ability. If key_entry_no = 0 (master key), then the authentication with host key is mandatory after power up or reset, in opposition minimal set of commands will be available.
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_aes_AV2_plain_host_key(uint8_t key_entry_no, IN uint8_t *aes_key_ver_a, uint8_t ver_a,
                                                                  IN uint8_t *aes_key_ver_b, uint8_t ver_b, IN uint8_t *aes_key_ver_c,
                                                                  uint8_t ver_c, uint8_t key_no_CEK, uint8_t key_v_CEK, uint8_t ref_no_KUC,
                                                                  uint8_t sam_lock_unlock, uint8_t sam_auth_host, OUT uint8_t *apdu_sw);

    /**
    * @brief If master key has enabled lock/unlock parameter, then SAM unlock with key with lock/unlock ability is required. uFR reader tries to unlock SAM with key which stored into reader by this function. If internal reader keys locked, then they must be unlocked first, with function ReaderKeysUnlock.
    * 
    * The communication in this process is plain, so key will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM
    *
    * @param key_no key reference number (0 - 127)
    * @param key_ver key version (0 - 255)
    * @param aes_key pointer to array containing 16 bytes of AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteSamUnlockKey(uint8_t key_no, uint8_t key_ver, IN uint8_t *aes_key);

    /**
    * @brief Function tries to change the UID on the card.
    * 
    * On some cards (e.g. Magic Classic) changing UID is possible. If theed card is that type of card, then the function returns UFR_OK.
    * 
    * @ingroup Miscellaneous
    *
    * @return Operation status
    */
    UFR_STATUS DL_API CheckUidChangeable(void);

    /**
    * @brief Function reset RF field at the reader. The RF field will be off, and then on after 50ms.
    * 
    * @ingroup Miscellaneous
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderRfReset(void);

    /**
    * @brief Function switch on RF field at the reader. 
    * 
    * For proper functionality the reader must be in the multi card mode.
    * From library version 5.0.48, and firmware version 5.0.51.
    * 
    * @ingroup Miscellaneous
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderRfOn(void);

    /**
    * @brief Function switch off RF field at the reader. 
    * 
    * For proper functionality the reader must be in the multi card mode. The RF field can be switched on by functions ReaderRfOn, EnumCards, or  DisableAnticolision.
    * From library version 5.0.48, and firmware version 5.0.51.
    * 
    * @ingroup Miscellaneous
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderRfOff(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API WriteReaderId(IN uint8_t *reader_id);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API ProgReader(IN uint8_t *data, uint16_t packet_nr, uint8_t init_cmd, VAR uint8_t *crc_ok);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API ProgReaderUsb(IN uint8_t *data, uint16_t packet_nr, uint8_t init_cmd, VAR uint8_t *crc_ok);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API ProgReaderStreamUsb(IN uint8_t *data, uint16_t packet_nr);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API BootReader(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_CodeProtect(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_WriteParams(IN uint8_t *aes_key, IN uint8_t *serial_nr, uint8_t hw_type, uint8_t hw_ver, IN uint8_t *dev_type, uint8_t production);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_WriteParamsUsb(IN uint8_t *aes_key, IN uint8_t *serial_nr, uint8_t hw_type, uint8_t hw_ver, IN uint8_t *dev_type, uint8_t production);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_Test(uint8_t param);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_LpcdCalibration(uint8_t lpcd_threshold, OUT uint16_t *lpcd_reference);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_LpcdPerform(uint8_t lpcd_threshold, uint16_t lpcd_reference, VAR uint16_t *lpcd_agc, VAR uint8_t *lpcd_status);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_RfOff(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_RfOn(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_ExtField(void);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API PN7462_ESP32_boot_init(IN uint8_t *reader_cnt, uint8_t reader_nr);

    // MIFARE PLUS
    /**
    * @brief Security level 0 command.
    * Function is used to change the data and AES keys from the initial delivery configuration to a customer specific value.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param address Number of block or key
    * @param data Value of data or AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_WritePerso(uint16_t address, IN uint8_t *data);

    /**
    * @brief Security level 0 command.
    * Function is used to finalize the personalization and switch up to security level 1.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_CommitPerso(void);

    /**
    * @brief Security level 0 command.
    * Function is used for card personalization. The minimum number of AES keys is entered into the card. There are card master key, card configuration key, key for switch to security level 2, key for switch to security level 3, security level 1 authentication key, virtual card select key, proximity check key, VC polling ENC and VC poling MAC key. Keys can not be changed at security level 1.
    * Other keys that are not personalized will have value 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF)
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param card_master_key card_master_key
    * @param card_config_key card_config_key
    * @param level_2_switch_key level_2_switch_key
    * @param level_3_switch_key level_3_switch_key
    * @param level_1_auth_key level_1_auth_key
    * @param select_vc_key select_vc_key
    * @param prox_chk_key prox_chk_key
    * @param vc_poll_enc_key vc_poll_enc_key
    * @param vc_poll_mac_key vc_poll_mac_key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_PersonalizationMinimal(IN uint8_t *card_master_key, IN uint8_t *card_config_key, IN uint8_t *level_2_switch_key,
                                                 IN uint8_t *level_3_switch_key, IN uint8_t *level_1_auth_key, IN uint8_t *select_vc_key,
                                                 IN uint8_t *prox_chk_key, IN uint8_t *vc_poll_enc_key, IN uint8_t *vc_poll_mac_key);

    /**
    * @brief Security level 1 or 2 command.
    * Function is used to switch to security level 3.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index ordinary number of AES key stored into reader (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_SwitchToSecurityLevel3(uint8_t key_index);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 1 or 2 command.
    * Function is used to switch to security level 3.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param aes_key pointer to 16 byte array containing the AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_SwitchToSecurityLevel3_PK(IN uint8_t *aes_key);

    /**
    * @brief Security level 1 command.
    * Security level 1 offers the same functionality as a MIFARE Classic card.
    * Function is used to optional AES authentication.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index ordinary number of AES key stored into reader (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_AesAuthSecurityLevel1(uint8_t key_index);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 1 command.
    * Security level 1 offers the same functionality as a MIFARE Classic card.
    * Function is used to optional AES authentication.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param aes_key pointer to 16 byte array containing the AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_AesAuthSecurityLevel1_PK(IN uint8_t *aes_key);

    /**
    * @brief Security level 3 command.
    * The function is used to change the AES card master key value.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index ordinary number of current master key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key pointer to 16 byte array containing the new master key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeMasterKey(uint8_t key_index, IN uint8_t *new_key);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES card master key value.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param old_key pointer to 16 byte array containing the current master key *new key pointer to 16 byte array containing the new master key
    * @param new_key pointer to 16 byte array containing the new master key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeMasterKey_PK(IN uint8_t *old_key, IN uint8_t *new_key);

    /**
    * @brief *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES card master key value.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index ordinary number of current master key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key_index key index from which the new master key will be set (0 - 15) or in SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeMasterKeySamKey(uint8_t key_index, uint8_t new_key_index);

    /**
    * @brief Security level 3 command.
    * The function is used to change the AES card configuration key value.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index ordinary number of current configuration key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key pointer to 16 byte array containing the new configuration key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeConfigurationKey(uint8_t key_index, IN uint8_t *new_key);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES card configuration key value.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param old_key pointer to 16 byte array containing the current configuration key
    * @param new_key pointer to 16 byte array containing the new configuration key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeConfigurationKey_PK(IN uint8_t *old_key, IN uint8_t *new_key);

    /**
    * @brief *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES card configuration key value.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index ordinary number of current configuration key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key_index key index from which the new configuration key will be set (0 - 15) or in SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeConfigurationKeySamKey(uint8_t key_index, uint8_t new_key_index);

    /**
    * @brief Security level 3 command.
    * Function is used for definition of using Random ID and Proximity check options. Authentication with AES card configuration key required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key_index ordinary number of configuration key stored into reader (0 - 15) *configuration_key pointer to 16 byte array containing the configuration key
    * @param rid_use 1 - Randnom ID enabled, 0 - Random ID disabled
    * @param prox_check_use 1- Proximity check is mandatory, 0 - Proximity check is not mandatory
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_FieldConfigurationSet(uint8_t configuration_key_index, uint8_t rid_use, uint8_t prox_check_use);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 3 command.
    * Function is used for definition of using Random ID and Proximity check options. Authentication with AES card configuration key required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key pointer to 16 byte array containing the configuration key
    * @param rid_use 1 - Randnom ID enabled, 0 - Random ID disabled
    * @param prox_check_use 1- Proximity check is mandatory, 0 - Proximity check is not mandatory
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_FieldConfigurationSet_PK(IN uint8_t *configuration_key, uint8_t rid_use, uint8_t prox_check_use);

    /**
    * @brief *only uFR CS with SAM support
    * Security level 3 command.
    * Function is used for definition of using Random ID and Proximity check options. Authentication with AES card configuration key required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key_index ordinary number of configuration key stored into reader (0 - 15)
    * @param rid_use 1 - Randnom ID enabled, 0 - Random ID disabled
    * @param prox_check_use 1- Proximity check is mandatory, 0 - Proximity check is not mandatory
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_FieldConfigurationSetSamKey(uint8_t configuration_key_index, uint8_t rid_use, uint8_t prox_check_use);

    /**
    * @brief Security level 3 command.
    * In order to access the block in sector data, AES authentication is needed. Each sector has two AES keys that can be used for authentication (Key A and Key B).
    * Default value if key is not personalized is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF).
    * For linear read part of card, enter the same value of sector keys for all sectors which will be read at once.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card.
    * @param auth_mode MIFARE_AUTHENT1A for Key A  or MIFARE_AUTHENT1B for Key B auth_mode_pk MIFARE_PLUS_AES_AUTHENT1A for Key A  or MIFARE_PLUS_AES_AUTHENT1B for Key B
    * @param key_index ordinary number of current sector key stored into reader (0 - 15)
    * @param new_key pointer to 16 byte array containing the new sector key (A or B)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKey(uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index, IN uint8_t *new_key);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 3 command.
    * In order to access the block in sector data, AES authentication is needed. Each sector has two AES keys that can be used for authentication (Key A and Key B).
    * Default value if key is not personalized is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF).
    * For linear read part of card, enter the same value of sector keys for all sectors which will be read at once.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card.
    * @param auth_mode MIFARE_AUTHENT1A for Key A  or MIFARE_AUTHENT1B for Kye B auth_mode_pk MIFARE_PLUS_AES_AUTHENT1A for Key A  or MIFARE_PLUS_AES_AUTHENT1B for Key B
    * @param old_key pointer to 16 byte array containing the current sector key (A or B)
    * @param new_key pointer to 16 byte array containing the new sector key (A or B)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKey_PK(uint8_t sector_nr, uint8_t auth_mode, IN uint8_t *old_key, IN uint8_t *new_key);

    /**
    * @brief *only uFR CS with SAM support
    * Security level 3 command.
    * In order to access the block in sector data, AES authentication is needed. Each sector has two AES keys that can be used for authentication (Key A and Key B).
    * Default value if key is not personalized is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF).
    * For linear read part of card, enter the same value of sector keys for all sectors which will be read at once.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card.
    * @param auth_mode MIFARE_AUTHENT1A for Key A  or MIFARE_AUTHENT1B for Kye B auth_mode_pk MIFARE_PLUS_AES_AUTHENT1A for Key A  or MIFARE_PLUS_AES_AUTHENT1B for Key B
    * @param key_index ordinary number of current sector key stored into reader (0 - 15)
    * @param new_key_index pointer to 16 byte array containing the new sector key (A or B)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKeySamKey(uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index, uint8_t new_key_index);

    /**
    *
    * @ingroup Card_Tag_Mifare_Plus
    * @ingroup UNDOCUMENTED
    *
    * @param sector_nr sector_nr
    * @param auth_mode auth_mode
    * @param key_index key_index
    * @param new_key new_key
    * @param new_key_type new_key_type
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorExtKey(uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index, IN uint8_t *new_key, uint8_t new_key_type);

    /**
    *
    * @ingroup Card_Tag_Mifare_Plus
    * @ingroup UNDOCUMENTED
    *
    * @param sector_nr sector_nr
    * @param auth_mode auth_mode
    * @param key_index key_index
    * @param new_key_index new_key_index
    * @param new_key_type new_key_type
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKeySamExtKey(uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index, uint8_t new_key_index, uint8_t new_key_type);

    /**
    * @brief
    * ADD DESCRIPTION
    * @ingroup Card_Tag_Mifare_Plus
    * @ingroup UNDOCUMENTED
    *
    * @param sector_nr sector_nr
    * @param auth_mode auth_mode
    * @param old_key old_key
    * @param new_key new_key
    * @param new_key_type new_key_type
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKeyExt_PK(uint8_t sector_nr, uint8_t auth_mode, IN uint8_t *old_key, IN uint8_t *new_key, uint8_t new_key_type);

    /**
    * @brief Security level 3 command.
    * Function is used to read UID if Random ID is enabled. Authentication with AES VC Polling ENC Key and VC Polling MAC Key is mandatory.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index_vc_poll_enc_key ordinary number of VC polling ENC key stored into reader (0 - 15)
    * @param key_index_vc_poll_mac_key ordinary number of VC polling MAC key stored into reader (0 - 15)
    * @param uid pointer to byte array containing the card UID
    * @param uid_len pointer to UID length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_GetUid(uint8_t key_index_vc_poll_enc_key, uint8_t key_index_vc_poll_mac_key, OUT uint8_t *uid, VAR uint8_t *uid_len);

    /**
    * @brief *only uFR CS with SAM support
    * Security level 3 command.
    * Function is used to read UID if Random ID is enabled. Authentication with AES VC Polling ENC Key and VC Polling MAC Key is mandatory.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key_index_vc_poll_enc_key ordinary number of VC polling ENC key stored into reader (0 - 15)
    * @param key_index_vc_poll_mac_key ordinary number of VC polling MAC key stored into reader (0 - 15)
    * @param uid pointer to byte array containing the card UID
    * @param uid_len pointer to UID length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_GetUidSamKey(uint8_t key_index_vc_poll_enc_key, uint8_t key_index_vc_poll_mac_key, OUT uint8_t *uid,
                                       VAR uint8_t *uid_len);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 3 command.
    * Function is used to read UID if Random ID is enabled. Authentication with AES VC Polling ENC Key and VC Polling MAC Key is mandatory.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param vc_poll_enc_key pointer to 16 byte array containing VC polling ENC key
    * @param vc_poll_mac_key pointer to 16 byte array containing VC polling MAC key
    * @param uid pointer to byte array containing the card UID
    * @param uid_len pointer to UID length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_GetUid_PK(IN uint8_t *vc_poll_enc_key, IN uint8_t *vc_poll_mac_key, OUT uint8_t *uid, VAR uint8_t *uid_len);

    /**
    * @brief Security level 3 command.
    * The function is used to change the AES VC polling ENC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key_index ordinary number of card configuration key stored into reader (0 - 15)
    * @param new_key pointer to 16 byte array containing new VC Polling ENC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingEncKey(uint8_t configuration_key_index, IN uint8_t *new_key);

    /**
    * @brief *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES VC polling ENC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key_index ordinary number of card configuration key stored into reader (0 - 15)
    * @param new_key_index pointer to 16 byte array containing new VC Polling ENC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingEncKeySamKey(uint8_t configuration_key_index, uint8_t new_key_index);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES VC polling ENC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key pointer to 16 byte array containing card configuration key
    * @param new_key pointer to 16 byte array containing new VC Polling ENC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingEncKey_PK(IN uint8_t *configuration_key, IN uint8_t *new_key);

    /**
    * @brief Security level 3 command.
    * The function is used to change the AES VC polling MAC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key_index pointer to 16 byte array containing card configuration key
    * @param new_key pointer to 16 byte array containing new VC Polling MAC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingMacKey(uint8_t configuration_key_index, IN uint8_t *new_key);

    /**
    * @brief *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES VC polling MAC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key_index pointer to 16 byte array containing card configuration key
    * @param new_key_index pointer to 16 byte array containing new VC Polling MAC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingMacKeySamKey(uint8_t configuration_key_index, uint8_t new_key_index);

    /**
    * @brief
    * Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES VC polling MAC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param configuration_key pointer to 16 byte array containing card configuration key
    * @param new_key pointer to 16 byte array containing new VC Polling MAC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingMacKey_PK(IN uint8_t *configuration_key, IN uint8_t *new_key);

    // ULTRALIGHT C
    /**
    * @brief
    * Provided Key mode (PK)
    * The 3DES authentication is executed using the transceive mode of reader. Pointer to array which contains 2K 3DES key (16 bytes ) is parameter of this functions. Function don’t use the key which stored into reader. DES algorithm for authentication executes in host device, not in reader.
    * After authentication, the reader leaves the transceive mode, but stay in mode where the HALT command doesn’t sending to the card. In this mode user can use functions for block and linear reading or writing. Reader stay into this mode, until the error during reading data from card,  or writing data into card occurs, or until the user calls function card_halt_enable().
    *
    * @ingroup Card_Tag_Mifare_Plus
    *
    * @param key pointer to data array of 16 bytes which contains 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_ExternalAuth_PK(IN uint8_t *key);

    /**
    * @brief No authentication. Write key into the card.
    *
    * @ingroup Card_Tag_Ultralight_C
    *
    * @param new_3des_key pointer to array of 16 bytes which contains new 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_write_3des_key_no_auth(IN uint8_t *new_3des_key);

    /**
    * @brief Write key into the card.
    *
    * @ingroup Card_Tag_Ultralight_C
    *
    * @param new_3des_key pointer to array of 16 bytes which contains new 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_write_3des_key_factory_key(IN uint8_t *new_3des_key);

    /**
    * @brief Write key into the card.
    *
    * @ingroup Card_Tag_Ultralight_C
    *
    * @param new_3des_key pointer to array of 16 bytes which contains new 2K 3DES key
    * @param old_3des_key pointer to array of 16 bytes which contains current 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_write_3des_key(IN uint8_t *new_3des_key, IN uint8_t *old_3des_key);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API BalanceGet(uint32_t auth_mode, IN void *auth_value, VAR int32_t *credit);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API BalanceSet(uint32_t auth_mode, IN void *auth_value, int32_t credit);

    /**
    * @brief This function sets communication speed (UART baud rate). 
    * 
    * Allowed values of baud rate are: 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, and 1000000 bps. All RS232 devices are supported, and USB devices (Nano FR, Classic) from firmware version 5.0.31.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @param baud_rate UART baud rate
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetUartSpeed(uint32_t baud_rate);

    /**
    * @brief This function returns communication speed (UART baud rate) to default value. 
    * 
    * For RS23 devices default communication speed is 115200 bps, and for USB devices is 1000000 bps.
    * For RS232 devices from version 5.0.1 (plus devices), and for USB devices from version 5.0.31.
    *
    * @ingroup ReaderAndLibrary_Communication
    *
    * @param reader_type 1 - USB 2 - RS232
    * @param comm_type 1 - COM port 2 - FTDI
    * @param port_name If comm_type is FTDI enter empty string If comm_type is COM port Windows “COMx” Linux “/dev/ttyUSBx” Mac OS “/dev/tty.usbserial-xxxxxxxx”
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetDefaultUartSpeed(uint8_t reader_type, uint8_t comm_type, IN c_string port_name);

    // NT4H
    /**
    * @brief Function sets file number, key number, and communication mode, before the using functions for reading and writing data into cards  which are used for NTAG 2xx cards. 
    * 
    * This makes it possible to use existing functions for the block and linear reading and writing.
    *
    * @ingroup Card_Tag_NT4H
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 and NTAG 424 TT - 1 to 3
    * @param key_no NTAG 413 - 0 to 2 NTAG 424 and NTAG 424 TT - 0 to 4
    * @param communication_mode  0 - plain, 1 - MACed, 3 - enciphered
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_set_global_parameters(uint8_t file_no, uint8_t key_no, uint8_t communication_mode);

    /**
    * @brief Provided Key mode (PK) The function changes the access parameters of an existing standard data file. 
    * 
    * The communication mode can be either plain or enciphered based on current access rights of the file, so current communication mode must be entered. Access rights are similar for Desfire cards.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_ext pointer to array contained AES key aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 and NTAG 424 TT - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 and NTAG 424 TT - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no reading key number
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_standard_file_settings_pk(IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                            uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief The function changes the access parameters of an existing standard data file. 
    * 
    * The communication mode can be either plain or enciphered based on current access rights of the file, so current communication mode must be entered. Access rights are similar for Desfire cards.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 and NTAG 424 TT - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 and NTAG 424 TT - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no reading key number
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_standard_file_settings(uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                         uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief Provided Key mode (PK)
    * Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file. 
    * 
    * Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_ext pointer to array contained AES key aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG 424 only)  0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC read_crt_limit value of SDM reading counter limit
    * @param read_ctr_limit value of SDM reading counter limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_sdm_file_settings_pk(IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                       uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                       uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                       uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                       uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                       uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit);

    /**
    * @brief Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file. 
    * 
    * Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG 424 only)  0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC read_crt_limit value of SDM reading counter limit
    * @param read_ctr_limit read_ctr_limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_sdm_file_settings(uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                    uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                    uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                    uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                    uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                    uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit);

    /**
    * @brief Function returns file settings.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param file_no NTAG 413 - 1 or 2, NTAG 424 - 1 to 3
    * @param file_type 0 - standard data file
    * @param communication_mode communication mode, 0 - plain, 1 - MACed, 3 - enciphered
    * @param sdm_enable 0 - SDM disabled, 1 - SDM enabled
    * @param file_size file size in bytes
    * @param read_key_no reading key number
    * @param write_key_no  writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG424 only) 0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_file_settings(uint8_t file_no, VAR uint8_t *file_type, VAR uint8_t *communication_mode, VAR uint8_t *sdm_enable, VAR uint32_t *file_size,
                                             VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                             VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                             VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                             VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                             VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit);

    /**
    * @brief Provided Key mode (PK) Function enables card Random ID. 
    * 
    * Authentication with application master key (key number 0) required.
    * Warning. This operation is ireversibile.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_ext pointer to array contained AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_set_rid_pk(IN uint8_t *aes_key_ext);
    UFR_STATUS DL_API nt4h_unset_rid_pk(IN uint8_t *aes_key_ext);

    /**
    * @brief Function enables card Random ID. Authentication with application master key (key number 0) required.
    * 
    * Warning. This operation is ireversibile.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_set_rid(uint8_t aes_key_no);

    /**
    * @brief Provided Key mode (PK) Function returns card UID if Random ID activated. 
    * 
    * Valid authentication is required.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key pointer to array contained AES key
    * @param key_no ordinal number of AES key into reader (0 - 15)
    * @param uid pointer to array contained UID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_uid_pk(IN uint8_t *auth_key, uint8_t key_no, OUT uint8_t *uid);

    /**
    * @brief Function returns card UID if Random ID activated. Valid authentication is required.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key_no ordinal number of AES key into reader (0 - 15)
    * @param key_no ordinal number of AES key into reader (0 - 15)
    * @param uid pointer to array contained UID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_uid(uint8_t auth_key_no, uint8_t key_no, OUT uint8_t *uid);

    /**
    * @brief Provided Key mode (PK) Function changes AES key. 
    * 
    * Authentication with the application master key is required.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key pointer to array contained AES key
    * @param key_no key number 0 - 2 or 0 - 4
    * @param new_key pointer to array contained new AES key
    * @param old_key pointer to array contained current AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_key_pk(IN uint8_t *auth_key, uint8_t key_no, IN uint8_t *new_key, IN uint8_t *old_key);

    /**
    * @brief Function changes AES key. 
    * 
    * Authentication with the application master key is required.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key_no ordinal number of AES key into reader (0 - 15)
    * @param key_no key number 0 - 2 or 0 - 4
    * @param new_key pointer to array contained new AES key
    * @param old_key pointer to array contained current AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_key(uint8_t auth_key_no, uint8_t key_no, IN uint8_t *new_key, IN uint8_t *old_key);

    /**
    * @brief Provided Key mode (PK) Function supports retrieving of the current values of SDM reading counter.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key pointer to array contained AES key
    * @param file_no file number of SDM file (2)
    * @param key_no key number 0 - 2 or 0 - 4
    * @param sdm_read_ctr pointer to value of SDM reading counter
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_sdm_ctr_pk(IN uint8_t *auth_key, uint8_t file_no, uint8_t key_no, VAR uint32_t *sdm_read_ctr);

    /**
    * @brief Function supports retrieving of the current values of SDM reading counter.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no file number of SDM file (2)
    * @param key_no key number 0 - 2 or 0 - 4
    * @param sdm_read_ctr pointer to value of SDM reading counter
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_sdm_ctr(uint8_t auth_key_no, uint8_t file_no, uint8_t key_no, VAR uint32_t *sdm_read_ctr);

    /**
    * @brief No authentication. Function supports retrieving of the current values of SDM reading counter.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param file_no file number of SDM file (2)
    * @param sdm_read_ctr pointer to value of SDM reading counter
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_sdm_ctr_no_auth(uint8_t file_no, VAR uint32_t *sdm_read_ctr);

    /**
    * @brief Helper function for the MAC of SDM checking. 
    * 
    * Users need to know the SDM counter, UID and AES key for file data read.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param smd_read_counter value of SDM reading counter
    * @param uid pointer to array contained 7 bytes UID
    * @param auth_key pointer to array contained AES meta data read key
    * @param mac_in_data data from mac_input_offset to mac_offset
    * @param mac_in_len mac_input_offset - mac_offset
    * @param sdm_mac pointer to array contained 8 bytes SDM MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_check_sdm_mac(uint32_t smd_read_counter, IN uint8_t *uid, IN uint8_t *auth_key, IN uint8_t *mac_in_data, IN uint8_t mac_in_len, IN uint8_t *sdm_mac);

    /**
    * @brief Helper function for decryption of encrypted file data. 
    * 
    * Users need to know the SDM counter, UID and AES key for file data read.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param smd_read_counter value of SDM reading counter
    * @param uid pointer to array contained 7 bytes UID
    * @param auth_key pointer to array contained AES meta data read key
    * @param enc_file_data pointer to array contained encrypted part of file data
    * @param enc_file_data_len length of encrypted part of file data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_decrypt_sdm_enc_file_data(uint32_t smd_read_counter, IN uint8_t *uid, IN uint8_t *auth_key, IN uint8_t *enc_file_data, IN uint8_t enc_file_data_len);

    /**
    * @brief Helper function for decryption of encrypted PICC data.
    * 
    * Function returns UID and SDM reading counter. Users need to know the AES key for metadata read (PICC data).
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param picc_data pointer to array contained encrypted PICC data
    * @param auth_key pointer to array contained AES meta data read key
    * @param picc_data_tag if bit 7 set exist UID mirroring if bit 6 set exist SDM reading counter
    * @param uid pointer to array contained 7 bytes UID
    * @param smd_read_cnt pointer to value of SDM reading counter
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_decrypt_picc_data(IN uint8_t *picc_data, IN uint8_t *auth_key, IN uint8_t *picc_data_tag, IN uint8_t *uid, IN uint32_t *smd_read_cnt);

    /**
    * Provided Key mode (PK)
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * @brief Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file. 
    * 
    * Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_ext pointer to array contained AES key aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no 1 - 3
    * @param key_no current change key number 0 - 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param tt_status_enable tag tamper status mirroring (0 - disabled, 1 - enabled)
    * @param tt_status_offset mirror position of tag tamper status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_tt_change_sdm_file_settings_pk(IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                          uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                          uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                          uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                          uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                          uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                          uint8_t tt_status_enable, uint32_t tt_status_offset);

    /**
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * @brief Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file.
    * 
    * Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no 1 - 3
    * @param key_no current change key number 0 - 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param tt_status_enable tag tamper status mirroring (0 - disabled, 1 - enabled)
    * @param tt_status_offset mirror position of tag tamper status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_tt_change_sdm_file_settings(uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                       uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                       uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                       uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                       uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                       uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                       uint8_t tt_status_enable, uint32_t tt_status_offset);

    /**
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * @brief Function returns file settings.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param file_no 413 - 1 or 2; NTAG 424 - 1 to 3
    * @param file_type 0 - standard data file
    * @param communication_mode communication mode, 0 - plain, 1 - MACed, 3 - enciphered
    * @param sdm_enable 0 - SDM disabled, 1 - SDM enabled
    * @param file_size file size in bytes
    * @param read_key_no reading key number
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG424 only) 0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param tt_status_enable tag tamper status (0 - disabled, 1 - enabled)
    * @param tt_status_offset mirror position of tag tamper status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_tt_get_file_settings(uint8_t file_no, VAR uint8_t *file_type, VAR uint8_t *communication_mode, VAR uint8_t *sdm_enable, VAR uint32_t *file_size,
                                                VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                VAR uint8_t *tt_status_enable, VAR uint32_t *tt_status_offset);

    /**
    * @brief Provided Key mode (PK)
    * From library version 5.0.43 and firmware version 5.0.43.
    * Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA) when the Random ID is activated. Authentication with valid key required.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key pointer to array contained AES key auth_key_nr ordinal number of AES key into reader (0 - 15)
    * @param key_no 0 - 4
    * @param uid 7 bytes UID length
    * @param ecc_signature 56 bytes ECC signature
    * @param dlogic_card_type card type value based on DLogic CardType enumeration
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_rid_read_ecc_signature_pk(IN uint8_t *auth_key, uint8_t key_no, OUT uint8_t *uid,
                                                     OUT uint8_t *ecc_signature, VAR uint8_t *dlogic_card_type);

    /**
    * @brief From library version 5.0.43 and firmware version 5.0.43.
    * Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA) when the Random ID is activated. Authentication with valid key required.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param auth_key_nr ordinal number of AES key into reader (0 - 15)
    * @param key_no 0 - 4
    * @param uid 7 bytes UID length
    * @param ecc_signature 56 bytes ECC signature
    * @param dlogic_card_type card type value based on DLogic CardType enumeration
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_rid_read_ecc_signature(uint8_t auth_key_nr, uint8_t key_no, OUT uint8_t *uid,
                                                  OUT uint8_t *ecc_signature, OUT uint8_t *dlogic_card_type);

    /**
    * @brief Provided Key mode (PK)
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function supports retrieving of the permanent and current Tag Tamper Status.
    *
    * @param aes_key_ext pointer to array contained AES key
    * @param key_no 0 - 4 *uid 7 bytes UID length *ecc_signature 56 bytes ECC signature *dlogic_card_type
    * @param tt_perm_status  tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    * @param tt_curr_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_tt_status_pk(IN uint8_t *aes_key_ext, uint8_t key_no, VAR uint8_t *tt_perm_status, VAR uint8_t *tt_curr_status);

    /**
    * @brief NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function supports retrieving of the permanent and current Tag Tamper Status.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param key_no 0 - 4 *uid 7 bytes UID length *ecc_signature 56 bytes ECC signature *dlogic_card_type
    * @param tt_perm_status tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    * @param tt_curr_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_tt_status(uint8_t aes_key_no, uint8_t key_no, VAR uint8_t *tt_perm_status, VAR uint8_t *tt_curr_status);

    /**
    * @brief No authentication
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function supports retrieving of the permanent and current Tag Tamper Status.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param tt_perm_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    * @param tt_curr_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_tt_status_no_auth(VAR uint8_t *tt_perm_status, VAR uint8_t *tt_curr_status);

    /**
    * @brief Provided Key mode (PK)
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function enabling tag tamper feature. Authentication with application master key (key number 0) required.
    * Warning. Enabling the Tag Tamper feature is permanent, it cannot be disabled once enabled.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_ext ordinal number of AES key into reader (0 - 15)
    * @param tt_status_key_no 0 - 4, 14 free access
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_enable_tt_pk(IN uint8_t *aes_key_ext, uint8_t tt_status_key_no);

    /**
    * @brief NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function enabling tag tamper feature. Authentication with application master key (key number 0) required.
    * Warning. Enabling the Tag Tamper feature is permanent, it cannot be disabled once enabled.
    *
    * @ingroup Card_Tag_NT4H
    *
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param tt_status_key_no 0 - 4, 14 free access
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_enable_tt(uint8_t aes_key_no, uint8_t tt_status_key_no);

    // Desfire light
    /**
    * @brief From library version 5.0.29 and firmware version 5.0.32. Desfire Light specific command.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param file_no file number 0, 1, 3, 4, 15 or 31
    * @param file_type file type 0 - standard data file, 2 - value file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no read key number (0 - 4)
    * @param write_key_no write key number (0 - 4)
    * @param read_write_key_no read write key number (0 - 4)
    * @param change_key_no change key number (0 - 4)
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param free_get_value value file get value without authentication (0 - disabled, 1 - enabled)
    * @param record_size cyclic record file size of record
    * @param max_number_of_rec cyclic record file maximal number of record
    * @param curr_number_of_rec cyclic record file number of used record
    * @param ex_unauth_operation TMC file exclude unauthorized operation
    * @param tmc_limit_conf TMC file limit configuration
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param tmc_limit TMC file counter limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_get_file_settings(uint8_t file_no, VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                            VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                            VAR uint32_t *file_size,
                                            VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable, VAR uint8_t *free_get_value,
                                            VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                            VAR uint8_t *ex_unauth_operation, VAR uint8_t *tmc_limit_conf, VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version, VAR uint32_t *tmc_limit);

    /**
    * @brief From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function changes file settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param aes_key_ext pointer to array contained AES key aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number 0, 1, 3, 4, 15 or 31 curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered read_key_no read key number (0 - 4) write_key_no write key number (0 - 4) read_write_key_no read write key number (0 - 4) change_key_no change key number (0 - 4)
    * @param key_no  DESCRIPTION
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no read key number (0 - 4)
    * @param write_key_no write key number (0 - 4)
    * @param read_write_key_no read write key number (0 - 4)
    * @param change_key_no change key number (0 - 4)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_change_file_settings_pk(IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                  uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function changes file settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number 0, 1, 3, 4, 15 or 31
    * @param key_no  currnent change key no
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no read key number (0 - 4)
    * @param write_key_no write key number (0 - 4)
    * @param read_write_key_no read write key number (0 - 4)
    * @param change_key_no change key number (0 - 4)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_change_file_settings(uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                               uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief Function changes file settings of the Transaction MAC file.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param aes_key_no aes_key_no
    * @param file_no file_no
    * @param key_no key_no
    * @param curr_communication_mode curr_communication_mode
    * @param new_communication_mode new_communication_mode
    * @param read_key_no read_key_no
    * @param commit_reader_id_key_no commit_reader_id_key_no
    * @param change_key_no change_key_no
    * @param ex_unauth_operation ex_unauth_operation
    * @param tmc_limit_conf tmc_limit_conf
    * @param tmc_limit tmc_limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_change_tmc_file_settings(uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                   uint8_t new_communication_mode, uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
                                                   uint8_t ex_unauth_operation, uint8_t tmc_limit_conf, uint32_t tmc_limit);

    /**
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    * @ingroup UNDOCUMENTED
    *
    * @param aes_key_ext aes_key_ext
    * @param file_no file_no
    * @param key_no key_no
    * @param curr_communication_mode curr_communication_mode
    * @param new_communication_mode new_communication_mode
    * @param read_key_no read_key_no
    * @param commit_reader_id_key_no commit_reader_id_key_no
    * @param change_key_no change_key_no
    * @param ex_unauth_operation ex_unauth_operation
    * @param tmc_limit_conf tmc_limit_conf
    * @param tmc_limit tmc_limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_change_tmc_file_settings_pk(IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                      uint8_t new_communication_mode, uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
                                                      uint8_t ex_unauth_operation, uint8_t tmc_limit_conf, uint32_t tmc_limit);

    /**
    * @brief
    * From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function delete transaction MAC file.
    * NOTE: Transaction MAC file exist by factory default. To use the operations with value file, and cyclic record file, this file must be deleted.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param aes_key_ext pointer to array contained AES key aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_delete_tmc_file_pk(IN uint8_t *aes_key_ext, uint8_t file_no);

    /**
    * @brief From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function delete transaction MAC file.
    * NOTE: Transaction MAC file exist by factory default. To use the operations with value file, and cyclic record file, this file must be deleted.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_delete_tmc_file(uint8_t aes_key_no, uint8_t file_no);

    /**
    * @brief From library version 5.0.37 and firmware version 5.0.38. For Desfire Light, and Desfire EV2.
    * Helper function for check transaction MAC in credit value operation. Function also returns decrypted Previous Reader ID. User must enter file number, value of credit, transaction MAC counter, card UID, transaction MAC key, Reader ID, encrypted Previous Reader ID and transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param file_no file number
    * @param value value of credit
    * @param trans_mac_counter transaction MAC counter uid pointer to 7 bytes array containing card UID trans_mac_key pointer to 16 bytes array containing Transaction MAC key reader_id pointer to 16 bytes array containing Reader ID prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param uid pointer to 7 bytes array containing card UID trans_mac_key pointer to 16 bytes array containing Transaction MAC key reader_id pointer to 16 bytes array containing Reader ID prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param reader_id pointer to 16 bytes array containing Reader ID prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_check_credit_value_transaction_mac(uint8_t file_no, uint32_t value, uint32_t trans_mac_counter, IN uint8_t *uid, IN uint8_t *trans_mac_key,
                                                             IN uint8_t *reader_id, IN uint8_t *prev_enc_reader_id, IN uint8_t *trans_mac_value, OUT uint8_t *prev_reader_id);

    /**
    * @brief From library version 5.0.37 and firmware version 5.0.38. For Desfire Light, and Desfire EV2.
    * Helper function for check transaction MAC in debit value operation. Function also returns decrypted Previous Reader ID. User must enter file number, value of credit, transaction MAC counter, card UID, transaction MAC key, Reader ID, encrypted Previous Reader ID and transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param file_no file number
    * @param value value of debit
    * @param trans_mac_counter transaction MAC counter uid pointer to 7 bytes array containing card UID trans_mac_key pointer to 16 bytes array containing Transaction MAC key reader_id pointer to 16 bytes array containing Reader ID prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param uid pointer to 7 bytes array containing card UID trans_mac_key pointer to 16 bytes array containing Transaction MAC key reader_id pointer to 16 bytes array containing Reader ID prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param reader_id pointer to 16 bytes array containing Reader ID prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing Previous Encrypted Reader ID trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    * @param prev_reader_id pointer to 16 bytes array containing Previous Reader ID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_check_debit_value_transaction_mac(uint8_t file_no, uint32_t value, uint32_t trans_mac_counter, IN uint8_t *uid, IN uint8_t *trans_mac_key,
                                                            IN uint8_t *reader_id, IN uint8_t *prev_enc_reader_id, IN uint8_t *trans_mac_value, OUT uint8_t *prev_reader_id);

    /**
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * From library version 5.0.37 and firmware version 5.0.38. For Desfire Light, and Desfire EV2.
    * Helper function for check transaction MAC in write record operation. Function also returns decrypted Previous Reader ID. User must enter file number, data offset, data length, array of data, transaction MAC counter, card UID, transaction MAC key, Reader ID, encrypted Previous Reader ID and transaction MAC.
    *
    * @param file_no file number
    * @param offset  data offset
    * @param data_len   length of array of data
    * @param data pointer to data array
    * @param trans_mac_counter   transaction MAC counter
    * @param uid  pointer to 7 bytes array containing card UID
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param reader_id  pointer to 16 bytes array containing Reader ID
    * @param prev_enc_reader_id  pointer to 16 bytes array containing Previous Encrypted Reader ID
    * @param trans_mac_value  pointer to 8 bytes array containing Transaction MAC
    * @param prev_reader_id   pointer to 16 bytes array containing Previous Reader ID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API desfire_check_write_record_transaction_mac(uint8_t file_no, uint32_t offset, uint32_t data_len, IN uint8_t *data, uint32_t trans_mac_counter,
                                                                 IN uint8_t *uid, IN uint8_t *trans_mac_key,
                                                                 IN uint8_t *reader_id, IN uint8_t *prev_enc_reader_id, IN uint8_t *trans_mac_value, OUT uint8_t *prev_reader_id);

    /**
    * @brief From library version 5.0.37 and firmware version 5.0.38. For Desfire Light, and Desfire EV2.
    * Helper function for check transaction MAC in write record operation. Function also returns decrypted Previous Reader ID. User must enter file number, data offset, data length, array of data, transaction MAC counter, card UID, transaction MAC key, Reader ID, encrypted Previous Reader ID and transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param file_no file number
    * @param offset  data offset
    * @param data_len   length of array of data
    * @param data    pointer to data array
    * @param trans_mac_counter   transaction MAC counter
    * @param uid  pointer to 7 bytes array containing card UID
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param reader_id  pointer to 16 bytes array containing Reader ID
    * @param prev_enc_reader_id  pointer to 16 bytes array containing Previous Encrypted Reader ID
    * @param trans_mac_value  pointer to 8 bytes array containing Transaction MAC
    * @param prev_reader_id   pointer to 16 bytes array containing Previous Reader ID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_check_write_record_transaction_mac(uint8_t file_no, uint32_t offset, uint32_t data_len, IN uint8_t *data, uint32_t trans_mac_counter,
                                                             IN uint8_t *uid, IN uint8_t *trans_mac_key,
                                                             IN uint8_t *reader_id, IN uint8_t *prev_enc_reader_id, IN uint8_t *trans_mac_value, OUT uint8_t *prev_reader_id);

    /**
    * @brief From library version 5.0.37 and firmware version 5.0.38. For Desfire Light, and Desfire EV2.
    * Helper function for check transaction MAC in clear record operation. Function also returns decrypted Previous Reader ID. Users must enter file number, transaction MAC counter, card UID, transaction MAC key, Reader ID, encrypted Previous Reader ID and transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light
    *
    * @param file_no file number
    * @param trans_mac_counter transaction MAC counter
    * @param uid  pointer to 7 bytes array containing card UID
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param reader_id  pointer to 16 bytes array containing Reader ID
    * @param prev_enc_reader_id  pointer to 16 bytes array containing Previous Encrypted Reader ID
    * @param trans_mac_value  pointer to 8 bytes array containing Transaction MAC
    * @param prev_reader_id   pointer to 16 bytes array containing Previous Reader ID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API desfire_check_clear_record_transaction_mac(uint8_t file_no, uint32_t trans_mac_counter, IN uint8_t *uid, IN uint8_t *trans_mac_key,
                                                                 IN uint8_t *reader_id, IN uint8_t *prev_enc_reader_id, IN uint8_t *trans_mac_value, OUT uint8_t *prev_reader_id);

    // reader
    /**
    * @brief Function returns various reader states. 
    * 
    * From library version 5.0.31 and firmware version 5.0.33
    * The reader states are defined into following structures. This function is useful for checking if the reader is still in emulation mode after calling the TagEmulationStartRam() function.
    * typedef enum E_EMULATION_MODES {
    * TAG_EMU_DISABLED,
    * TAG_EMU_DEDICATED,
    * TAG_EMU_COMBINED,
    * TAG_EMU_AUTO_AD_HOC
    * }emul_modes_t;
    * typedef enum E_EMULATION_STATES
    * {
    * EMULATION_NONE,
    * EMULATION_IDLE,
    * EMULATION_AUTO_COLL,
    * EMULATION_ACTIVE,
    * EMULATION_HALT,
    * EMULATION_POWER_OFF
    * }emul_states_t;
    * typedef enum E_PCD_MGR_STATES
    * {
    * PCD_MGR_NO_RF_GENERATED,
    * PCD_MGR_14443A_POLLING,
    * PCD_MGR_14443A_SELECTED,
    * PCD_MGR_CE_DEDICATED,
    * PCD_MGR_CE_COMBO_START,
    * PCD_MGR_CE_COMBO,
    * PCD_MGR_CE_COMBO_IN_FIELD
    * }pcd_states_t;
    *
    * @ingroup Miscellaneous
    *
    * @param state - normal working mode states are PCD_MGR_NO_RF_GENERATED or PCD_MGR_14443A_POLLING or PCD_MGR_14443A_SELECTED. - NTAG emulation mode state is PCD_MGR_CE_DEDICATED emul_mode - normal working mode state is TAG_EMU_DISABLED - NTAG emulation mode state is TAG_EMU_DEDICATED emul_state state from structure emul_states_t sleep_mode 0 - reader is in normal or emulation mode 1 - reader is in sleep mode
    * @param emul_mode - normal working mode state is TAG_EMU_DISABLED - NTAG emulation mode state is TAG_EMU_DEDICATED emul_state state from structure emul_states_t sleep_mode 0 - reader is in normal or emulation mode 1 - reader is in sleep mode
    * @param emul_state state from structure emul_states_t sleep_mode 0 - reader is in normal or emulation mode 1 - reader is in sleep mode
    * @param sleep_mode 0 - reader is in normal or emulation mode 1 - reader is in sleep mode
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderStatus(VAR pcd_states_t *state, VAR emul_modes_t *emul_mode, VAR emul_states_t *emul_state, VAR uint8_t *sleep_mode);

    // EMV FUNCTIONS

    /**
    * @brief Used for extracting the credit card PAN number. Must provide card’s Payment System Environment (PSE1 or PSE2).
    *
    * @ingroup Card_Tag_CardFeatures_EMV
    *
    * @param df_name Name of Payment System Environment used. Use value “1PAY.SYS.DDF01” for PSE1, or “2PAY.SYS.DDF01” for PSE2
    * @param pan_str Pointer to char array containing credit card PAN.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EMV_GetPAN(IN c_string df_name, OUT char *pan_str);

    /**
    * @brief Used for extracting details about the last transaction stored in a credit card. Must provide card’s Payment System Environment (PSE1 or PSE2).
    *
    * @ingroup Card_Tag_CardFeatures_EMV
    *
    * @param df_name Name of Payment System Environment used. Use value “1PAY.SYS.DDF01” for PSE1, or “2PAY.SYS.DDF01” for PSE2
    * @param last_transaction_info Pointer to char array containing details about the last transaction stored in the card.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EMV_GetLastTransaction(IN c_string df_name, OUT char *last_transaction_info);

    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    // XXX: Support for multiple readers with same DLL
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #################  M U L T I   R E A D E R   S U P P O R T  #################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################
    // #############################################################################

    //--------------------------------------------------------------------------------------------------

    ///---------------------------------------------------------------------
    /**
    * @brief This is the first function in the order for execution for the multi-reader support.
    * The function prepares the list of connected uF-readers to the system and returns the number of list items - number of connected uFR devices.
    * ReaderList_UpdateAndGetCount() scans all communication ports for compatible devices, probes open readers if still connected, if not close and marks their handles for deletion. If some device is disconnected from the system this function should remove its handle.
    * As of uFCoder version 5.0.73, this function probes both FTDI & COM devices and tries to open them.
    * Each call to this method will close previously opened devices by this function, scan, and open everything found.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param NumberOfDevices how many compatible devices are connected to the system
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_UpdateAndGetCount(VAR int32_t *NumberOfDevices);

    /**
    * @brief Used to retrieve information about a reader found & connected via ReaderList_UpdateAndGetCount().
    * This should be executed for each device based on number of devices found, providing valid index.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceIndex index of the device in the readers list
    * @param DeviceHandle assigned Handle
    * @param DeviceSerialNumber device serial number
    * @param DeviceType device type - device identification in AIS database
    * @param DeviceFWver version of firmware
    * @param DeviceCommID device identification number (master)
    * @param DeviceCommSpeed communication speed
    * @param DeviceCommFTDISerial FTDI COM port identification
    * @param DeviceCommFTDIDescription FTDI COM port description
    * @param DeviceIsOpened is Device opened
    * @param DeviceStatus actual device status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_GetInformation( //
        uint32_t DeviceIndex,                    // index of the device to get information from
        VAR UFR_HANDLE *DeviceHandle,            //// assigned Handle
        OUT c_string *DeviceSerialNumber,        //// device serial number
        VAR int *DeviceType,                     //// device type - device identification in AIS database
        OUT c_string *DeviceFWver,               //// version of firmware
        VAR int *DeviceCommID,                   //// device identification number (master)
        VAR int *DeviceCommSpeed,                //// communication speed
        OUT c_string *DeviceCommFTDISerial,      //// FTDI COM port identification
        OUT c_string *DeviceCommFTDIDescription, //// FTDI COM port description
        VAR int *DeviceIsOpened,                 //// is Device opened
        VAR int *DeviceStatus                    //// actual device status
    );

    /**
    * @brief Force handle deletion when you identify that the reader is no longer connected, and want to release the handle immediately. If the handle exists in the list of opened devices, function would try to close communication port and destroy the handle.
    * When uFR reader is disconnected, ReaderList_UpdateAndGetCount() will do that (destroy) automatically in next execution.
    *
    * @param DeviceHandle The handle that will be destroyed
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_Destroy(UFR_HANDLE *DeviceHandle);

    /**
    * @brief This method is used for manual addition of uFR devices to the list. Parameters used are the same as in ReaderOpenEx() method. Use this method if the device was not previously discovered by the ReaderList_UpdateAndGetCount() method.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceHandle the handle that will be assigned for interacting with the specified reader on success.
    * @param reader_type Refer to ReaderOpenEx() for detailed description of this parameter.
    * @param port_name Refer to ReaderOpenEx() for detailed description of this parameter.
    * @param port_interface Refer to ReaderOpenEx() for detailed description of this parameter. arg Refer to ReaderOpenEx() for detailed description of this parameter.
    * @param arg Refer to ReaderOpenEx() for detailed description of this parameter.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_Add(UFR_HANDLE *DeviceHandle, uint32_t reader_type,
                                     c_string port_name, uint32_t port_interface, void *arg);

    /**
    * @brief Tries to re-open the device based on the serial number of the device. This method should be called when you use ReaderCloseM() to close the communication with the reader opened by ReaderList_UpdateAndGetCount().
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param hndUFR handle of the uFR device
    * @param Device_SN Serial number of the device contained as char array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_OpenBySerial(VAR UFR_HANDLE *hndUFR, const char Device_SN[16]);

    // XXX: Obsolete functions - remain for backward compatibility
    /**
    * @brief
    * Gets reader’s reader serial number as a pointer to 4 byte value, based on the index of the device in the list.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceIndex Index of the device
    * @param lpulSerialNumber Contains reader serial number as a 4 byte value (uint32_t)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_GetSerialByIndex(int32_t DeviceIndex, VAR uint32_t *lpulSerialNumber);

    /**
    * @brief Gets reader’s descriptive name as a array of 8 chars, based on the index of the device in the list.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceIndex Index of the device
    * @param pSerialDescription Contains reader serial number as array of 8 chars
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_GetSerialDescriptionByIndex(int32_t DeviceIndex, OUT uint8_t pSerialDescription[8]);

    /**
    * @brief Gets devices reader type based on the index of the device in the list.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceIndex Index of the device
    * @param lpulReaderType Contains reader type as 4 byte value (uint32_t)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_GetTypeByIndex(int32_t DeviceIndex, VAR uint32_t *lpulReaderType);

    /**
    * @brief Gets devices FTDI serial port number based on the index of the device in the list.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceIndex Index of the device
    * @param Device_Serial Contains FTDI serial number as c_string
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_GetFTDISerialByIndex(int32_t DeviceIndex, OUT char **Device_Serial);

    /**
    * @brief Gets devices FTDI description based on the index of the device in the list.
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceIndex Index of the device
    * @param Device_Description FTDI description as c_string
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_GetFTDIDescriptionByIndex(int32_t DeviceIndex, OUT char **Device_Description);

    /**
    * @brief Tries to re-open the device based on the device index. This method should be called when you use ReaderCloseM() to close the communication with the reader opened by ReaderList_UpdateAndGetCount().
    *
    * @ingroup ReaderAndLibrary_ReaderList
    *
    * @param DeviceIndex Index of the device
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderList_OpenByIndex(const int32_t DeviceIndex, VAR UFR_HANDLE *hndUFR);

    //--------------------------------------------------------------------------------------------------

    // open first/next Reader and return handle - better to use ReaderList_OpenByIndex()
    /**
    * @brief Multi reader support. Open reader communication port for all µFR devices. You can also use this function to open communication with µFR Online devices.
    * Using ReaderOpen to open communication with µFR Online devices:
    * If you have only one reader attached to your PC, it will open that reader serial port on 1Mbit/s, or if you have only one reader attached to another power supply (not your PC) it will open that reader based on it’s working mode (TCP or UDP). If you have more than one µFR Online device, ReaderOpen function will open the first one found, for opening another device, use ReaderOpenEx instead.
    *
    * @ingroup ReaderAndLibrary_Communication_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderOpenM(VAR UFR_HANDLE *hndUFR);

#ifdef ESP_PLATFORM
    /**
    * @brief @param hndUFR handle of the uFR device
    * @param port_num
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspReaderOpenM(VAR UFR_HANDLE *hndUFR, uint32_t port_num);
#endif

    /**
    * @brief Multi reader support. Physical reset of reader communication port.
    *
    * @ingroup ReaderAndLibrary_Communication_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderResetM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Close reader communication port.
    *
    * @ingroup ReaderAndLibrary_Communication_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderCloseM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. This function is used to restart the reader by software. It sets all readers parameters to default values and close RF field which resets all the cards in the field.
    *
    * @ingroup ReaderAndLibrary_Communication_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderSoftRestartM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Returns reader type as a pointer to 4 byte value.
    *
    * @ingroup ReaderAndLibrary_Information_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpulReaderType pointer to lpulReaderType variable. “lpulReaderType” as result - please refer to Appendix: DLogic reader type enumeration. E.g. for µFR Nano Classic readers this value is  0xD1180022.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderTypeM(UFR_HANDLE hndUFR, IN uint32_t *lpulReaderType);

    /**
    * @brief Multi reader support. Returns reader serial number as a pointer to 4 byte value.
    *
    * @ingroup ReaderAndLibrary_Information_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpulSerialNumber pointer to lpulSerialNumber variable. “lpulSerialNumber “ as result holds 4 byte serial number value.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderSerialNumberM(UFR_HANDLE hndUFR, IN uint32_t *lpulSerialNumber);

    /**
    * @brief Multi reader support. Retrieve info if reader is still connected to host.
    *
    * @ingroup ReaderAndLibrary_Information_M
    *
    * @param hndUFR handle of the uFR device
    * @param connected pointer to connected variable “connected” as result: > 0 Reader is connected on system = 0 Reader is not connected on system anymore (or closed) < 0 other error “connected” - Pointer to unsigned int type variable 32 bit long, where the information   about readers availability is written. If the reader is connected on system, function store 1 (true) otherwise, on some error, store zero in that variable.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderStillConnectedM(UFR_HANDLE hndUFR, VAR uint32_t *connected);

    /**
    * @brief Multi reader support. Store a new key or change existing key under provided index parameter.The keys are in a special area in EEPROM that can not be read anymore which gains protection.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucKey Pointer to an array of 6 bytes containing the key. Default key values are always “FF FF FF FF FF FF” hex.
    * @param ucKeyIndex key Index. Possible values ​​are 0 to 31.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderKeyWriteM(UFR_HANDLE hndUFR, IN const uint8_t *aucKey, uint8_t ucKeyIndex);

    /**
    * @brief Multi reader support. Lock reader’s keys to prevent further changing.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param password pointer to the 8 bytes array containing valid password.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderKeysLockM(UFR_HANDLE hndUFR, IN const uint8_t *password);

    /**
    * @brief Multi reader support. Unlock reader’s keys if they are locked with previous function.
    * The factory setting is that reader keys are unlocked.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param password pointer to the 8 bytes array containing valid password.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderKeysUnlockM(UFR_HANDLE hndUFR, IN const uint8_t *password);

    /**
    * @brief Multi reader support. This function turns sound and light reader signals. Sound signals are performed by the reader's buzzer and light signals are performed by the reader's LEDs.
    * There are predefined signal values for sound and light:
    *
    * @ingroup ReaderAndLibrary_Signalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param light_signal_mode 0 - None, 1 - Long Green, 2 - Long Red, 3 - Alternation, 4 - Flash
    * @param beep_signal_mode 0 - None, 1 - Short, 2 - Long, 3 - Double Short, 4 - Triple Short, 5 - Triplet Melody
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderUISignalM(UFR_HANDLE hndUFR, uint8_t light_signal_mode, uint8_t beep_signal_mode);

    /**
    * @brief Multi reader support. From version 5.0.68.
    * Function sets the duty cycle ratio of the sound signal. Value is in percent (0 - 100%). Default value is 50%, and this value will be set after the reset of the reader, without using this function.
    *
    * @ingroup ReaderAndLibrary_Signalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param sound_volume volume in percent 0 - 100 %
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderSoundVolumeM(UFR_HANDLE hndUFR, uint8_t sound_volume);

    /**
    * @brief Multi reader support. Read user data written in device NV memory.
    * User data is 16 byte long.
    * From version 5.0.86. function ReadUserDataExt added. When using this function, user data is 32 bytes long.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData pointer to a 16 bytes array containing user data, or 32 bytes for ReadUserDataExt
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadUserDataM(UFR_HANDLE hndUFR, OUT uint8_t *aucData);

    /**
    * @brief Multi reader support. Read user data written in device NV memory.
    * User data is 16 byte long.
    * From version 5.0.86. function ReadUserDataExt added. When using this function, user data is 32 bytes long.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData pointer to a 16 bytes array containing user data, or 32 bytes for ReadUserDataExt
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadUserDataExtM(UFR_HANDLE hndUFR, OUT uint8_t *aucData);

    /**
    * @brief Multi reader support. Write user data into the device's NV memory. User data is 16 byte long.
    * From version 5.0.86. function WriteUserDataExt added. When using this function, user data is 32 bytes long.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData pointer to a 16 byte array containing user data,  or 32 bytes for ReadUserDataExt
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteUserDataM(UFR_HANDLE hndUFR, IN const uint8_t *aucData);

    /**
    * @brief Multi reader support. Write user data into the device's NV memory. User data is 16 byte long.
    * From version 5.0.86. function WriteUserDataExt added. When using this function, user data is 32 bytes long.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData pointer to a 16 byte array containing user data,  or 32 bytes for ReadUserDataExt
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteUserDataExtM(UFR_HANDLE hndUFR, IN const uint8_t *aucData);

    /**
    * @brief Multi reader support. Returns card UID as a 4-byte array. This function is deprecated and used only for backward compatibility with older firmware versions (before v2.0). We strongly discourage use of this function. This function can’t successfully handle 7 byte UIDS.
    *
    * @param hndUFR handle of the uFR device
    * @param lpucCardType returns pointer to variable which holds card type according to SAK lpulCardSerial returns pointer to array of card UID bytes, 4 bytes long ONLY
    * @param lpulCardSerial returns pointer to array of card UID bytes, 4 bytes long ONLY
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCardIdM(UFR_HANDLE hndUFR, VAR uint8_t *lpucCardType, OUT uint32_t *lpulCardSerial);

    /**
    * @brief Function returns ATQA and SAK (ISO 14443-3) of selected card.
    * 
    * Multi reader support. From library version 5.0.36 and firmware version 5.0.37
    *
    * @ingroup Miscellaneous_M
    *
    * @param hndUFR handle of the uFR device
    * @param atqa pointer to variable which contain ATQA sak pointer to variable which contain SAK
    * @param sak pointer to variable which contain SAK
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAtqaSakM(UFR_HANDLE hndUFR, uint16_t *atqa, uint8_t *sak);

    /**
    * @brief Multi reader support. Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.28) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockReadM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.28) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockReadSamKeyM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWriteM(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWriteSamKeyM(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B:use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)

    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorReadM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                         uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorReadSamKeyM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                               uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index  Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWriteM(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                          uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWriteSamKeyM(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t sector_address,
                                                uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @param hndUFR handle of the uFR device
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start reading
    * @param usDataLength Length of data - how many bytes to read
    * @param lpusBytesReturned Pointer to variable holding how many bytes are returned
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authenticationwith key A or key B:use KeyA - MIFARE_AUTHENT1A = 0x60or KeyB - MIFARE_AUTHENT1B = 0x61For NTAG 21x, Ultralight EV1 and other T2T tags supportingPWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead()or LinearRead_PK() functions. Value 0x60 with LinearRead() orLinearRead_PK() functions means “without PWD_AUTH“ and in thatcase you can send for ucReaderKeyIndex or aucProvidedKeyparameters anything you want without influence on the result. ForNTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTHyou can use _AKM1 or _AKM2 function variants only withoutPWD_AUTH in any case of the valid values (0x60 or 0x61) providedfor this parameter.For Mifare Plus tags (PK mode) defines whether to performauthentication with key A or key B:use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearReadM(UFR_HANDLE hndUFR, OUT uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength,
                                  VAR uint16_t *lpusBytesReturned, uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start reading
    * @param usDataLength Length of data - how many bytes to read
    * @param lpusBytesReturned Pointer to variable holding how many bytes are returned
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearReadSamKeyM(UFR_HANDLE hndUFR, OUT uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength,
                                        VAR uint16_t *lpusBytesReturned, uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief Multi reader support. Read Linear data Address Space. On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start reading
    * @param usDataLength Length of data - how many bytes to read
    * @param lpusBytesReturned Pointer to variable holding how many bytes are returned
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowReadM(UFR_HANDLE hndUFR, OUT uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength,
                                  VAR uint16_t *lpusBytesReturned, uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief Multi reader support. These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start writting
    * @param usDataLength Length of data - how many bytes to write
    * @param lpusBytesWritten Pointer to variable holding how many bytes were written
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWriteM(UFR_HANDLE hndUFR, IN const uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength,
                                   VAR uint16_t *lpusBytesWritten, uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucData Pointer to array of bytes containing data
    * @param usLinearAddress Address of byte - where to start writting
    * @param usDataLength Length of data - how many bytes to write
    * @param lpusBytesWritten Pointer to variable holding how many bytes were written
    * @param ucKeyMode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param ucReaderKeyIndex Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWriteSamKeyM(UFR_HANDLE hndUFR, IN const uint8_t *aucData, uint16_t usLinearAddress, uint16_t usDataLength,
                                         VAR uint16_t *lpusBytesWritten, uint8_t ucKeyMode, uint8_t ucReaderKeyIndex);

    /**
    * @brief Multi reader support. This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCardM(UFR_HANDLE hndUFR, IN const uint8_t *new_key_A, uint8_t blocks_access_bits,
                                        uint8_t sector_trailers_access_bits, uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B,
                                        VAR uint8_t *lpucSectorsFormatted, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteM(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A,
                                          uint8_t block0_access_bits, uint8_t block1_access_bits, uint8_t block2_access_bits,
                                          uint8_t sector_trailer_access_bits, uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B,
                                          uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteSamKeyM(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A,
                                                uint8_t block0_access_bits, uint8_t block1_access_bits, uint8_t block2_access_bits,
                                                uint8_t sector_trailer_access_bits, uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B,
                                                uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key_index Index of reader’s key to be used (RK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafeM(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address, IN const uint8_t *sector_trailer,
                                                uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockReadM(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address, uint8_t auth_mode,
                                      uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockReadSamKeyM(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address,
                                            uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorReadM(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                              uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorReadSamKeyM(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                    uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWriteM(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode,
                                       uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWriteSamKeyM(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode,
                                             uint8_t key_index);

    /**
    * @brief Multi reader support. Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWriteM(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t sector_address,
                                               uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWriteSamKeyM(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t sector_address,
                                                     uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Increments particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrementM(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t block_address, uint8_t auth_mode,
                                           uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Increments particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrementSamKeyM(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t block_address, uint8_t auth_mode,
                                                 uint8_t key_index);

    /**
    * @brief Multi reader support. Increments particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value increment value to add 
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrementM(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t sector_address,
                                                   uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Increments particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value increment value to add 
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrementSamKeyM(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t sector_address,
                                                         uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Decrements particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrementM(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t block_address, uint8_t auth_mode,
                                           uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Decrements particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrementSamKeyM(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t block_address, uint8_t auth_mode,
                                                 uint8_t key_index);

    /**
    * @brief Multi reader support. Decrements particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrementM(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t sector_address,
                                                   uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Decrements particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key_index Index of reader’s key to be used (RK mode)For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrementSamKeyM(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t sector_address,
                                                         uint8_t block_in_sector_address, uint8_t auth_mode, uint8_t key_index);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API BlockRead_AKM1M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWrite_AKM1M(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B:
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorRead_AKM1M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                              uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWrite_AKM1M(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t sector_address,
                                               uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API LinearRead_AKM1M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint16_t linear_address, uint16_t length,
                                       VAR uint16_t *bytes_returned, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Read Linear data Address Space. On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowRead_AKM1M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint16_t linear_address, uint16_t length,
                                       VAR uint16_t *bytes_returned, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start writing
    * @param length Length of data - how many bytes to write
    * @param bytes_written Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters

    * @return Operation status
    */
    UFR_STATUS DL_API LinearWrite_AKM1M(UFR_HANDLE hndUFR, IN const uint8_t *data, uint16_t linear_address, uint16_t length,
                                        VAR uint16_t *bytes_written, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCard_AKM1M(UFR_HANDLE hndUFR, IN const uint8_t *new_key_A, uint8_t blocks_access_bits,
                                             uint8_t sector_trailers_access_bits, uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B,
                                             VAR uint8_t *lpucSectorsFormatted, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWrite_AKM1M(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A,
                                               uint8_t block0_access_bits, uint8_t block1_access_bits, uint8_t block2_access_bits,
                                               uint8_t sector_trailer_access_bits, uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B,
                                               uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafe_AKM1M(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address,
                                                     IN const uint8_t *sector_trailer, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockRead_AKM1M(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address,
                                           uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorRead_AKM1M(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                   uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWrite_AKM1M(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWrite_AKM1M(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t sector_address,
                                                    uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Increments particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrement_AKM1M(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Increments particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value increment value to add 
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in MIFARE_AUTHENT1A or MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrement_AKM1M(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t sector_address,
                                                        uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Decrements particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented sector_address Absolute Sector address block_in_sector_address Block address in Sector auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrement_AKM1M(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 1 (AKM1)
    * Decrements particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrement_AKM1M(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t sector_address,
                                                        uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Read particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API BlockRead_AKM2M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWrite_AKM2M(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorRead_AKM2M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                              uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWrite_AKM2M(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t sector_address,
                                               uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) For keys into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.29 and library versions from 5.0.19. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API LinearRead_AKM2M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint16_t linear_address, uint16_t length,
                                       VAR uint16_t *bytes_returned, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Read Linear data Address Space. On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read bytes_returned
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter.
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowRead_AKM2M(UFR_HANDLE hndUFR, OUT uint8_t *data, uint16_t linear_address, uint16_t length,
                                       VAR uint16_t *bytes_returned, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start writing
    * @param length Length of data - how many bytes to write bytes_returned
    * @param bytes_written Pointer to variable holding how many bytes were written
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWrite_AKM2M(UFR_HANDLE hndUFR, IN const uint8_t *data, uint16_t linear_address, uint16_t length,
                                        VAR uint16_t *bytes_written, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCard_AKM2M(UFR_HANDLE hndUFR, IN const uint8_t *new_key_A, uint8_t blocks_access_bits,
                                             uint8_t sector_trailers_access_bits, uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B,
                                             VAR uint8_t *lpucSectorsFormatted, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWrite_AKM2M(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A,
                                               uint8_t block0_access_bits, uint8_t block1_access_bits, uint8_t block2_access_bits,
                                               uint8_t sector_trailer_access_bits, uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B,
                                               uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafe_AKM2M(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address,
                                                     IN const uint8_t *sector_trailer, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockRead_AKM2M(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address,
                                           uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorRead_AKM2M(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                   uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15) key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode) ValueBlockDecrement Function description Decrements particular Value block with specified value using absolute Block address. Mifare Plus X, SE and EV1 using. For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader. Function declaration (C language) UFR_STATUS ValueBlockDecrement(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index); UFR_STATUS ValueBlockDecrement_AKM1(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode; UFR_STATUS ValueBlockDecrement_AKM2(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode); UFR_STATUS ValueBlockDecrement_PK(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, const uint8_t *key); *only uFR CS with SAM support UFR_STATUS ValueBlockDecrementSamKey(int32_t decrement_value, uint8_t block_address, uint8_t auth_mode, uint8_t key_index);
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWrite_AKM2M(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWrite_AKM2M(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t sector_address,
                                                    uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Increments particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrement_AKM2M(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Increments particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value increment value to add 
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrement_AKM2M(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t sector_address,
                                                        uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Decrements particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrement_AKM2M(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t block_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Automatic Key Mode 2 (AKM2)
    * Decrements particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrement_AKM2M(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t sector_address,
                                                        uint8_t block_in_sector_address, uint8_t auth_mode);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Read particular block using absolute Block address.
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockRead() or BlockRead_PK() functions. Value 0x60 with BlockRead() or BlockRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API BlockRead_PKM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t block_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Write particular block using absolute Block address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param block_address Absolute block address
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockWrite() or BlockWrite_PK() functions. Value 0x60 with BlockWrite() or BlockWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockWrite_PKM(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t block_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Read particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorRead() or BlockInSectorRead_PK() functions. Value 0x60 with BlockInSectorRead() or BlockInSectorRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorRead_PKM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                            uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Write particular block using relative Block in Sector address.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with BlockInSectorWrite() or BlockInSectorWrite_PK() functions. Value 0x60 with BlockInSectorWrite() or BlockInSectorWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B:  use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API BlockInSectorWrite_PKM(UFR_HANDLE hndUFR, IN const uint8_t *data, uint8_t sector_address, uint8_t block_in_sector_address,
                                             uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearRead() or LinearRead_PK() functions. Value 0x60 with LinearRead() or LinearRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API LinearRead_PKM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint16_t linear_address, uint16_t length,
                                     VAR uint16_t *bytes_returned, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Read Linear data Address Space. On the contrary of LinearRead functions, this functions read whole card including trailer blocks and manufacturer block.
    * This function is useful when making “dump” of the whole card.
    * Linear reading in uFR firmware utilise FAST_READ ISO 14443-3 command with NTAG21x and Mifare Ultralight EV1 tags. When using this functions with other card types, auth_mode, key_index and key parameters are not relevant but must take default values.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start reading
    * @param length Length of data - how many bytes to read
    * @param bytes_returned Pointer to variable holding how many bytes are returned
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinRowRead() or LinRowRead_PK() functions. Value 0x60 with LinRowRead() or LinRowRead_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API LinRowRead_PKM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint16_t linear_address, uint16_t length,
                                     VAR uint16_t *bytes_returned, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * These functions are used for writing data to the card using emulation of the linear address space. The method for proving authenticity is determined by the suffix in the functions names.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param data Pointer to array of bytes containing data
    * @param linear_address Address of byte - where to start writing
    * @param length Length of data - how many bytes to write
    * @param bytes_written Pointer to variable holding how many bytes were written
    * @param auth_mode For Mifare Classic tags defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH value 0x61 means “use PWD_AUTH“ with LinearWrite() or LinearWrite_PK() functions. Value 0x60 with LinearWrite() or LinearWrite_PK() functions means “without PWD_AUTH“ and in that case you can send for ucReaderKeyIndex or aucProvidedKey parameters anything you want without influence on the result. For NTAG 21x, Ultralight EV1 and other T2T tags supporting PWD_AUTH you can use _AKM1 or _AKM2 function variants only without PWD_AUTH in any case of the valid values (0x60 or 0x61) provided for this parameter. For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 bytes array containing Crypto1 key (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API LinearWrite_PKM(UFR_HANDLE hndUFR, IN const uint8_t *data, uint16_t linear_address, uint16_t length,
                                      VAR uint16_t *bytes_written, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * This function is specific to Mifare Classic cards only. It performs “Format card” operation - write new Sector Trailer values on whole card at once. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Bytes 0 - 5
    * Bytes 6 - 8
    * Byte 9
    * Bytes 10 - 15
    * KeyA
    * Block Access &
    * Trailer Access Bits
    * GPB
    * KeyB
    * For more information, please refer to Mifare Classic Keys and Access Conditions in this document.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authetntication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are caluculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provode to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param blocks_access_bits Block Access permissions bits. Values 0 to 7
    * @param sector_trailers_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailers_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyA
    * @param lpucSectorsFormatted Pointer to variable holding return value how many sectors are successfully formatted
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API LinearFormatCard_PKM(UFR_HANDLE hndUFR, IN const uint8_t *new_key_A, uint8_t blocks_access_bits,
                                           uint8_t sector_trailers_access_bits, uint8_t sector_trailers_byte9, IN const uint8_t *new_key_B,
                                           VAR uint8_t *lpucSectorsFormatted, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Mifare Plus using.
    * For firmware versions from 5.0.29 and library versions from 5.0.19, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculated from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param new_key_A Pointer on 6 bytes array containing a new KeyA
    * @param block0_access_bits Access Permissions Bits for Block 0. Values 0 to 7
    * @param block1_access_bits Access Permissions Bits for Block 1. Values 0 to 7
    * @param block2_access_bits Access Permissions Bits for Block 2. Values 0 to 7
    * @param sector_trailer_access_bits Sector Trailer Access permissions bits. Values 0 to 7
    * @param sector_trailer_byte9 GPB value
    * @param new_key_B Pointer on 6 bytes array containing a new KeyB
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWrite_PKM(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address, IN const uint8_t *new_key_A,
                                             uint8_t block0_access_bits, uint8_t block1_access_bits, uint8_t block2_access_bits,
                                             uint8_t sector_trailer_access_bits, uint8_t sector_trailer_byte9, IN const uint8_t *new_key_B,
                                             uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * This function is specific to Mifare Classic cards only. It writes new Sector Trailer value at one Sector Trailer. It writes following data:
    * KeyA, Block Access Bits, Trailer Access Bits, GeneralPurposeByte(GPB), KeyB, same as construction of Sector Trailer.
    * Difference between this function and SectorTrailerWrite is :
    * * SectorTrailerWrite will check parameters and “safely” write them into trailer, non valid values will not be written
    * * SectorTrailerWriteUnsafe writes array of 16 bytes as raw binary trailer representation, any value can be written.
    * USE THIS FUNCTION WITH CAUTION, WRONG VALUES CAN DESTROY CARD!
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param addressing_mode Defines if Absolute (0) or Relative (1) Block Addressing mode is used
    * @param address Address of Trailer according to addressing_mode
    * @param sector_trailer Pointer to 16 byte array as binary representation of Sector Trailer
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61
    * @param key Pointer to 6 byte array containing key bytes (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API SectorTrailerWriteUnsafe_PKM(UFR_HANDLE hndUFR, uint8_t addressing_mode, uint8_t address,
                                                   IN const uint8_t *sector_trailer, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockRead_PKM(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t block_address,
                                         uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Read particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of reading value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorRead_PKM(UFR_HANDLE hndUFR, VAR int32_t *value, VAR uint8_t *value_addr, uint8_t sector_address,
                                                 uint8_t block_in_sector_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockWrite_PKM(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t block_address, uint8_t auth_mode,
                                          IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Write particular Value block using absolute Block address. This function uses Mifare Classic specific mechanism of writing value which is stored into whole block. Value blocks have a fixed data format which permits error detection and correction and a backup management. Value is a signed 4-byte value and it is stored three times, twice non-inverted and once inverted. Negative numbers are stored in standard 2's complement format. For more info, please refer to Mifare Classic documentation.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to variable where retrieved value will be stored
    * @param value_addr Signifies a 1-byte address, which can be used to save the storage address of a block, when implementing a powerful backup management. For more info, please refer to Mifare Classic documentation.
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorWrite_PKM(UFR_HANDLE hndUFR, int32_t value, uint8_t value_addr, uint8_t sector_address,
                                                  uint8_t block_in_sector_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Increments particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value value showing how much initial block value will be incremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockIncrement_PKM(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t block_address, uint8_t auth_mode,
                                              IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Increments particular Value block with specified value using Block in Sector address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param increment_value increment value to add
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorIncrement_PKM(UFR_HANDLE hndUFR, int32_t increment_value, uint8_t sector_address,
                                                      uint8_t block_in_sector_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Decrements particular Value block with specified value using absolute Block address.
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    *
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param block_address Absolute block address
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81 key_index Index of reader’s key to be used (RK mode) For Crypto1 keys (0 - 31) For Mifare Plus AES keys (0 - 15) (fw version to 5.0.36) For key into SAM (1 - 127) For Mifare Plus and fw versions from 5.0.36 and library versions from 5.0.34. in  MIFARE_AUTHENT1A or  MIFARE_AUTHENT1B mode uses AES key calculated from Crypto1 key (0 -31), and in MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B mode uses AES keys (0 - 15)
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockDecrement_PKM(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t block_address, uint8_t auth_mode,
                                              IN const uint8_t *key);

    /**
    * @brief Provided Key mode (PK) Decrements particular Value block with specified value using Block in Sector address.
    * 
    * Mifare Plus X, SE and EV1 using.
    * For firmware versions from 5.0.36 and library versions from 5.0.34, this functions may be used for Mifare plus cards. If authentication mode is MIFARE_AUTHENT1A or MIFARE_AUTHENT1B, AES key for authentication, and new AES key A and new AES key B are calculate from Crypto1 keys.  If authentication mode is MIFARE_PLUS_AES_AUTHENT1A or MIFARE_PLUS_AES_AUTHENT1B, new AES keys are provided to reader.
    * Multi reader support. 
    * @ingroup Card_Tag_Mifare_M
    *
    * @param hndUFR handle of the uFR device
    * @param decrement_value value showing how much initial block value will be decremented
    * @param sector_address Absolute Sector address
    * @param block_in_sector_address Block address in Sector
    * @param auth_mode Defines whether to perform authentication with key A or key B: use KeyA - MIFARE_AUTHENT1A = 0x60 or KeyB - MIFARE_AUTHENT1B = 0x61 For Mifare Plus tags (PK mode) defines whether to perform authentication with key A or key B: use KeyA - MIFARE_PLUS_AES_AUTHENT1A = 0x80 or KeyB - MIFARE_PLUS_AES_AUTHENT1B = 0x81
    * @param key Pointer to 6 byte array containing key bytes (PK mode) For Mifare Plus pointer to 16 bytes array containing AES key (PK mode)
    * @return Operation status
    */
    UFR_STATUS DL_API ValueBlockInSectorDecrement_PKM(UFR_HANDLE hndUFR, int32_t decrement_value, uint8_t sector_address,
                                                      uint8_t block_in_sector_address, uint8_t auth_mode, IN const uint8_t *key);

    /**
    * @brief Multi reader support. Returns reader hardware version as two byte representation of higher and lower byte.
    *
    * @ingroup ReaderAndLibrary_Information_M
    *
    * @param hndUFR handle of the uFR device
    * @param version_major pointer to version major variable
    * @param version_minor pointer to version minor variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderHardwareVersionM(UFR_HANDLE hndUFR, VAR uint8_t *version_major, VAR uint8_t *version_minor);

    /**
    * @brief Multi reader support. Returns reader firmware version as two byte representation of higher and lower byte.
    *
    * @ingroup ReaderAndLibrary_Information_M

    * @param hndUFR handle of the uFR device
    * @param version_major pointer to version major variable
    * @param version_minor pointer to version minor variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderFirmwareVersionM(UFR_HANDLE hndUFR, VAR uint8_t *version_major, VAR uint8_t *version_minor);

    // New commands (for RTC & I2C EEPROM):
    /**
    * @brief Multi reader support. Function returns a 6 bytes array of uint8_t that represents the current date and time into the device's RTC.
    * * Byte 0 represent year (current year - 2000)
    * * Byte 1 represent month (1 - 12)
    * * Byte 2 represent day of the month (1 - 31)
    * * Byte 3 represent hour (0 - 23)
    * * Byte 4 represent minute (0 - 59)
    * * Byte 5 represent second (0 - 59)
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RTC_M
    *
    * @param hndUFR handle of the uFR device
    * @param time pointer to the 6 bytes array containing date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderTimeM(UFR_HANDLE hndUFR, VAR uint8_t *time);

    /**
    * @brief Multi reader support. Function sets the date and time into the device's RTC. Function requires the 8 bytes password entry to set  date and time. Date and time are represented into a 6 bytes array in the same way as in the GetReaderTime function. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RTC_M
    *
    * @param hndUFR handle of the uFR device
    * @param password pointer to the 8 bytes array containing password time
    * @param time pointer to the 6 bytes array containing date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetReaderTimeM(UFR_HANDLE hndUFR, IN uint8_t *password, VAR uint8_t *time);

    /**
    * @brief Multi reader support. This function is used in Common, Advance and Access Control set of functions.
    * It defines/changes password which I used for:
    * * Locking/unlocking keys stored into reader
    * * Setting date/time of RTC
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param old_password pointer to the 8 bytes array containing current password
    * @param new_password pointer to the 8 bytes array containing new password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ChangeReaderPasswordM(UFR_HANDLE hndUFR, IN uint8_t *old_password, IN uint8_t *new_password);

    /**
    * @brief Multi reader support. Function writes array of data into EEPROM. Maximal length of array is 128 bytes. Function requires password which length is 8 bytes. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param data pointer to array containing data
    * @param address address of first data
    * @param size length of array
    * @param password pointer to array containing password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderEepromWriteM(UFR_HANDLE hndUFR, IN uint8_t *data, uint32_t address, uint32_t size, IN uint8_t *password);

    /**
    * @brief Multi reader support. Function returns array of data read from EEPROM. Maximal length of array is 128 bytes.
    *
    * @ingroup ReaderAndLibrary_EEPROM_M
    *
    * @param hndUFR handle of the uFR device
    * @param data pointer to  array containing data from EEPROM
    * @param address address of first data
    * @param size length of array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderEepromReadM(UFR_HANDLE hndUFR, OUT uint8_t *data, uint32_t address, uint32_t size);

    /**
    * @brief Multi reader support. Returns reader’s descriptive name as a row of 8 chars.
    *
    * @ingroup ReaderAndLibrary_Information_M
    *
    * @param hndUFR handle of the uFR device
    * @param pSerialDescription pointer to pSerialDescription array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetReaderSerialDescriptionM(UFR_HANDLE hndUFR, OUT uint8_t pSerialDescription[8]);

    // New since version 2.0:
    /**
    * @brief Multi reader support. Returns reader firmware build version as one byte representation.
    *
    * @ingroup ReaderAndLibrary_Information_M
    *
    * @param hndUFR handle of the uFR device
    * @param build pointer to build variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetBuildNumberM(UFR_HANDLE hndUFR, VAR uint8_t *build);

    /**
    * @brief Multi reader support. This function returns UID of card actually present in RF field of reader. 
    * 
    * It can handle all three known types : 4, 7 and 10 byte long UIDs.
    * This function is recommended for use instead of GetCardId.
    *
    * @ingroup Card_Tag_General_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpucSak returns pointer to variable which holds card type according to SAK
    * @param aucUid returns pointer to array of card UID bytes, variable length
    * @param lpucUidSize returns pointer to variable holding information about UID length
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCardIdExM(UFR_HANDLE hndUFR, VAR uint8_t *lpucSak, OUT uint8_t *aucUid, VAR uint8_t *lpucUidSize);

    /**
    * @brief Multi reader support. This function returns UID of last card which was present in RF field of reader.  
    * 
    * It can handle all three known types : 4, 7 and 10 byte long UIDs. Difference with GetCardIdEx is that card does not be in RF field mandatory, UID value is stored in temporary memory area.
    *
    * @ingroup Card_Tag_General_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpucSak returns pointer to variable which holds card type according to SAK
    * @param aucUid returns pointer to array of card UID bytes, variable length
    * @param lpucUidSize returns pointer to variable holding information about UID length
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetLastCardIdExM(UFR_HANDLE hndUFR, VAR uint8_t *lpucSak, OUT uint8_t *aucUid, VAR uint8_t *lpucUidSize);

    //------------------------------------------------------------------------------
    // Multi card mode:
    //------------------------------------------------------------------------------
    /**
    * @brief Multi reader support. This function puts the reader in an “anti-collision” mode of operation.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EnableAntiCollisionM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Exits from “anti-collision” mode of operation i.e. put the reader in to “single card” mode of operation.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DisableAntiCollisionM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. If the reader is in an “anti-collision” mode of operation, this function enumerates cards which are found in the reader field. Otherwise the function returns ANTI_COLLISION_DISABLED status code.
    * All the calls to the ListCards(), SelectCard() and DeselectCard() work with UIDs from the actual UID list of the enumerated cards, which is obtained by the last call of this function.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpucCardsNumber If the function is successfully executed, the memory location on which this pointer points to, will contain a number of the enumerated cards.
    * @param lpucUidListSize If the function is successfully executed, the memory location on which this pointer points to, will contain a UID list of the enumerated cards size in bytes.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EnumCardsM(UFR_HANDLE hndUFR, VAR uint8_t *lpucCardsNumber, OUT uint8_t *lpucUidListSize); // Card pointer is on the first card in list

    /**
    * @brief Multi reader support. Before calling this function you have to call EnumCards() first.
    * For each UID of the cards detected in the reader field, there are 11 “UID record bytes” allocated in the list. First of those 11 bytes allocated designate actual UID length immediately followed by the exactly 10 bytes of UID (which is maximum hypothetical UID size). E.g, if the actual UID length is 4 bytes, you should ignore last 6 bytes of the UID record.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucUidList Pointer to the memory alocated for the UID list. Before calling this function, you should alocate atleast *lpucUidListSize bytes which is returned by the prior call to EnumCards() function.
    * @param ucUidListSize Size (in bytes) of the array alocated on the memory location aucUidList points to.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ListCardsM(UFR_HANDLE hndUFR, OUT uint8_t *aucUidList, uint8_t ucUidListSize); // Before calling this function you must call EnumCards() first.

    /**
    * @brief Multi reader support. Selects one of the cards which UID is on the actual UID list of the enumerated cards. If there is any of the cards previously selected calling this function you will get an CARD_ALREADY_SELECTED status code and, in such a case, you should call DeslectCard() function prior using SelectCard(). If UID list of the enumerated cards is empty, you will get an NO_TAGS_ENUMERRATED status code.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision_M
    *
    * @param hndUFR handle of the uFR device
    * @param aucUid pointer to the byte array containing UID of the card which is to be selected
    * @param ucUidSize actual UID size
    * @param lpucSelctedCardType pointer to byte which will contain DlogicCardType constant of the selected card, in case of successful execution of this function
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SelectCardM(UFR_HANDLE hndUFR, IN const uint8_t *aucUid, uint8_t ucUidSize, OUT uint8_t *lpucSelctedCardType);

    /**
    * @brief Multi reader support. If the reader is in a “anti-collision” mode of operation, this function deselects currently selected card. Otherwise function returns ANTI_COLLISION_DISABLED status code.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API DeslectCardM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Calling this function you can get current anti-collision status of the reader.
    *
    * @ingroup Card_Tag_CardFeatures_AntiCollision_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpcIsAntiCollEnabled pointer to byte which will contain 1 if reader is in a “anti-collision” mode of operation, 0 otherwise
    * @param lpcIsAnyCardSelected pointer to byte which will contain 1 if reader is in a “anti-collision” mode of operation and there is selected card, 0 otherwise
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAntiCollisionStatusM(UFR_HANDLE hndUFR, VAR int8_t *lpcIsAntiCollEnabled, VAR int8_t *lpcIsAnyCardSelected);

    //------------------------------------------------------------------------------

    /**
    * @brief Multi reader support. This function returns card type according to DlogicCardType enumeration. For details, please refer to Appendix: DLogic CardType enumeration.
    * If the card type is not supported, function return the lpucCardType value equal to zero : TAG_UNKNOWN = 0x00
    *
    * @ingroup Card_Tag_General_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpucCardType pointer to lpucCardType variable. Variable lpucCardType holds returned value of actual card type present in RF field.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetDlogicCardTypeM(UFR_HANDLE hndUFR, VAR uint8_t *lpucCardType);

    /**
    * @brief Multi reader support. This function returns 8 bytes of the T2T version. All modern T2T chips support this functionality and have in common a total of 8 byte long version response. This function is primarily intended to use with NFC_T2T_GENERIC tags (i.e. tags which return 0x0C in the *lpucCardType parameter of the GetDlogicCardType()).
    *
    * @ingroup Card_Tag_NTAG_2XX_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpucVersionResponse array containing 8 bytes which will receive raw T2T version.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetNfcT2TVersionM(UFR_HANDLE hndUFR, OUT uint8_t lpucVersionResponse[8]);

    /**
    * @brief Multi reader support. Function returns  size of user data space on the card (LinearSize), and size of total data space on the card (RawSize). The user data space is accessed via functions LinearWrite and LinearRead. Total data space is accessed via functions LinRowWrite and LinRowRead. For example Mifare Classic 1K card have 752 bytes of user data space (sector trailers and block 0 are not included), and 1024 bytes of total data space.
    *
    * @ingroup Card_Tag_General_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpulLinearSize pointer to variable which contain size of user data space
    * @param lpulRawSize pointer to variable which contain size of total data space
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCardSizeM(UFR_HANDLE hndUFR, VAR uint32_t *lpulLinearSize, VAR uint32_t *lpulRawSize);

    /**
    * @brief Function provides the information about the tag tamper status which is detected when the NTAG 213 TT is powered by an RF field.
    * 
    * Multi reader support. From library version 5.0.59 and firmware version 5.0.60
    *
    * @ingroup Miscellaneous_M
    *
    * @param hndUFR handle of the uFR device
    * @param tt_message 4 byte Tag Tamper message. “0000” is returned, if the NTAG 213 TT has never detected the Tag Tamper as opened during the startup. If the NTAG 213 TT has once detected the tag tamper wire as opened, it returns the data which have been programmed in page 45 (TT_MESSAGE)
    * @param tt_status status of the tag tamper wire detected during startup. “C” if Tag Tamper was closed at current startup “O” if Tag Tamper was open at current startup “I” if Tag Tamper measurement was incorrect
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadTTStatusM(UFR_HANDLE hndUFR, OUT uint8_t *tt_message, VAR uint8_t *tt_status);

    //------------------------------------------------------------------------------

    /**
    * @brief Multi reader support. Function returns “mobile additional” data if the tag in the reader field is actually the selected HCE application in a mobile phone with the appropriate AID which can be set using the SetMobileUniqueIdAid() API. The indication that the HCE application in the mobile phone with the corresponding AID is actually selected is the card type code 0x60 (DL_MOBILE_AID) obtained by the previous call to the GetDlogicCardType() or GetCardIdEx() API.
    *
    * @param hndUFR handle of the uFR device
    * @param data Array of bytes that should have at least 32 bytes previously allocated.
    * @param len Pointer to the variable containing actual size of the data array before calling this function and after the successful execution contains size of the data returned by the reader (max. 32 bytes)
    *
    * @ingroup Card_Tag_M
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetMobileAdditionalDataM(UFR_HANDLE hndUFR, uint8_t data[32], uint32_t *len);

    /**
    * @brief Multi reader support. Function returns reader’s serialized discovery loop structure i.e. C union (following gcc example):
    * typedef union {
    * __attribute ((packed)) struct {
    * uint16_t flags;
    * uint32_t RFU;
    * };
    * __attribute ((packed)) struct {
    * uint8_t byte0;
    * uint8_t byte1;
    * uint32_t RFU;
    * } bytes;
    * __attribute ((packed)) struct {
    * uint8_t legacy:1;
    * uint8_t enable_type_a:1;
    * uint8_t enable_type_b:1;
    * uint8_t enable_apple_ecp:1;
    * uint8_t enable_hce:1;
    * uint8_t auto_select_dlogic_aid:1;
    * uint8_t auto_select_apple_vas:1;
    * uint8_t auto_select_google_vas:1;
    * uint8_t RFU_flags;
    * uint32_t RFU;
    * } bits;
    * } discovery_loop_setup_t;
    * sizeof (discovery_loop_setup_t) is 6 bytes.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures_M
    *
    * @param hndUFR handle of the uFR device
    * @param setupStruct Pointer to the array of bytes that should have at least sizeof (discovery_loop_setup_t) i.e. 6 bytes previously allocated.
    * @param len Pointer to the variable containing actual size of the data array before calling this function (at least sizeof (discovery_loop_setup_t) i.e. 6 bytes) and after the successful execution contains size of the data returned by the reader.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetDiscoveryLoopSetupM(UFR_HANDLE hndUFR, uint8_t *setupStruct, uint32_t *len);

    /**
    * @brief Multi reader support. Function sets the reader’s discovery loop.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures_M
    *
    * @param hndUFR handle of the uFR device
    * @param setupStruct Pointer to the serialized discovery loop structure.
    * @param len Size of the serialized discovery loop structure. e.g. sizeof (discovery_loop_setup_t) i.e. 6 bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetDiscoveryLoopM(UFR_HANDLE hndUFR, const uint8_t *setupStruct, uint32_t len);

    /**
    * @brief Multi reader support. Function returns the AID set in the reader to retrieve the mobile phone's unique ID. If the reader’s AID has never been set using SetMobileUniqueIdAid(), the function returns UFR_READING_ERROR status and the reader uses the default AID which is
    * {0xF0, 0x01, 0x02, 0x03, 0x04, 0x05}.
    * Minimum AID length is 5 bytes. Maximum AID len is 16 bytes.
    * For details, see the example project at the
    * https://www.d-logic.com/code/nfc-rfid-reader-sdk/ufr-aid_for_mobile_unique_id_setup.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures_M
    *
    * @param hndUFR handle of the uFR device
    * @param aid Pointer to the array of bytes that should have at least 16 bytes previously allocated.
    * @param len Pointer to the variable containing actual size of the data array before calling this function (at least 16) and after the successful execution contains size of the data returned by the reader (max. 16 bytes)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetMobileUniqueIdAidM(UFR_HANDLE hndUFR, uint8_t *aid, uint32_t *len);

    /**
    * @brief Multi reader support. Function sets the reader’s AID to retrieve the mobile phone's unique ID.
    * 
    * Minimum AID length is 5 bytes. Maximum AID len is 16 bytes.
    * The default (factory) uFR AID is {0xF0, 0x01, 0x02, 0x03, 0x04, 0x05}.
    * Minimum AID length is 5 bytes. Maximum AID len is 16 bytes.
    * For details, see the example project at the
    * https://www.d-logic.com/code/nfc-rfid-reader-sdk/ufr-aid_for_mobile_unique_id_setup.
    *
    * @ingroup ReaderAndLibrary_uFRZeroSpecificFeatures_M
    *
    * @param hndUFR handle of the uFR device
    * @param aid Pointer to the array of bytes containing the new AID.
    * @param len Size of the new AID in bytes.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetMobileUniqueIdAidM(UFR_HANDLE hndUFR, const uint8_t *aid, uint32_t len);

    //------------------------------------------------------------------------------

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ATECC608LockConfigM(UFR_HANDLE hndUFR);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ATECC608LockDataAndOtpM(UFR_HANDLE hndUFR);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ATECC608LockKeySlotM(UFR_HANDLE hndUFR, uint8_t key_slot);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608DefaultSlotsConfigurationM(UFR_HANDLE hndUFR);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608DefaultKeysConfigurationM(UFR_HANDLE hndUFR);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608IOSecretKeyM(UFR_HANDLE hndUFR);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608ECCPrivateKeyUnencryptedM(UFR_HANDLE hndUFR, uint8_t key_slot, uint8_t bool_enabled,
                                                           uint8_t pub_key_id[4], uint8_t merchant_id[32], uint8_t ecc_priv_key[32]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetATECC608ECCPrivateKeyM(UFR_HANDLE hndUFR, uint8_t key_slot, uint8_t bool_enabled,
                                                uint8_t pub_key_id[4], uint8_t merchant_id[32], uint8_t ecc_priv_key[32]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608ConfigZoneM(UFR_HANDLE hndUFR, uint8_t config_zone[128]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608OtpZoneM(UFR_HANDLE hndUFR, uint8_t otp_zone[64]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608ZonesLockStatusM(UFR_HANDLE hndUFR, VAR uint8_t *bool_config_zone_locked,
                                                  VAR uint8_t *bool_otp_zone_locked);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetATECC608InfoRevisionM(UFR_HANDLE hndUFR, uint8_t revision[4]);

    //------------------------------------------------------------------------------

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetReaderProModeM(UFR_HANDLE hndUFR, VAR uint32_t *pReaderProMode, OUT uint32_t *pReaderProConfig);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API SetReaderProModeM(UFR_HANDLE hndUFR, const uint32_t ReaderProMode);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_InitializeM(UFR_HANDLE hndUFR, IN const uint8_t *TBSerialString, uint16_t job_number);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetNextEncryptedCardM(UFR_HANDLE hndUFR, const uint32_t from_timestamp, const uint32_t to_timestamp,
                                                           OUT uint8_t out_card_data[]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetNextM(UFR_HANDLE hndUFR, const uint32_t code_type, const uint32_t from_timestamp,
                                              const uint32_t to_timestamp, const uint32_t additional_data_size,
                                              IN const uint8_t additional_data[], VAR uint32_t *out_card_data_size, OUT uint8_t out_card_data[]);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetActualCardSNM(UFR_HANDLE hndUFR, OUT uint32_t *ActualCard_SN, VAR uint32_t *ActualCard_SN_LOG);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetJobSNM(UFR_HANDLE hndUFR, VAR uint32_t *JobSN);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API CardEncryption_GetSalterSNM(UFR_HANDLE hndUFR, OUT uint8_t SalterSN[8], VAR uint8_t *magicByte);

    /**
    * @brief Multi reader support. Function returns TNF, type of record, ID and payload from the NDEF record. NDEF record shall be elected by the message ordinal and record ordinal in this message.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param record_nr NDEF record ordinal (in message)
    * @param tnf pointer to the variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    *
    * @return Operation status
    */
    UFR_STATUS DL_API read_ndef_recordM(UFR_HANDLE hndUFR, uint8_t message_nr, uint8_t record_nr, VAR uint8_t *tnf, OUT uint8_t *type_record,
                                        VAR uint8_t *type_length, OUT uint8_t *id, VAR uint8_t *id_length, OUT uint8_t *payload,
                                        VAR uint32_t *payload_length);

    /**
    * @brief Multi reader support. Function adds a record to the end of message, if one or more records already exist in this message. If current message is empty, then this empty record will be replaced with the record. Parameters of function are: ordinal of message, TNF, type of record, ID, payload. Function also returns pointer to the variable which reported that the card formatted for NDEF using (card does not have a capability container, for example new Mifare Ultralight, or Mifare Classic card).
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param tnf pointer to variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    * @param card_formated pointer to the variable which shows that the card formatted for NDEF using.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API write_ndef_recordM(UFR_HANDLE hndUFR, uint8_t message_nr, uint8_t *tnf, IN uint8_t *type_record, uint8_t *type_length,
                                         IN uint8_t *id, uint8_t *id_length, IN uint8_t *payload, uint32_t *payload_length,
                                         VAR uint8_t *card_formated);

    /**
    * @brief Multi reader support. This function works the same as the write_ndef_record(), with the additional “UID and / or NFC counter mirror” features support. NTAG 21x family of devices offers these specific features. For details about “ASCII mirror” features refer to http://www.nxp.com/docs/en/data-sheet/NTAG213_215_216.pdf (in Rev. 3.2 from 2. June 2015, page 20) and http://www.nxp.com/docs/en/data-sheet/NTAG210_212.pdf (in Rev. 3.0 from 14. March 2013, page 16).
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param tnf pointer to variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    * @param card_formated pointer to the variable which shows that the card formatted for NDEF using.
    * @param use_uid_ascii_mirror if use_uid_ascii_mirror == 1 then “UID ASCII Mirror” feature is in use. if use_uid_ascii_mirror == 0 then “UID ASCII Mirror” feature is switched off.
    * @param use_counter_ascii_mirror if use_counter_ascii_mirror == 1 then “NFC counter ASCII Mirror” feature is in use. if use_counter_ascii_mirror == 0 then “NFC counter ASCII Mirror” feature is switched off.
    * @param payload_mirroring_pos Defines the starting position of the “ASCII Mirror” into the NDEF record payload.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API write_ndef_record_mirroringM(UFR_HANDLE hndUFR, uint8_t message_nr, uint8_t *tnf, IN uint8_t *type_record,
                                                   uint8_t *type_length, IN uint8_t *id, uint8_t *id_length, IN uint8_t *payload,
                                                   uint32_t *payload_length, VAR uint8_t *card_formated, int use_uid_ascii_mirror,
                                                   int use_counter_ascii_mirror, uint32_t payload_mirroring_pos);

    /**
    * @brief Multi reader support. This function works the same as the write_ndef_record(), with the additional “UID and / or NFC counter mirror” features support. NTAG 21x family of devices offers these specific features. For details about “ASCII mirror” features refer to http://www.nxp.com/docs/en/data-sheet/NTAG213_215_216.pdf (in Rev. 3.2 from 2. June 2015, page 20) and http://www.nxp.com/docs/en/data-sheet/NTAG210_212.pdf (in Rev. 3.0 from 14. March 2013, page 16).
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message_nr NDEF message ordinal (starts from 1)
    * @param tnf pointer to variable containing TNF of record
    * @param type_record pointer to array containing type of record
    * @param type_length pointer to the variable containing length of type of record string
    * @param id pointer to array containing ID of record
    * @param id_length pointer to the variable containing length of ID of record string
    * @param payload pointer to array containing payload of record
    * @param payload_length pointer to the variable containing length of payload
    * @param card_formated pointer to the variable which shows that the card formatted for NDEF using.
    * @param use_uid_ascii_mirror if use_uid_ascii_mirror == 1 then “UID ASCII Mirror” feature is in use. if use_uid_ascii_mirror == 0 then “UID ASCII Mirror” feature is switched off.
    * @param use_counter_ascii_mirror if use_counter_ascii_mirror == 1 then “NFC counter ASCII Mirror” feature is in use. if use_counter_ascii_mirror == 0 then “NFC counter ASCII Mirror” feature is switched off. payload_mirroring_pos Defines the starting position of the “ASCII Mirror” into the NDEF record payload.
    * @param use_tt_message_mirror if use_tt_message_mirror == 1 then Tag tamper status mirroring is enabled
    * @param payload_mirroring_pos Defines the starting position of the “ASCII Mirror” into the NDEF record payload.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API write_ndef_record_mirroring_ttM(UFR_HANDLE hndUFR, uint8_t message_nr, uint8_t *tnf, IN uint8_t *type_record,
                                                      uint8_t *type_length, IN uint8_t *id, uint8_t *id_length, IN uint8_t *payload,
                                                      uint32_t *payload_length, VAR uint8_t *card_formated, int use_uid_ascii_mirror,
                                                      int use_counter_ascii_mirror, int use_tt_message_mirror, uint32_t payload_mirroring_pos);

    /**
    * @brief Multi reader support. Function returns the number of NDEF messages that have been read from the card, and number of NDEF records, number of NDEF empty messages. Also, function returns array of bytes containing number of messages pairs. First byte of pair is message ordinal, and second byte is number of NDEF records in that message. Message ordinal starts from 1.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_message_cnt pointer to the variable containing number of NDEF messages
    * @param ndef_record_cnt pointer to the variable containing number of NDEF record
    * @param ndef_record_array pointer to the array of bytes containing pairs (message ordinal - number of records)
    * @param empty_ndef_message_cnt pointer to the variable containing number of empty messages
    *
    * @return Operation status
    */
    UFR_STATUS DL_API get_ndef_record_countM(UFR_HANDLE hndUFR, VAR uint8_t *ndef_message_cnt, VAR uint8_t *ndef_record_cnt,
                                             OUT uint8_t *ndef_record_array, VAR uint8_t *empty_ndef_message_cnt);

    /**
    * @brief Multi reader support. Function deletes the last record of the selected message. If a message contains one record, then it will be written as an empty message.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message_nr NDEF message ordinal (starts form 1)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API erase_last_ndef_recordM(UFR_HANDLE hndUFR, uint8_t message_nr);

    /**
    * @brief Multi reader support. Function deletes all records of the message, then writes an empty message.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message_nr NDEF message ordinal (starts form 1)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API erase_all_ndef_recordsM(UFR_HANDLE hndUFR, uint8_t message_nr);

    /**
    * @brief Multi reader support. Function prepares the card for NDEF using.  Function writes Capability Container (CC) if necessary, and writes empty message. If the card is MIFARE CLASSIC or MIFARE PLUS, then the function writes MAD (MIFARE Application Directory), and default keys and access bits for NDEF using.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ndef_card_initializationM(UFR_HANDLE hndUFR);

    //---------------------------------------------------------------------
    // Card emulation:
    //---------------------------------------------------------------------

    /**
    * @brief Multi reader support. Function stores a message record for NTAG emulation mode into the reader. Parameters of the function are: TNF, type of record, ID, payload. Maximum total size for emulated NDEF message is 144 bytes.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode_M
    *
    * @param hndUFR handle of the uFR device
    * @param tnf TNF of the record
    * @param type_record pointer to the array containing record type
    * @param type_length length of the record type
    * @param id pointer to the array containing record ID
    * @param id_length length of the record ID
    * @param payload pointer to the array containing record payload
    * @param payload_length length of the record payload
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteEmulationNdefM(UFR_HANDLE hndUFR, uint8_t tnf, IN uint8_t *type_record, uint8_t type_length, IN uint8_t *id,
                                          uint8_t id_length, IN uint8_t *payload, uint8_t payload_length);

    /**
    * @brief Multi reader support. Put the reader permanently in a NDEF tag emulation mode. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling  TagEmulationStop() function).
    * In this mode, the reader can only answer to the commands issued by a following library functions:
    * TagEmulationStart(),
    * WriteEmulationNdef(),
    * TagEmulationStop(),
    * GetReaderSerialNumber(),
    * GetReaderSerialDescription(),
    * GetReaderHardwareVersion(),
    * GetReaderFirmwareVersion(),
    * GetBuildNumber()
    * Calls to the other functions in this mode returns following error code:
    * FORBIDDEN_IN_TAG_EMULATION_MODE = 0x90
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationStartM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Allows the reader permanent exit from a NDEF tag emulation mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API TagEmulationStopM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Puts the uFR reader into a permanently periodical switching from “NDEF tag emulation mode” to “tag reader mode”. Only way for a reader to exit from this mode is to receive the TAG_EMULATION_STOP command (issued by calling the TagEmulationStop() function).
    * Much better control of the NFC device in a uFR proximity range can be achieved using Ad-Hoc emulation mode, described before.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_CombinedMode_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API CombinedModeEmulationStartM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Put uFR in emulation mode with ad-hoc emulation parameters (see. SetAdHocEmulationParams() and GetAdHocEmulationParams() functions). uFR stays in ad-hoc emulation mode until AdHocEmulationStop() is called or reader reset.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AdHocEmulationStartM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Terminate uFR ad-hoc emulation mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AdHocEmulationStopM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. This function returns  current ad-hoc emulation parameters. On uFR power on or reset ad-hoc emulation parameters are set back to their default values.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel default value is 15. Could be in range from 0 to 15.
    * @param ThresholdCollLevel default value is 7. Could be in range from 0 to 7
    * @param RFLevelAmp default value is 0. On uFR device should be 0 all the time. (1 for on, 0 for off).
    * @param RxGain Could be in range from 0 to 7.
    * @param RFLevel Could be in range from 0 to 15.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAdHocEmulationParamsM(UFR_HANDLE hndUFR, VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel,
                                               VAR uint8_t *RFLevelAmp, VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief Multi reader support. This command set ad-hoc emulation parameters. On uFR power on or reset ad-hoc emulation parameters are set back to their default values.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel default value is 15. Could be in range from 0 to 15
    * @param ThresholdCollLevel default value is 7. Could be in range from 0 to 7
    * @param RFLevelAmp default value is 0. On uFR device should be 0 all the time. (1 for on, 0 for off).
    * @param RxGain Could be in range from 0 to 7.
    * @param RFLevel Could be in range from 0 to 15
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetAdHocEmulationParamsM(UFR_HANDLE hndUFR, uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp,
                                               uint8_t RxGain, uint8_t RFLevel);

    /**
    * @brief Multi reader support. Returns external field state when uFR is in ad-hoc emulation mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AdHocMode_M
    *
    * @param hndUFR handle of the uFR device
    * @param is_field_present contains 0 if external field isn’t present or 1 if field is present.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetExternalFieldStateM(UFR_HANDLE hndUFR, VAR uint8_t *is_field_present);

    /**
    * @brief Multi reader support. Put reader permanently in the mode that use shared RAM. After execution of this function, must be executed function TagEmulationStart.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EnterShareRamCommModeM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The permanent exit from mode that use shared RAM. After execution of this function, must be executed function TagEmulationStop.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ExitShareRamCommModeM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Function allows writing data to the shared RAM.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param ram_data pointer to data array
    * @param addr address of first data in an array
    * @param data_len length of array. Address + data_len <= 184
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteShareRamM(UFR_HANDLE hndUFR, uint8_t *ram_data, uint8_t addr, uint8_t data_len);

    /**
    * @brief Multi reader support. Function allows read data from the shared RAM.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SharedRAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param ram_data pointer to data array
    * @param addr address of first data in an array
    * @param data_len length of array. Address + data_len <= 184
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadShareRamM(UFR_HANDLE hndUFR, uint8_t *ram_data, uint8_t addr, uint8_t data_len);

    /**
    * @brief Multi reader support. From library version 5.0.31, and firmware version 5.0.33
    * Function stores a message record for NTAG emulation mode into the reader in the RAM. Parameters of the function are: TNF, type of record, ID, payload. Maximum total size for emulated NDEF message is 1008 bytes. Unlike the function WriteEmulationNdef, the data is not written to the EEPROM of the reader, so they cannot be loaded after the reader is reset. This function must be called after reader reset to use the NTAG emulation.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_TagEmulationMode_M
    *
    * @param hndUFR handle of the uFR device
    * @param tnf TNF of the record
    * @param type_record pointer to the array containing record type
    * @param type_length length of the record type
    * @param id pointer to the array containing record ID
    * @param id_length length of the record ID
    * @param payload pointer to the array containing record payload
    * @param payload_length length of the record payload
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteEmulationNdefRamM(UFR_HANDLE hndUFR, uint8_t tnf, uint8_t *type_record, uint8_t type_length,
                                             uint8_t *id, uint8_t id_length, uint8_t *payload, uint32_t payload_length);

    //------------------------------------------------------------------------------

    /**
    * @brief Multi reader support. This function returns the ECC signature of the card chip UID. Card chip UID is signed using EC private key known only to a manufacturer.
    *
    * @ingroup Card_Tag_CardFeatures_OriginalityChecking_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucUid pointer to a chip UID (in case of successfully executed operation). Returned here for convenience.
    * @param lpucUidLen pointer to variable which will (in case of successfully executed operation) receive true length of the returned UID. (Maximum UID length is 10 bytes but there is three possible UID sizes: 4, 7 and 10).
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    * @return Operation status
    */
    UFR_STATUS DL_API ReadECCSignatureM(UFR_HANDLE hndUFR, IN uint8_t lpucECCSignature[ECC_SIG_LEN], OUT uint8_t lpucUid[MAX_UID_LEN],
                                        VAR uint8_t *lpucUidLen, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Multi reader support. From library version 5.0.43 and firmware version 5.0.43.
    * This function returns the ECC signature of the card chip UID. Card chip UID is signed using EC private key known only to a manufacturer.
    * Unlike the ReadECCSignature function, this function supports ECC with variable length.
    *
    * @ingroup Card_Tag_CardFeatures_OriginalityChecking
    *
    * @param hndUFR handle of the uFR device
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucECCSignatureLen pointer to ECC signature length
    * @param lpucUid pointer to a chip UID (in case of successfully executed operation). Returned here for convenience.
    * @param lpucUidLen pointer to variable which will (in case of successfully executed operation) receive true length of the returned UID. (Maximum UID length is 10 bytes but there is three possible UID sizes: 4, 7 and 10).
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadECCSignatureExtM(UFR_HANDLE hndUFR, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucECCSignatureLen,
                                           OUT uint8_t *lpucUid, VAR uint8_t *lpucUidLen, VAR uint8_t *lpucDlogicCardType);

    //------------------------------------------------------------------------------

    /**
    * @brief Multi reader support. This function is used to read one of the three 24-bit one-way counters in Ultralight EV1 chip family. Those counters can’t be password protected. In the initial Ultralight EV1 chip state, the counter values are set to 0.
    *
    * @ingroup Card_Tag_NTAG_2XX_M
    *
    * @param hndUFR handle of the uFR device
    * @param counter_address Address of the target counter. Can be in range 0 to 2. Counters are mapped in a separate address space.
    * @param value Pointer to a uint32_t which will contained counter value after successful function execution. Since counters are 24-bit in length, most significant byte of the *value will be always 0.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadCounterM(UFR_HANDLE hndUFR, uint8_t counter_address, VAR uint32_t *value);

    /**
    * @brief Multi reader support. This function is used to increment one of the three 24-bit one-way counters in Ultralight EV1 chip family. Those counters can’t be password protected. If the sum of the addressed counter value and the increment value is higher than 0xFFFFFF, the tag replies with an error and does not update the respective counter.
    *
    * @ingroup Card_Tag_NTAG_2XX_M
    *
    * @param hndUFR handle of the uFR device
    * @param counter_address Address of the target counter. Can be in range 0 to 2. Counters are mapped in a separate address space.
    * @param inc_value Increment value. Only the 3 least significant bytes are relevant.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API IncrementCounterM(UFR_HANDLE hndUFR, uint8_t counter_address, uint32_t inc_value);

    /**
    * @brief Multi reader support. This function is used to read 24-bit NFC counters in NTAG 213, NTAG 215 and NTAG 216 chips without using password authentication. If access to the NFC counter is configured to be password protected, this function will return COUNTER_ERROR.
    *
    * @ingroup Card_Tag_NTAG_2XX_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to a uint32_t which will contain counter value after successfulfunction execution. Since counter is 24-bit in length, most significant byte of the *value will always be 0.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNFCCounterM(UFR_HANDLE hndUFR, VAR uint32_t *value); // Same as ReadCounter(2, &value);

    /**
    * @brief Multi reader support. This function is used to read 24-bit NFC counter in NTAG 213, NTAG 215 and NTAG 216 chips using “reader key password authentication”. If access to NFC counter is configured to be password protected and PWD-PACK pair stored as a 6-byte key in uFR reader disagrees with PWD-PACK pair configured in tag, this function will return UFR_AUTH_ERROR. If access to NFC counter isn’t configured to be password protected, this function will return UFR_AUTH_ERROR.
    *
    * @ingroup Card_Tag_NTAG_2XX_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to a uint32_t which will contain counter value after successful function execution. Since counter is 24-bit in length, most significant byte of the *value will always be 0.
    * @param reader_key_index Index of the 6-byte key (PWD-PACK pair for this type of NFC tags) stored in the uFR reader. Can be in range 0 to 31.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNFCCounterPwdAuth_RKM(UFR_HANDLE hndUFR, VAR uint32_t *value, uint8_t reader_key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * This function is used to read 24-bit NFC counter in NTAG 213, NTAG 215 and NTAG 216 chips using “reader key password authentication”. If access to NFC counter is configured to be password protected and PWD-PACK pair stored as a 6-byte key in uFR reader disagrees with PWD-PACK pair configured in tag, this function will return UFR_AUTH_ERROR. If access to NFC counter isn’t configured to be password protected, this function will return UFR_AUTH_ERROR.
    *
    * @ingroup Card_Tag_NTAG_2XX_M
    *
    * @param hndUFR handle of the uFR device
    * @param value Pointer to a uint32_t which will contain counter value after successful function execution. Since counter is 24-bit in length, most significant byte of the *value will always be 0.
    * @param key ointer to an array contains provided 6-byte key (PWD-PACK pair for this type of NFC tags) for password authentication.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNFCCounterPwdAuth_PKM(UFR_HANDLE hndUFR, VAR uint32_t *value, IN const uint8_t *key);

    //------------------------------------------------------------------------------

    /**
    * @brief Multi reader support. This function is used for the “Asynchronous UID sending” feature. Returned string contains hexadecimal notation of card ID with one mandatory suffix character and one optional prefix character.
    * On the uFR Zero USB series there is an option to enable USB HID keyboard simulation. It is needed to set the baud rate to 0. For example, if baud rate is setted to any other value than 0, UID is sent to UART, but if it is setted to 0 UID is sent as keyboard simulation.
    * Example:
    * Card ID is 0xA103C256, prefix is 0x58 ('X'), suffix is 0x59 ('Y')
    * Returned string is “XA103C256Y”
    * Function sets configuration parameters for this feature.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending_M
    *
    * @param hndUFR handle of the uFR device
    * @param send_enable turn feature on/off (0/1)
    * @param prefix_enable use prefix or not (0/1)
    * @param prefix prefix character
    * @param suffix suffix character
    * @param send_removed_enable Turn feature on/off (0/1). If feature is enabled then Asynchronous UID will also be sent when removing a card from the reader field.
    * @param async_baud_rate baud rate value (e.g. 9600)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetAsyncCardIdSendConfigM(UFR_HANDLE hndUFR, uint8_t send_enable, uint8_t prefix_enable, uint8_t prefix, uint8_t suffix,
                                                uint8_t send_removed_enable, uint32_t async_baud_rate);

    /**
    * @brief Multi reader support. Function sets the parameters of card ID sending.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending_M
    *
    * @param hndUFR handle of the uFR device
    * @param send_enable turn feature on/off (0/1)
    * @param prefix_enable use prefix or not (0/1)
    * @param prefix prefix character
    * @param suffix suffix character
    * @param send_removed_enable Turn feature on/off (0/1). If feature is enabled then Asynchronous UID will also be sent when removing a card from the reader field.
    * @param reverse_byte_order Turn feature on/off (0/1). If feature is disabled then the order of bytes (UID) will be as on card. If feature is enabled then the order of bytes will be reversed then the card’s order of bytes.
    * @param decimal_representation Turn feature on/off (0/1). If feature is enabled then the UID will be presented as a decimal number. If feature is disabled then the UID will be presented as a hexadecimal number
    * @param async_baud_rate baud rate value (e.g. 9600)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetAsyncCardIdSendConfigExM(UFR_HANDLE hndUFR, uint8_t send_enable, uint8_t prefix_enable, uint8_t prefix, uint8_t suffix,
                                                  uint8_t send_removed_enable, uint8_t reverse_byte_order, uint8_t decimal_representation,
                                                  uint32_t async_baud_rate);

    /**
    * @brief Multi reader support. Returns info about parameters configured with previous function.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending_M
    *
    * @param hndUFR handle of the uFR device
    * @param send_enable pointer, if feature is on/off (0/1)
    * @param prefix_enable pointer, if prefix is used or not (0/1)
    * @param prefix pointer to variable holding prefix character
    * @param suffix pointer to variable holding suffix character
    * @param send_removed_enable Pointer. If value is 0 then feature is off. Otherwise, feature is on. If feature is enabled then Asynchronous UID is sent when the card is removed from the reader field.
    * @param async_baud_rate pointer to variable holding configured baud rate
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAsyncCardIdSendConfigM(UFR_HANDLE hndUFR, VAR uint8_t *send_enable, VAR uint8_t *prefix_enable, VAR uint8_t *prefix,
                                                VAR uint8_t *suffix, VAR uint8_t *send_removed_enable, VAR uint32_t *async_baud_rate);

    /**
    * @brief Multi reader support. Function returns the parameters of card ID sending.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_AsynchronousUIDSending_M
    *
    * @param hndUFR handle of the uFR device
    * @param send_enable pointer, if feature is on/off (0/1)
    * @param prefix_enable pointer, if prefix is used or not (0/1)
    * @param prefix pointer to variable holding prefix character
    * @param suffix pointer to variable holding suffix character
    * @param send_removed_enable Pointer. If value is 0 then feature is off. Otherwise, feature is on. If feature is enabled then Asynchronous UID is sent when the card is removed from the reader field.
    * @param reverse_byte_order Turn feature on/off (0/1). If feature is disabled then the order of bytes (UID) will be as on card. If feature is enabled then the order of bytes will be reversed then the card’s order of bytes.
    * @param decimal_representation Turn feature on/off (0/1). If feature is enabled then the UID will be presented as a decimal number. If feature is disabled then the UID will be presented as a hexadecimal number
    * @param async_baud_rate pointer to baud rate variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetAsyncCardIdSendConfigExM(UFR_HANDLE hndUFR, VAR uint8_t *send_enable, VAR uint8_t *prefix_enable, VAR uint8_t *prefix,
                                                  VAR uint8_t *suffix, VAR uint8_t *send_removed_enable, VAR uint8_t *reverse_byte_order,
                                                  VAR uint8_t *decimal_representation, VAR uint32_t *async_baud_rate);

    /**
    * @brief *uFR Zero series readers only
    * Multi reader support.
    *  Function to set custom RGB UI signalization
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl_M
    *
    * @param hndUFR handle of the uFR device
    * @param idle_mode sets idle mode value
    * @param card_detection_mode sets card detection mode value
    * @param idle_color sets idle color
    * @param card_detection_color sets card detection color
    * @param enabled value that enables it (1) or disables it (0)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetCustomUiConfigM(UFR_HANDLE hndUFR, uint8_t idle_mode, uint8_t card_detection_mode, uint8_t *idle_color, uint8_t *card_detection_color, uint8_t enabled);

    /**
    * @brief *uFR Zero series readers only
    * Multi reader support.
    *  Function to get custom RGB UI signalization
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl_M
    *
    * @param hndUFR handle of the uFR device
    * @param idle_mode returns idle mode value
    * @param card_detection_mode returns card detection mode value
    * @param idle_color returns idle color
    * @param card_detection_color returns card detection color
    * @param enabled returns 1 if enabled, 0 if disabled
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetCustomUiConfigM(UFR_HANDLE hndUFR, uint8_t *idle_mode, uint8_t *card_detection_mode, uint8_t *idle_color, uint8_t *card_detection_color, uint8_t *enabled);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_numberM(UFR_HANDLE hndUFR, VAR uint32_t *card_number);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_right_recordM(UFR_HANDLE hndUFR, uint8_t record_number, uint16_t first_reader_nr, uint16_t last_reader_nr,
                                            uint8_t start_hour, uint8_t start_minute, uint8_t end_hour, uint8_t end_minute, IN uint8_t *days);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_right_recordM(UFR_HANDLE hndUFR, uint8_t record_number, VAR uint16_t *first_reader_nr,
                                            VAR uint16_t *last_reader_nr, VAR uint8_t *start_hour, VAR uint8_t *start_minute,
                                            VAR uint8_t *end_hour, VAR uint8_t *end_minute, OUT uint8_t *days);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_erase_right_recordM(UFR_HANDLE hndUFR, uint8_t record_number);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_validate_recordM(UFR_HANDLE hndUFR, uint8_t begin_year, uint8_t begin_month, uint8_t begin_day,
                                               uint8_t begin_hour, uint8_t begin_minute, uint8_t end_year, uint8_t end_month, uint8_t end_day,
                                               uint8_t end_hour, uint8_t end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_validate_recordM(UFR_HANDLE hndUFR, VAR uint8_t *begin_year, VAR uint8_t *begin_month, VAR uint8_t *begin_day,
                                               VAR uint8_t *begin_hour, VAR uint8_t *begin_minute, VAR uint8_t *end_year,
                                               VAR uint8_t *end_month, VAR uint8_t *end_day, VAR uint8_t *end_hour, VAR uint8_t *end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_card_typeM(UFR_HANDLE hndUFR, uint8_t card_type);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_typeM(UFR_HANDLE hndUFR, VAR uint8_t *card_type);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_card_daily_durationM(UFR_HANDLE hndUFR, uint16_t duration);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_daily_durationM(UFR_HANDLE hndUFR, VAR uint16_t *duration);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_card_total_durationM(UFR_HANDLE hndUFR, uint32_t duration);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_card_total_durationM(UFR_HANDLE hndUFR, VAR uint32_t *duration);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_credit_and_period_validityM(UFR_HANDLE hndUFR, VAR int32_t *credit, VAR uint32_t *begin_year,
                                                          VAR uint32_t *begin_month, VAR uint32_t *begin_day, VAR uint32_t *begin_hour,
                                                          VAR uint32_t *begin_minute, VAR uint32_t *end_year, VAR uint32_t *end_month,
                                                          VAR uint32_t *end_day, VAR uint32_t *end_hour, VAR uint32_t *end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_credit_and_period_validityM(UFR_HANDLE hndUFR, int32_t credit, uint32_t begin_year, uint32_t begin_month,
                                                          uint32_t begin_day, uint32_t begin_hour, uint32_t begin_minute, uint32_t end_year,
                                                          uint32_t end_month, uint32_t end_day, uint32_t end_hour, uint32_t end_minute);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_right_type_recordM(UFR_HANDLE hndUFR, uint8_t record_number, uint8_t right_record_type, IN uint8_t *right_data);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_get_right_type_recordM(UFR_HANDLE hndUFR, uint8_t record_number, VAR uint8_t *right_record_type,
                                                 OUT uint8_t *right_data);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API ais_set_right_record_type_max_daily_counterM(UFR_HANDLE hndUFR, uint8_t record_number, uint16_t first_reader_nr,
                                                                   uint16_t last_reader_nr, uint8_t start_hour, uint8_t start_minute,
                                                                   uint8_t end_hour, uint8_t end_minute, IN uint8_t *days,
                                                                   uint8_t max_daily_counter);

    //=============================================================================

    /**
    * @brief Multi reader support. Electric strike switches when the function is called. Pulse duration determined by function.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR_M
    *
    * @param hndUFR handle of the uFR device
    * @param pulse_duration pulse_duration is strike switch on period in ms
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrXrcLockOnM(UFR_HANDLE hndUFR, uint16_t pulse_duration);

    /**
    * @brief Multi reader support. Function switches relay.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR_M
    *
    * @param hndUFR handle of the uFR device
    * @param state if the state is 1, then relay is switch on, and if state is 0, then relay is switch off
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrXrcRelayStateM(UFR_HANDLE hndUFR, uint8_t state);

    /**
    * @brief Multi reader support. Function returns states of 3 IO pins.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR_M
    *
    * @param hndUFR handle of the uFR device
    * @param intercom shows that there is voltage at the terminals for intercom connection, or not
    * @param door shows that the door's magnetic switch opened or closed
    * @param relay_state is 1 if relay switch on, and 0 if relay switch off
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrXrcGetIoStateM(UFR_HANDLE hndUFR, VAR uint8_t *intercom, VAR uint8_t *door, VAR uint8_t *relay_state);

    /**
    * @brief
    * Multi reader support. Function controls the output pin on the reader.
    *
    * @ingroup ReaderAndLibrary_BaseHDUFR_M
    *
    * @param hndUFR handle of the uFR device
    * @param output_nr ordinal number of hardware specific output pin
    * @param invert 1 output is inverted, 0 output is normal
    * @param cycle_nr Number of on-off cycles. If the cycle number is 0, the output state will be infinite, or until this will be changed with the next function call (output state is 1 if the invert is 0, and 0 if invert is 1).
    * @param on_duration On duration in ms. If the invert is 0 output state is 1, and if invert is 1 output state is 0.
    * @param off_duration Off duration in ms. If the invert is 0 output state is 0, and if invert is 1 output state is 1. This state of the output pin remains after the completion of the on-off cycle.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrOutControlM(UFR_HANDLE hndUFR, uint8_t output_nr, uint8_t invert, uint8_t cycle_nr, uint8_t on_duration, uint8_t off_duration);

    /**
    * @brief Multi reader support. This function turns Red LED only.
    * If “light_status” value is 1, red light will be constantly turned on until receive “light_status “ value 0.
    *
    * @ingroup ReaderAndLibrary_Signalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param light_status value 0 or 1
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRedLightControlM(UFR_HANDLE hndUFR, uint8_t light_status);

    /**
    * @brief Multi reader support. For classic uFR PLUS devices only.
    * The function prohibits the blinking of the green diode (if this option is set), and sets color on RGB diodes. This color stays on diodes until this function sets the parameter "enable"  to 0.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    * @param intensity value of color intensity in percent (0 - 100)
    * @param enable 1 - enable 0 - disable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbLightControlM(UFR_HANDLE hndUFR, uint8_t red, uint8_t green, uint8_t blue, uint8_t intensity, uint8_t enable);

    /**
    * @brief Multi reader support. From version 5.0.55.
    * Before the function calls, the function GreenLedBlinkingTurnOff must be called, or the reader is already in mode of blocking automatic signalization. Function sets the color of the RGB diodes. This color stays on the RGB until the function GreenLedBlinkingTurnOn is called. Intensity of light is defined by a parameter stored using the function SetRgbIntensity.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbControlM(UFR_HANDLE hndUFR, uint8_t red, uint8_t green, uint8_t blue);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbExtLightControlM(UFR_HANDLE hndUFR, uint8_t enable);

    /**
    * @brief Multi reader support. From version 5.0.64.
    * The function sets color on the RGB diodes. This setting will appear when the reader is in sleep mode. Function adjusts the period, and duration of impulse of light. The period is a product of approximately two seconds (2s, 4s, 6s, 8s,...). Maximal duration of impulse of light is 2000 ms.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    * @param intensity value of color intensity in percent (0 - 100)
    * @param period number of the 2 seconds period. (1 = 2s, 2 = 4s, 3 = 6s, …)
    * @param duration duration of impulse of light in ms.
    * @param enable 1 - enable 0 - disable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbLightControlSleepM(UFR_HANDLE hndUFR, uint8_t red, uint8_t green, uint8_t blue, uint8_t intensity,
                                               uint8_t period, uint16_t duration, uint8_t enable);

    /**
    * @brief Multi reader support. From version 5.0.66.
    * The function sets color on the RGB diodes, period of inactivity NFC RF and RGB, and duration of activity NFC RF and RGB. In the inactivity period NFC RF is off, and RGB light is off. In the activity period NFC RF is on, and RGB may be on. Function also sets the number of omitted activity periods, when the RGB light is off. For example if the inactivity period is 400ms, activity duration is 50ms, and number of omitted activity periods is 5, RGB lights will be on 50ms at every 2250ms.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param red value of red color (0 - 255)
    * @param green value of green color (0 - 255)
    * @param blue value of blue color (0 - 255)
    * @param intensity value of color intensity in percent (0 - 100)
    * @param period inactivity period in ms
    * @param duration duration of activity period in ms
    * @param rgb_omitted_cnt number of omitted activity periods
    * @param enable 1 - enable 0 - disable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrRgbLightControlRfPeriodM(UFR_HANDLE hndUFR, uint8_t red, uint8_t green, uint8_t blue, uint8_t intensity,
                                                  uint16_t period, uint16_t duration, uint8_t rgb_omitted_cnt, uint8_t enable);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbIdleSetM(UFR_HANDLE hndUFR, uint8_t red, uint8_t green, uint8_t blue);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbIdleDefaultM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The function allows you to set the number of unsuccessful card selections before it can be considered that the card is not placed on the reader. Period between two card selections is approximately 10ms. Default value of this parameter is 20 i.e. 200ms. This parameter can be set in the range of 0 to 254.
    * This is useful for asynchronous card ID transmission, if parameter send_removed_enable in function SetAsyncCardIdSendConfig is set. Then you can set a lower value of the number of unsuccessful card selections,  in order to send information to the card removed was faster.
    * A small value of this parameter may cause a false report that the card is not present, and immediately thereafter true report that the card is present.
    *
    * @ingroup ReaderAndLibrary_M
    *
    * @param hndUFR handle of the uFR device
    * @param bad_select_nr_max number of unsuccessful card selections
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrSetBadSelectCardNrMaxM(UFR_HANDLE hndUFR, uint8_t bad_select_nr_max);

    /**
    * @brief Multi reader support. The function returns value of maximal unsuccessful card selections, which is set in reader.
    *
    * @ingroup ReaderAndLibrary_M
    *
    * @param hndUFR handle of the uFR device
    * @param bad_select_nr_max pointer to number of unsuccessful card selections
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrGetBadSelectCardNrMaxM(UFR_HANDLE hndUFR, VAR uint8_t *bad_select_nr_max);

    /**
    * @brief Multi reader support. Turn the device into Sleep mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrEnterSleepModeM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Wake up device from Sleep mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API UfrLeaveSleepModeM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Turn the device into Sleep mode after a certain amount of time.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep_M
    *
    * @param hndUFR handle of the uFR device
    * @param seconds_wait variable holding value of seconds to wait before entering into sleep. If the parameter is 0x00, the AutoSleep feature is turned off (default state).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AutoSleepSetM(UFR_HANDLE hndUFR, uint8_t seconds_wait);

    /**
    * @brief Multi reader support. Get status of AutoSleep mode.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_SleepAutoSleep_M
    *
    * @param hndUFR handle of the uFR device
    * @param seconds_wait variable holding value of seconds to wait before entering into sleep. If the parameter is 0x00, the AutoSleep feature is turned off (default state).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API AutoSleepGetM(UFR_HANDLE hndUFR, VAR uint8_t *seconds_wait);

    /**
    * @brief Multi reader support. This function is used for setting communication speed between reader and ISO144443-4 cards. For other card types, a default speed of 106 kbps is in use.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param tx_speed setup value for transmit speed
    * @param rx_speed setup value for receive speed
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetSpeedPermanentlyM(UFR_HANDLE hndUFR, unsigned char tx_speed, unsigned char rx_speed);

    /**
    * @brief Multi reader support. Returns baud rate configured with previous function.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param tx_speed pointer to variable, returns configured value for transmit speed
    * @param rx_speed pointer to variable, returns configured value for receive speed
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetSpeedParametersM(UFR_HANDLE hndUFR, VAR unsigned char *tx_speed, VAR unsigned char *rx_speed);

    /**
    * @brief Multi reader support. Function enables sending data to the display. A string of data contains information about the intensity of color in each cell of the display. Each cell has three LED (red, green and blue). For each cell of the three bytes is necessary. The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. For example, if the display has 16 cells, an array contains 48 bytes. Value of intensity is in range from 0 to 255.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl_M
    *
    * @param hndUFR handle of the uFR device
    * @param display_data pointer to data array
    * @param data_length number of data into array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetDisplayDataM(UFR_HANDLE hndUFR, IN uint8_t *display_data, uint8_t data_length);

    /**
    * @brief Multi reader support. From version 5.0.55
    * Function has the same functionality as the function SetDisplayData. New feature is the RGB port selection. Internal port uses RGB diodes on the reader PCB. Card size reader has two diodes. XL reader has four diodes. External port uses LED RING with RGB diodes.
    * Before the function calls, the function GreenLedBlinkingTurnOff must be called, or the reader is already in mode of blocking automatic signalization. Function sets the color of the RGB diodes. This color stays on the RGB until the function GreenLedBlinkingTurnOn is called. Intensity of light is defined by a parameter stored using the function SetRgbIntensity.
    *
    * @ingroup ReaderAndLibrary_RGBSignalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param display_data pointer to data array
    * @param data_length number of data into array
    * @param port_name EXTERNAL_RGB_PORT INTERNAL_RGB_PORT
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRgbDataM(UFR_HANDLE hndUFR, uint8_t *display_data, uint8_t data_length, uint8_t port_name);

    /**
    * @brief Multi reader support. This function plays constant sound of “frequency” Hertz.
    *
    * @ingroup ReaderAndLibrary_Signalization_M
    *
    * @param hndUFR handle of the uFR device
    * @param frequency frequency in Hz To stop playing sound, send 0 value for “frequency”.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetSpeakerFrequencyM(UFR_HANDLE hndUFR, uint16_t frequency);

    /**
    * @brief Multi reader support. SetRgbIntensity (alias from version 5.0.55)
    * Function sets the intensity of light on the display. Value of intensity is in the range 0 to 100.  This value writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl_M
    *
    * @param hndUFR handle of the uFR device
    * @param intensity value of intensity (0 - 100)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetDisplayIntensityM(UFR_HANDLE hndUFR, uint8_t intensity);

    /**
    * @brief Multi reader support. GetRgbIntensity (alias from version 5.0.55)
    * Function gets the intensity of light on the display.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_DisplayControl_M
    *
    * @param hndUFR handle of the uFR device
    * @param intensity value of intensity (0 - 100)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetDisplayIntensityM(UFR_HANDLE hndUFR, VAR uint8_t *intensity);

    // #############################################################################
    // #############################################################################

    /**
    * @brief Multi reader support. Call SetISO14443_4_Mode() or SetISO14443_4_Mode_GetATS(). ISO 14443-4 tag in a field will be selected and RF field polling will be stopped.
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetISO14443_4_ModeM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Call SetISO14443_4_Mode() or SetISO14443_4_Mode_GetATS(). ISO 14443-4 tag in a field will be selected and RF field polling will be stopped.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param ats After successful function execution, buffer on which this pointer points to will contain ATS returned from the TAG (historical bytes included). Before calling this function, you have to allocate MAX_ATS_LEN bytes for the ats buffer. MAX_ATS_LEN macro is defined in uFCoder.h (#define MAX_ATS_LEN 25).
    * @param ats_len After successful function execution, variable on which this pointer points to will contain actual ATS length.
    * @param uid After successful call to this function, buffer on which this pointer points to will contain TAG UID. Before calling this function, you have to allocate MAX_UID_LEN bytes for the ats buffer. MAX_UID_LEN macro is defined in uFCoder.h (#define MAX_UID_LEN 10).
    * @param uid_len After successful function execution, variable on which this pointer points to will contain actual UID length.
    * @param sak After successful function execution, variable on which this pointer points to will contain SAK (Select Acknowledge) of the TAG in field.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetISO14443_4_Mode_GetATSM(OUT UFR_HANDLE hndUFR, uint8_t ats[MAX_ATS_LEN], VAR uint8_t *ats_len,
                                                 OUT uint8_t uid[MAX_UID_LEN], VAR uint8_t *uid_len, VAR uint8_t *sak);

    /**
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetISO14443_4_DLStorageM(UFR_HANDLE hndUFR);

    /**
    * @brief DEPRECATED
    */
    UFR_STATUS DL_API uFR_i_block_transceiveM(UFR_HANDLE hndUFR, uint8_t chaining, uint8_t timeout, uint8_t block_length,
                                              IN uint8_t *snd_data_array, VAR size_t *rcv_length, OUT uint8_t *rcv_data_array,
                                              VAR uint32_t *ufr_status);
    /**
    * @brief Multi reader support.
    * Used to transmit C-APDU and receive R-APDU packets per defined parameters
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param cls APDU CLA (class byte)
    * @param ins APDU command code (instruction byte)
    * @param p1 parameter byte
    * @param p2 parameter byte
    * @param data_out APDU command data field. Use NULL if data_out_len is 0
    * @param data_out_len number of bytes in the APDU command data field (Lc field)
    * @param data_in buffer for receiving APDU response. There should be allocated at least (send_le + 2) bytes before function call.
    * @param max_data_in_len size of the receiving buffer. If the APDU response exceeded size of buffer, then function returns error
    * @param response_len value of the Le fied if send_le is not 0. After successful execution location pointed by the response_len will contain number of bytes in the APDU response.
    * @param send_le if this parameter is 0 then APDU Le field will not be sent. Otherwise Le field will be included in the APDU message. Value response_len pointed to, before function call will be value of the Le field.
    * @param apdu_status APDU error codes SW1 and SW2 in 2 bytes array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_APDU_TransceiveM(UFR_HANDLE hndUFR, uint8_t cls, uint8_t ins, uint8_t p1, uint8_t p2, IN uint8_t *data_out,
                                           uint8_t data_out_len, OUT uint8_t *data_in, uint32_t max_data_in_len, VAR uint32_t *response_len,
                                           uint8_t send_le, OUT uint8_t *apdu_status);

    /**
    * @brief Multi reader support.
    * Sends C–APDU in the c_string (zero terminated) format, containing pairs of the
       hexadecimal digits. Pairs of the hexadecimal digits can be delimited by any of the punctuation
       characters or white space.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param c_apdu C_APDU as string 
    * @param r_apdu R_APDU returned as string
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUHexStrTransceiveM(UFR_HANDLE hndUFR, IN const char *c_apdu, OUT char **r_apdu);

    /**
    * @brief Multi reader support.
    * Binary alternative function to the APDUHexStrTransceive(). C-APDU and R-APDU are
       sent and receive in the form of the byte arrays. There is obvious need for a c_apdu_len and
      *r_apdu_len parameters which represents length of the *c_apdu and *r_apdu byte arrays,
       respectively
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param c_apdu Array containing the C-APDU
    * @param c_apdu_len length of the c_apdu array
    * @param r_apdu Array containing received R-APDU
    * @param r_apdu_len length of the received r_apdu array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUPlainTransceiveM(UFR_HANDLE hndUFR, IN const uint8_t *c_apdu, uint32_t c_apdu_len, OUT uint8_t *r_apdu,
                                           VAR uint32_t *r_apdu_len);

    /**
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param c_apdu Array containing the C-APDU
    * @param c_apdu_len length of the c_apdu array
    * @param r_apdu Array containing received R-APDU
    * @param r_apdu_len length of the received r_apdu array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUPlainTransceiveToHeapM(UFR_HANDLE hndUFR, IN const uint8_t *c_apdu, uint32_t c_apdu_len, VAR uint8_t **r_apdu, VAR uint32_t *r_apdu_len);

    /**
    * @brief Multi reader support.
    * This is “exploded binary” alternative function intended for support APDU commands in ISO 14443-
       4A tags. APDUTransceive() receives separated parameters which are an integral part of the C–
       APDU. There are parameters cls, ins, p0, p1 of the uint8_t type.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param cls lcs
    * @param ins ins
    * @param p1 p1
    * @param p2 p2
    * @param data_out data_out
    * @param Nc Nc
    * @param data_in data_in
    * @param Ne Ne
    * @param send_le send_le
    * @param apdu_status apdu_status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDUTransceiveM(UFR_HANDLE hndUFR, uint8_t cls, uint8_t ins, uint8_t p1, uint8_t p2, IN const uint8_t *data_out,
                                      uint32_t Nc, OUT uint8_t *data_in, VAR uint32_t *Ne, uint8_t send_le, OUT uint8_t *apdu_status);

    /**
    * @brief Multi reader support.
    * I-block used to convey information for use by the application layer
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param chaining 1 - chaining in use, 0 - no chaining
    * @param timeout timeout for card reply
    * @param block_length inf block length
    * @param snd_data_array pointer to array of data that will be send
    * @param rcv_length length of received data
    * @param rcv_data_array pointer to array of data that will be received
    * @param rcv_chained 1 received packet is chained, 0 received packet is not chained
    * @param ufr_status card operation status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API i_block_trans_rcv_chainM(UFR_HANDLE hndUFR, uint8_t chaining, uint8_t timeout, uint8_t block_length,
                                               IN uint8_t *snd_data_array, VAR uint8_t *rcv_length, OUT uint8_t *rcv_data_array,
                                               VAR uint8_t *rcv_chained, VAR uint32_t *ufr_status);

    /**
    * @brief Multi reader support.
    * R-block used to convey positive or negative acknowledgements. An R-block never contains an INF field. The acknowledgement relates to the last received block.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param ack 1 ACK, 0 NOT ACK
    * @param timeout timeout for card reply
    * @param rcv_length length of received data
    * @param rcv_data_array pointer to array of data that will be received
    * @param rcv_chained 1 received packet is chained, 0 received packet is not chained
    * @param ufr_status card operation status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API r_block_transceiveM(UFR_HANDLE hndUFR, uint8_t ack, uint8_t timeout, VAR uint8_t *rcv_length, OUT uint8_t *rcv_data_array,
                                          VAR uint8_t *rcv_chained, VAR uint32_t *ufr_status);

    /**
    * @brief Multi reader support.
    * Used to deselect tag and restore RF field polling. This call is mandatory after using SetISO14443_4_Mode() and its variants.
    *
    * @ingroup Card_Tag_CardFeatures_ISO144434_4_M
    *
    * @param hndUFR handle of the uFR device
    * @param timeout timeout in [ms]
    *
    * @return Operation status
    */
    UFR_STATUS DL_API s_block_deselectM(UFR_HANDLE hndUFR, uint8_t timeout);

    /**
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param card_activate card_activate
    * @param card_halted card_halted
    * @param tx_crc hardware RF TX crc using (1 - yes, 0 - no)
    * @param rx_crc hardware RF RX crc using (1 - yes, 0 - no)
    * @param crypto1 crypto1
    * @param timeout timeout
    * @param tx_data tx_data
    * @param tx_data_len tx_data_len
    * @param rx_data rx_data
    * @param rx_data_len rx_data_len
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_transceiveM(UFR_HANDLE hndUFR, uint8_t card_activate, uint8_t card_halted, uint8_t tx_crc, uint8_t rx_crc,
                                       uint8_t crypto1, uint32_t timeout, IN uint8_t *tx_data, uint8_t tx_data_len, OUT uint8_t *rx_data,
                                       VAR uint8_t *rx_data_len);

    /**
    * @brief Multi reader support. Function sets the parameters for transceive mode. If the hardware CRC option is used, then only command bytes are sent to the card (hardware will add two bytes of CRC to the end of the RF packet). If this option did not use, then command bytes and two bytes of CRC sent to card  (i.e. ISO14443 typeA CRC). Timeout for card response in us sets.
    * Card is selected and waiting for commands.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode_M
    *
    * @param hndUFR handle of the uFR device
    * @param tx_crc hardware RF TX crc using (1 - yes, 0 - no)
    * @param rx_crc hardware RF RX crc using (1 - yes, 0 - no)
    * @param rf_timeout timeout for card response in us
    * @param uart_timeout timeout for UART response in ms
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_transceive_mode_startM(UFR_HANDLE hndUFR, uint8_t tx_crc, uint8_t rx_crc, uint32_t rf_timeout, uint32_t uart_timeout);

    /**
    * @brief Multi reader support.
    * The function returns the reader to normal mode.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_transceive_mode_stopM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support.
    * Function enables normal working mode of reader, after leaving the transceive working mode with blocking card HALT command in the main loop.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API card_halt_enableM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The function sends data through the serial port to the card.
    *
    * @ingroup Card_Tag_CardFeatures_TransceiveMode_M
    *
    * @param hndUFR handle of the uFR device
    * @param send_data pointer to data array for sending to card
    * @param send_len number of bytes for sending
    * @param rcv_data pointer to data array received from card
    * @param bytes_to_receive expected number of bytes received from card
    * @param rcv_len number of bytes received from card
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uart_transceiveM(UFR_HANDLE hndUFR, IN uint8_t *send_data, uint8_t send_len, OUT uint8_t *rcv_data,
                                       uint32_t bytes_to_receive, VAR uint32_t *rcv_len);

    /**
    * @brief Multi reader support.
    * Function activates the smart card and returns an ATR (Answer To Reset) array of bytes from the smart card.
    * After the successfully executed function, the same APDU commands as for ISO14443-4 tags can be used, but not at the same time.
    * Note. This function is used for NXP SAM AV2 activation, and unlocking if SAM is locked.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @param hndUFR handle of the uFR device
    * @param atr_data pointer to array containing ATR
    * @param atr_len pointer to ATR length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API open_ISO7816_interfaceM(UFR_HANDLE hndUFR, OUT uint8_t *atr_data, VAR uint8_t *atr_len);

    /**
    * @brief Multi reader support.
    * Function activates the smart card and returns an ATR (Answer To Reset) array of bytes from the smart card.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @param hndUFR handle of the uFR device
    * @param atr_data pointer to array containing ATR
    * @param atr_len pointer to ATR length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API Open_ISO7816_GenericM(UFR_HANDLE hndUFR, OUT uint8_t *atr_data, VAR uint8_t *atr_len);

    /**
    * @brief Multi reader support.
    * Function switches the use of APDU to ISO7816 interface. The smart card must be in the active state.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDU_switch_to_ISO7816_interfaceM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support.
    * Function deactivates the smart card. APDU commands are not used.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API close_ISO7816_interface_no_APDUM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support.
    * Function deactivates the smart card. APDU commands are used by ISO 14443-4 tags. Tag must already be in ISO 14443-4 mode.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API close_ISO7816_interface_APDU_ISO14443_4M(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support.
    * Function switches the use APDU to ISO14443-4 tags. The smart card stays in active state. Tag must already be in ISO 14443-4 mode.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDU_switch_to_ISO14443_4_interfaceM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support.
    * APDU commands are not used. The smart card stays in active state.
    *
    * @ingroup Card_Tag_CardFeatures_ISO7816_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API APDU_switch_off_from_ISO7816_interfaceM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support.
    * Using this function you can select the appropriate application on the card. For the DLSigner JCApp AID should be 'F0 44 4C 6F 67 69 63 00 01'. For the DLStorage JCApp AID should be 'F0 44 4C 6F 67 69 63 01 01'. Before calling this function, the NFC tag must be in ISO 14443-4 mode. For entering ISO 14443-4 mode use the SetISO14443_4_Mode() or SetISO14443_4_Mode_GetATS() function.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param aid Pointer to array containing AID (Application ID) i.e: "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01" for the DLSigner or "\xF0\x44\x4C\x6F\x67\x69\x63\x01\x01" for the DLStorage JCApp.
    * @param aid_len Length of the AID in bytes (9 for the DLSigner or DLStorage JCApps).
    * @param selection_response On Application successful selection, the card returns 16 bytes. In the current version only the first of those bytes (i.e. byte with index 0) is relevant and contains JCApp card type which is 0xA0 for actual revision.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSelectByAidM(UFR_HANDLE hndUFR, IN const uint8_t *aid, uint8_t aid_len, OUT uint8_t selection_response[16]);

    /**
    * @brief Multi reader support. In JCApp cards you can put two types of asymmetric crypto keys. Those are RSA and ECDSA private keys, three of each. Before you can use a JCApp card for digital signing you have to put an appropriate private key in it. There is no way to read out private keys from the card.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This feature is disabled in the regular DLSigner JCApp. To acquire cards with this feature enabled you have to contact your supplier with a special request.
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_type 0 for RSA private key and 1 for ECDSA private key.
    * @param key_index For each of the card types there are 3 different private keys that you can set. Their indexes are from 0 to 2.
    * @param key Pointer to array containing key bytes.
    * @param key_bit_len Key length in bits.
    * @param key_param Reserved for future use (RFU). Use null for this parameter.
    * @param key_parm_len Reserved for future use (RFU). Use 0 for this parameter.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPutPrivateKeyM(UFR_HANDLE hndUFR, uint8_t key_type, uint8_t key_index, IN const uint8_t *key, uint16_t key_bit_len,
                                          const IN uint8_t *key_param, uint16_t key_parm_len);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_type key_type
    * @param key_index key_index
    * @param key_designator key_designator
    * @param key_bit_len key_bit_len
    * @param params params
    * @param params_size params_size
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGenerateKeyPairM(UFR_HANDLE hndUFR, uint8_t key_type, uint8_t key_index, uint8_t key_designator,
                                            uint16_t key_bit_len, IN const uint8_t *params, uint16_t params_size);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_index key_index
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppDeleteRsaKeyPairM(UFR_HANDLE hndUFR, uint8_t key_index);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_index key_index
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppDeleteEcKeyPairM(UFR_HANDLE hndUFR, uint8_t key_index);

    /**
    * @brief Multi reader support.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param cipher 0 for the RSA private key and 1 for the ECDSA.
    * @param digest 0 for none digest (not supported with ECDSA) and 1 for SHA1
    * @param padding 0 for none (not supported with RSA) and 1 for pads the digest according to the PKCS#1 (v1.5) scheme.
    * @param key_index For each of the card types there are 3 different private keys that you can set. Their indexes are from 0 to 2.
    * @param chunk Pointer to array containing first chunk of data.
    * @param chunk_len Length of the first chunk of data (max. 255).
    * @param alg_param Reserved for future use (RFU). Use null for this parameter.
    * @param alg_parm_len Reserved for future use (RFU). Use 0 for this parameter.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSignatureBeginM(UFR_HANDLE hndUFR, uint8_t cipher, uint8_t digest, uint8_t padding, uint8_t key_index,
                                           IN const uint8_t *chunk, uint16_t chunk_len, IN const uint8_t *alg_param, uint16_t alg_parm_len);

    /**
    * @brief Multi reader support.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param chunk Pointer to an array containing one of the chunks of data.
    * @param chunk_len Length of the current one of the remaining chunks of data (max. 255).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSignatureUpdateM(UFR_HANDLE hndUFR, IN const uint8_t *chunk, uint16_t chunk_len);

    /**
    * @brief Multi reader support. Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param sig_len Pointer to a 16-bit value in which you will get length of the signature in case of a successful executed chain of function calls, described in the introduction of this topic.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppSignatureEndM(UFR_HANDLE hndUFR, VAR uint16_t *sig_len);

    /**
    * @brief Multi reader support.
    * This function virtually combines three successive calls of functions JCAppSignatureBegin(), JCAppSignatureUpdate() and JCAppSignatureEnd() and can be used in case your data for signing have 255 bytes or less.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * Prior to calling this function you have to be logged in with a User PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param cipher 0 for the RSA private key and 1 for the ECDSA.
    * @param digest 0 for none digest (not supported with ECDSA) and 1 for SHA1
    * @param padding 0 for none (not supported with RSA) and 1 for pads the digest according to the PKCS#1 (v1.5) scheme.
    * @param key_index For each of the card types there are 3 different private keys that you can set. Their indexes are from 0 to 2.
    * @param plain_data Pointer to array containing data for signing.
    * @param plain_data_len Length of the data for signing (max. 255).
    * @param sig_len Pointer to a 16-bit value in which you will get the length of the signature in case of successful execution.
    * @param alg_param Reserved for future use (RFU). Use null for this parameter.
    * @param alg_parm_len Reserved for future use (RFU). Use 0 for this parameter.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGenerateSignatureM(UFR_HANDLE hndUFR, uint8_t cipher, uint8_t digest, uint8_t padding, uint8_t key_index,
                                              IN const uint8_t *plain_data, uint16_t plain_data_len, VAR uint16_t *sig_len,
                                              IN const uint8_t *alg_param, uint16_t alg_parm_len);

    /**
    * @brief Multi reader support.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param obj Pointer to an array containing an object (certificate).
    * @param obj_size Length of the object (certificate).
    * @param id Pointer to an array containing object id. Object id is a symbolic value and has to be unique on the card.
    * @param id_size Length of the object id. Minimum object id length can be 1 and maximum 253.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPutObjM(UFR_HANDLE hndUFR, uint8_t obj_type, uint8_t obj_index, IN uint8_t *obj, int16_t obj_size, IN uint8_t *id,
                                   uint8_t id_size);

    /**
    * @brief Multi reader support.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * Prior to calling of this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param subject Pointer to an array containing subject. Subject is a symbolic value linked to an appropriate certificate by the same obj_type and index.
    * @param size Length of the subject. Maximum subject length is 255.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPutObjSubjectM(UFR_HANDLE hndUFR, uint8_t obj_type, uint8_t obj_index, IN uint8_t *subject, uint8_t size);

    /**
    * @brief Multi reader support.
    * Using this function you can delete certificate objects from a card. This includes subjects linked to a certificate.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppInvalidateCertM(UFR_HANDLE hndUFR, uint8_t obj_type, uint8_t obj_index);

    /**
    * @brief Multi reader support.
    * This function you always have to call 2 times. Before the first call you have to set parameter id to null and you will get the id_size of the obj_type at obj_index. Before the second call you have to allocate an array of the returned id_size bytes and pass that array using parameter id. Before second call, *id_size should be set to a value of the exact bytes allocated.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param id When id == NULL, the function returns id_size.
    * @param id_size Before second call, *id_size should be set to a value of the exact bytes allocated.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetObjIdM(UFR_HANDLE hndUFR, uint8_t obj_type, uint8_t obj_index, OUT uint8_t *id, VAR uint16_t *id_size); // when id == NULL returns size

    /**
    * @brief Multi reader support.
    * This function you always have to call 2 times. Before the first call you have to set the parameter subject to null and you will get the size of the obj_type at obj_index. Before the second call you have to allocate an array of returned size bytes and pass that array using parameter subject. Before second call, *size should be set to a value of the exact bytes allocated.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param subject When subject == NULL, function returns size.
    * @param size Before second call, *size should be set to a value of the exact bytes allocated.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetObjSubjectM(UFR_HANDLE hndUFR, uint8_t obj_type, uint8_t obj_index, OUT uint8_t *subject, VAR uint16_t *size); // when subject == NULL returns size

    /**
    * @brief Multi reader support.
    * This function you always have to call 2 times. Before the first call you have to set parameter id to null and you will get the id_size of the obj_type at obj_index. Before the second call you have to allocate an array of the returned id_size bytes and pass that array using parameter id. Before second call, *id_size should be set to a value of the exact bytes allocated.
    * Before calling this function, NFC tag must be in ISO 14443-4 mode and JCApp should be selected using JCAppSelectByAid() with AID = "\xF0\x44\x4C\x6F\x67\x69\x63\x00\x01".
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    *
    * @param hndUFR handle of the uFR device
    * @param obj_type 0 for certificate containing RSA public key, 1 for certificate containing ECDSA public key and 2 for the CA (certificate authority).
    * @param obj_index For each of the certificates containing RSA or ECDSA public keys there are 3 different corresponding private keys that should be set before placing the certificates themselves. Their indexes are from 0 to 2. For CA there are 12 memory slots so their indexes can be from 0 to 11.
    * @param obj When obj == NULL, function returns size
    * @param size Before second call, *size should be set to a value of the exact bytes allocated.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetObjM(UFR_HANDLE hndUFR, uint8_t obj_type, uint8_t obj_index, OUT uint8_t *obj, int16_t size); // when obj == NULL returns size

    /**
    * @brief Multi reader support.
    * This function is used to login to the JCApp with an appropriate PIN code. Every time you deselect the JCApp tag either by calling s_block_deselect(), ReaderReset(), ReaderClose() or because of the loss of the NFC field, in order to communicate with the same tag you have to select JCApp and login again, using this function.
    * Every successful login resets the incorrectly entered PIN code counter for the PIN code specified by the SO parameter.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common_M
    *
    * @param hndUFR handle of the uFR device
    * @param SO If this parameter has value 0 function will try to login as a User. If this parameter has a value different then 0, the function will try to login as a Security Officer (SO).
    * @param pin Pointer to the array of bytes which contains PIN code.
    * @param pinSize Effective size of the array of bytes which contains PIN code.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppLoginM(UFR_HANDLE hndUFR, uint8_t SO, IN uint8_t *pin, uint8_t pinSize);

    /**
    * @brief Multi reader support. This function is used to get how many of the unsuccessful login attempts remain before specified PIN or PUK code will be blocked.
    * This function have parameter of the type dl_sec_code_t which is defined as:
    * typedef enum {
    * USER_PIN = 0,
    * SO_PIN,
    * USER_PUK,
    * SO_PUK
    * } dl_sec_code_t;
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common_M
    *
    * @param hndUFR handle of the uFR device
    * @param secureCodeType Specifies the PIN code type (see the dl_sec_code_t type definition above, in the text)
    * @param triesRemaining Pointer to the 16-bit unsigned integer which will contain the number of the unsuccessful login attempts remains before specified PIN code will be blocked, in case of successful function execution. If this value is 0 then the specified PIN code is blocked.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetPinTriesRemainingM(UFR_HANDLE hndUFR, dl_sec_code_t secureCodeType, VAR uint16_t *triesRemaining);

    /**
    * @brief Multi reader support. This function is used to change the PIN or PUK code which type is specified with secureCodeType parameter of type dl_sec_code_t which is defined as:
    * typedef enum {
    * USER_PIN = 0,
    * SO_PIN,
    * USER_PUK,
    * SO_PUK
    * } dl_sec_code_t;
    * Prior to calling this function you have to be logged in with an SO PIN code.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common_M
    *
    * @param hndUFR handle of the uFR device
    * @param secureCodeType Specifies the PIN or PUK code type you wish to change (see the dl_sec_code_t type definition above, in the text)
    * @param newPin Pointer to the array of bytes which contains a new code
    * @param newPinSize Effective size of the array of bytes which contains a new code.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinChangeM(UFR_HANDLE hndUFR, dl_sec_code_t secureCodeType, IN uint8_t *newPin, uint8_t newPinSize);

    /**
    * @brief Multi reader support.
    * This function is used to unblock PIN code which is specified by the SO parameter.
    * This function does not require to be logged in with any of the PIN codes.
    *
    * @ingroup Card_Tag_JavaCardApplication_Common_M
    *
    * @param hndUFR handle of the uFR device
    * @param SO If this parameter has value 0 function will try to unblock User PIN code. If this parameter has a value different then 0, the function will try to unblock SO PIN code.
    * @param puk Pointer to the array of bytes which contains PUK code.
    * @param pukSize Effective size of the array of bytes which contains PUK code.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinUnblockM(UFR_HANDLE hndUFR, uint8_t SO, IN uint8_t *puk, uint8_t pukSize);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_Common_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param SO SO
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinEnableM(UFR_HANDLE hndUFR, uint8_t SO);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_Common_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param SO SO
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppPinDisableM(UFR_HANDLE hndUFR, uint8_t SO);

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_index key_index
    * @param modulus modulus
    * @param modulus_size modulus_size
    * @param exponent exponent
    * @param exponent_size exponent_size
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetRsaPublicKeyM(UFR_HANDLE hndUFR, uint8_t key_index, OUT uint8_t *modulus, VAR uint16_t *modulus_size,
                                            OUT uint8_t *exponent, VAR uint16_t *exponent_size); // when modulus == NULL, returns sizes and exponent ignored

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_index key_index
    * @param keyW keyW
    * @param keyWSize keyWSize
    * @param field field
    * @param field_size field_size
    * @param ab ab
    * @param ab_size ab_size
    * @param g g
    * @param g_size g_size
    * @param r r
    * @param r_size r_size
    * @param k k
    * @param key_size_bits key_size_bits
    * @param key_designator key_designator
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetEcPublicKeyM(UFR_HANDLE hndUFR, uint8_t key_index, OUT uint8_t *keyW, VAR uint16_t *keyWSize, OUT uint8_t *field,
                                           VAR uint16_t *field_size, OUT uint8_t *ab, VAR uint16_t *ab_size, OUT uint8_t *g,
                                           VAR uint16_t *g_size, OUT uint8_t *r, VAR uint16_t *r_size, VAR uint16_t *k,
                                           VAR uint16_t *key_size_bits, VAR uint16_t *key_designator); // when keyW == NULL, returns size

    /**
    *
    * @ingroup Card_Tag_JavaCardApplication_PKIAndDigitalSignature_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_index key_index
    * @param key_size_bits key_size_bits
    * @param key_designator key_designator
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCAppGetEcKeySizeBitsM(UFR_HANDLE hndUFR, uint8_t key_index, VAR uint16_t *key_size_bits, VAR uint16_t *key_designator);

    //------------------------------------------------------------------------------

    /**
    * @brief Multi reader support.
    * This function has to be called before JCStorageListFiles() to acquire the size of the array of bytes needed to be allocated for the list of currently existing files on the DLStorage card. Maximum files on the DLStorage card is 16.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param list_size Pointer to the 32-bit unsigned integer which will contain the size of the array of bytes needed to be allocated prior to calling the JCStorageListFiles() function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageGetFilesListSizeM(UFR_HANDLE hndUFR, VAR uint32_t *list_size);

    /**
    * @brief Multi reader support.
    * After calling the JCStorageGetFilesListSize() function and getting the size of the list of the currently existing files on the DLStorage card, and if the list size is greater than 0, you can allocate a convenient array of bytes and then call this function. On successful function execution, the array pointed by the list parameter will contain indexes of the existing files on the card. Maximum files on the DLStorage card is 16. Each byte of the array pointed by the list parameter contains a single index of the existing file on the DLStorage card.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param list Pointer to the allocated array of bytes of the size acquired by the previous call to JCStorageGetFilesListSize() function.
    * @param list_bytes_allocated Size of the array of bytes pointed by the list parameter. Have to be equal to the value of the *list_size acquired by the previous call to JCStorageGetFilesListSize() function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageListFilesM(UFR_HANDLE hndUFR, OUT uint8_t *list, uint32_t list_bytes_allocated);

    /**
    * @brief Multi reader support.
    * This function returns file size indexed by the parameter card_file_index, on successful execution. Returned file size is in bytes. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. You have to know file size to allocate an appropriate amount of data prior to calling the JCStorageReadFile() function.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param card_file_index It should contain an index of the file which size we want to get
    * @param file_size Pointer to the 32-bit unsigned integer which will contain size in bytes of the file having card_file_index.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageGetFileSizeM(UFR_HANDLE hndUFR, uint8_t card_file_index, VAR uint32_t *file_size);

    /**
    * @brief Multi reader support.
    * After calling the JCStorageGetFileSize() function and getting the size of the file on the DLStorage card you can allocate a convenient array of bytes and then call this function. On successful function execution, the array pointed by the data parameter will contain file content. If the file with the index defined by the card_file_index parameter does not exist, the function will return UFR_APDU_SW_FILE_NOT_FOUND (0x000A6A82) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param card_file_index It should contain an index of the file we want to read.
    * @param data Pointer to the allocated array of bytes of the size acquired by the previous call to JCStorageGetFileSize() function.
    * @param data_bytes_allocated d Size of the array of bytes pointed by the data parameter. Have to be equal to the value of the *file_size acquired by the prior calling JCStorageGetFileSize() function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageReadFileM(UFR_HANDLE hndUFR, uint8_t card_file_index, OUT uint8_t *data, uint32_t data_bytes_allocated);

    /**
    * @brief Multi reader support.
    * This function reads a file from the DLStorage card directly to the new file on the host file-system. If the file on the host file system already exists, it will be overwritten. If the file with the index defined by the card_file_index parameter does not exist, the function will return UFR_APDU_SW_FILE_NOT_FOUND (0x000A6A82) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param card_file_index It should contain an index of the file we want to read.
    * @param file_system_path_name Pointer to the null-terminated string that should contain path and the name of the new file on the host file-system which will contain the data read from the file on the card in case of successful function execution.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageReadFileToFileSystemM(UFR_HANDLE hndUFR, uint8_t card_file_index, IN const char *file_system_path_name);

    /**
    * @brief Multi reader support.
    * This function creates a file on the DLStorage card and writes an array of bytes pointed by the data parameter to it. Parameter data_size defines the amount of data to be written in the file on the DLStorage card. If the file with the index defined by the card_file_index parameter already exists on the card, the function will return UFR_APDU_SW_ENTITY_ALREADY_EXISTS (0x000A6A89) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. If there is an error during the writing procedure, for example because of the loss of the NFC field and the file is only partially written (tearing event), a corrupted file on the DLStorage card should be deleted and then written again. Therefore we suggest you to always do verification of the data written to the card.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param card_file_index It should contain an index of the file we want to create and write data to it.
    * @param data Pointer to the data i.e. array of bytes to be written into the new file on the card.
    * @param data_size Size, in bytes, of the data to be written into the file on the card.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageWriteFileM(UFR_HANDLE hndUFR, uint8_t card_file_index, IN const uint8_t *data, uint32_t data_size);

    /**
    * @brief Multi reader support.
    * This function writes file content from the host file-system to the new file on the DLStorage card. If the file with the index defined by the card_file_index parameter already exists on the card, the function will return UFR_APDU_SW_ENTITY_ALREADY_EXISTS (0x000A6A89) error code. Maximum files on the DLStorage card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. If there is an error during the writing procedure, for example because of the loss of the NFC field and the file is only partially written (tearing event), a corrupted file on the DLStorage card should be deleted and then written again. Therefore we suggest you to always do verification of the data written to the card.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param card_file_index It should contain an index of the file on the card we want to create and write content of the file from the host file-sistem to it.
    * @param file_system_path_name Pointer to the null-terminated string that should contain path and the name of the file from the host file-sistem whose content we want to transfer to the new file on the card.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageWriteFileFromFileSystemM(UFR_HANDLE hndUFR, uint8_t card_file_index, IN const char *file_system_path_name);

    /**
    * @brief Multi reader support.
    * After successful call to this function, the file on the DLStorage card will be deleted. Maximum files on the card is 16 and file indexes are zero-based so indexes can be in the range of 0 to 15. If a file with index defined by the file_index parameter does not exist, the function will return UFR_APDU_SW_FILE_NOT_FOUND (0x000A6A82) error code.
    *
    * @ingroup Card_Tag_JavaCardApplication_DLStorage_M
    *
    * @param hndUFR handle of the uFR device
    * @param file_index It should contain an index of the file we want to delete.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API JCStorageDeleteFileM(UFR_HANDLE hndUFR, uint8_t file_index);

    //------------------------------------------------------------------------------

    /**
    * @brief Multi reader support.
    * Use this function to authenticate to the eMRTD NFC tag using BAC. This function establishes a security channel for communication. Security channel is maintained using send_sequence_cnt parameter and channel session keys are ksenc (for encryption) and ksmac (for calculating MAC).
    *
    * @ingroup Card_Tag_CardFeatures_MRTD_M
    *
    * @param hndUFR handle of the uFR device
    * @param mrz_proto_key MRZ proto-key acquired using prior call to MRTD_MRZDataToMRZProtoKey() or MRTD_MRZSubjacentToMRZProtoKey() function.
    * @param ksenc This array must have allocated at least 16 bytes prior to calling this function. This array will contain a session encryption key after successful function execution.
    * @param ksmac This array must have allocated at least 16 bytes prior to calling this function. This array will contain a session key for calculating MAC after successful function execution.
    * @param send_sequence_cnt After successful execution of this function, the pointer to this 64-bit value should be saved and forwarded at every subsequent call to MRTDFileReadBacToHeap() and/or other functions for reading eMRTD.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDAppSelectAndAuthenticateBacM(UFR_HANDLE hndUFR, IN const uint8_t mrz_proto_key[25], OUT uint8_t ksenc[16],
                                                       OUT uint8_t ksmac[16], VAR uint64_t *send_sequence_cnt);

    /**
    * @brief Multi reader support.
    * Use this function to read files from the eMRTD NFC tag. You can call this function only after successfully established security channel by the previously called
    * MRTDAppSelectAndAuthenticateBac() function. Session keys ksenc and ksmac, and also parameter send_sequence_cnt are acquired by the previously called
    * MRTDAppSelectAndAuthenticateBac() function. After the successful call to this function, *output points to the file data read from an eMRTD file specified by the file_index parameter. Buffer, in which the data is stored, is automatically allocated on the memory heap during function execution. Maximum amount of data allocated can be 32KB. User is obligated to cleanup allocated data space, occupied by the *output, after use (e.g. by calling DLFree() or directly free() from the C/C++ code).
    *
    * @ingroup Card_Tag_CardFeatures_MRTD_M
    *
    * @param hndUFR handle of the uFR device
    * @param file_index file index
    * @param output buffer that storese output
    * @param output_length length of the returned output
    * @param ksenc This array must have allocated at least 16 bytes prior to calling this function. This array will contain a session encryption key after successful function execution.
    * @param ksmac This array must have allocated at least 16 bytes prior to calling this function. This array will contain a session key for calculating MAC after successful function execution.
    * @param send_sequence_cnt send_sequence_cnt
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDFileReadBacToHeapM(UFR_HANDLE hndUFR, IN const uint8_t *file_index, VAR uint8_t **output, OUT uint32_t *output_length,
                                             IN const uint8_t ksenc[16], IN const uint8_t ksmac[16], VAR uint64_t *send_sequence_cnt);

    /**
    * @brief Multi reader support.
    * This function validates data groups read from the eMRTDocument. All the elements needed for a validation are recorded into the eMRTD and additional CSCA certificate (Country Signing Certificate Authority). During function execution, hash values of the data groups are validated. Data groups hash values have to be the same as those values embedded in the SOD file which is signed by the private key corresponding to the DS certificate. The DS certificate has to be included in the SOD file too. SOD content is a special case of the PKCS#7 ASN.1 DER encoded structure. Finally, DS certificate signature is validated by the external CSCA certificate which is proof of the valid certificates chain of thrust.
    * The countries provided their CSCA certificates on the specialized Internet sites. CSCA certificates can be in PEM (base64 encoded) or binary files (there having extensions such as PEM, DER, CER, CRT…). Some countries have Master List files that include certificates from other countries with which they have bilateral agreements. Those Master List files have an “.ml” file extension. Additionally, the ICAO Public Key Directory (PKD) is a central repository for exchanging the information required to authenticate ePassports. For more details you can visit the ICAO PKD web site.
    * ________________
    *
    * @ingroup Card_Tag_CardFeatures_MRTD_M
    *
    * @param hndUFR handle of the uFR device
    * @param cert_storage_folder Pointer to the zero terminated string which should contains path to the folder containing CSCA certificates and/or ICAO Master List files.
    * @param out_str After successful function execution, this pointer will point to the pointer on the zero terminated string containing verbose printout of the validation steps. Various printout details are determined by the value of the verbose_level function parameter.
    * @param endln Pointer to the zero terminated string which contains the new line escape sequence for the target system. In the general case it should be "\n" but on some systems can be "\r" or "\r\n".
    * @param verbose_level One of the values defined in the E_PRINT_VERBOSE_LEVELS enumeration: enum E_PRINT_VERBOSE_LEVELS {  PRINT_NONE,  PRINT_ESSENTIALS,  PRINT_DETAILS,  PRINT_ALL_PLUS_STATUSES, };
    * @param ksenc Session encryption key acquired using prior call to MRTDAppSelectAndAuthenticateBac() function.
    * @param ksmac Session key for calculating MAC acquired using prior call to MRTDAppSelectAndAuthenticateBac() function.
    * @param send_sequence_cnt This pointer should point to a 64-bit value initialized by the previously successful call to MRTDAppSelectAndAuthenticateBac() function. Pointer to this 64-bit value should be saved and forwarded at every subsequent call to this function and/or other functions used for reading eMRTD.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MRTDValidateM(UFR_HANDLE hndUFR, IN const char *cert_storage_folder, VAR char **out_str, IN const char *endln,
                                    uint32_t verbose_level, OUT uint8_t ksenc[16], OUT uint8_t ksmac[16], VAR uint64_t *send_sequence_cnt);
    // #############################################################################

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_DESFIRE_Start(void);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_DESFIRE_StartM(UFR_HANDLE hndUFR);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_DESFIRE_Stop(void);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_DESFIRE_StopM(UFR_HANDLE hndUFR);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_APDU_Start(void); // Alias for uFR_DESFIRE_Start()
    /**
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_APDU_StartM(UFR_HANDLE hndUFR); // Alias for uFR_DESFIRE_StartM()
    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_APDU_Stop(void); // Alias for uFR_DESFIRE_Stop()
    /**
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_APDU_StopM(UFR_HANDLE hndUFR); // Alias for uFR_DESFIRE_StopM()

    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUidM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                             VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 128 bit AES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                 VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 64 bit DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, OUT uint8_t *card_uid,
                                                 VAR uint8_t *card_uid_len, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 128 bit 2K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                    OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 192 bit 3K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_3k3desM(UFR_HANDLE hndUFR, IN uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                    OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * Provided Key mode (PK)
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                 OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                 VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 128 bit AES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                     OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                     VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 64 bit DES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                     OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                     VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 128 bit 2K3DES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                        OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * 192 bit 3K3DES key provided key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_GetDesfireUid_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                        OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUidAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                    OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUid3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                       OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUidDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                    OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief This function returns Unique ID of card, if the Random ID is used.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Mifare Desfire EV1 card can be configured to use Random ID numbers instead Unique ID numbers during anti-collision procedure. In this case card uses single anti-collision loop, and returns Random Number Tag 0x08 and 3 bytes Random Number (4 bytes Random ID). 
    * From library version 5.0.29. and firmware version 5.0.32, Desfire Light card supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_nr key number into application (0 for card master key or application master key)
    * @param card_uid pointer to array containing card UID
    * @param card_uid_len pointer to card UID length variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_GetDesfireUid2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                       OUT uint8_t *card_uid, VAR uint8_t *card_uid_len, VAR uint16_t *card_status,
                                                       VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Function returns the available bytes on the card.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param free_mem_byte pointer to free memory size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFreeMemM(UFR_HANDLE hndUFR, VAR uint32_t *free_mem_byte, VAR uint16_t *card_status,
                                              VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCardM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 128 bit AES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 64 bit DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 128 bit 2K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 192 bit 3K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * Provided Key mode (PK)
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, VAR uint16_t *card_status,
                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 128 bit AES key provided key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 64 bit DES key provided key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 128 bit 2K3DES key provided key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * 192 bit 3K3DES key provided key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireFormatCard_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 128 bit AES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCardAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCard3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 64 bit DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCardDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function releases all allocated user memory on the card.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * All applications will be deleted, also all files within those applications will be deleted. Only the card master key, and card master key settings will not be deleted. This operation requires authentication with the card master key.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireFormatCard2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                        uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                        uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                            uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                            uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                            uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                            uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                               uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                               uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                               uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                               uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                            uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                            uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key provided key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key provided key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                                uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key provided key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key provided key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                               uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                               uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no,
                                                                  uint8_t communication_settings, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                               uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                               uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no,
                                                                  uint8_t communication_settings, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. No authentication
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [a]
    * @param write_key_no key for writing [b]
    * @param read_write_key_no key for reading and writing [c]
    * @param change_key_no key for changing this setting [d]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                 uint8_t change_key_no, uint8_t communication_settings,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. From library version 5.0.96, and firmware version 5.0.81.
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [i]
    * @param write_key_no key for writing [j]
    * @param read_write_key_no key for reading and writing [k]
    * @param change_key_no key for changing this setting [l]
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_isoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);
    /**
    * @brief Multi reader support.
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication 	communication settings value is 0x00
    * - plain communication secured by MACing 	communication settings value is 0x01
    * - fully enciphered communication		communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 – 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    * Secure Dynamic Message can be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_iso_sdmM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                    uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);
    /**
    * @brief Multi reader support.
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_des_isoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3des_isoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                   uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3des_isoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                   uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * From library version 5.0.96, and firmware version 5.0.81.
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [i]
    * @param write_key_no key for writing [j]
    * @param read_write_key_no key for reading and writing [k]
    * @param change_key_no key for changing this setting [l]
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                    uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                    uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * From library version 5.0.96, and firmware version 5.0.81.
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication 	communication settings value is 0x00
    * - plain communication secured by MACing 	communication settings value is 0x01
    * - fully enciphered communication		communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 – 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    * Secure Dynamic Message can be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [i]
    * @param write_key_no key for writing [j]
    * @param read_write_key_no key for reading and writing [k]
    * @param change_key_no key for changing this setting [l]
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_aes_iso_sdm_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                        uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                        uint8_t read_write_key_no, uint8_t change_key_no,
                                                                        uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                        VAR uint16_t *exec_time);
    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                                    uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                    uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Provided Key mode (PK)
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_2k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id,
                                                                       uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                       uint8_t read_write_key_no, uint8_t change_key_no,
                                                                       uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Provided Key mode (PK)
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_3k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id,
                                                                       uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                       uint8_t read_write_key_no, uint8_t change_key_no,
                                                                       uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileAesAuthIsoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Desfire EV3 only.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication 	communication settings value is 0x00
    * - plain communication secured by MACing 	communication settings value is 0x01
    * - fully enciphered communication		communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 – 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    * Secure Dynamic Message can be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileAesAuthIsoSdmM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                     uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                     uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings. Communication settings define communication mode between reader and card. The communication modes are: - plain communication communication settings value is 0x00 - plain communication secured by MACing communication settings value is 0x01 - fully enciphered communication communication settings value is 0x03 Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only). ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile3k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                     uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                     uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings. Communication settings define communication mode between reader and card. The communication modes are: - plain communication communication settings value is 0x00 - plain communication secured by MACing communication settings value is 0x01 - fully enciphered communication communication settings value is 0x03 Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only). ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFileDesAuthIsoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings. Communication settings define communication mode between reader and card. The communication modes are: - plain communication communication settings value is 0x00 - plain communication secured by MACing communication settings value is 0x01 - fully enciphered communication communication settings value is 0x03 Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only). ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateStdDataFile2k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                     uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                     uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, uint16_t iso_file_id, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. From library version 5.0.96, and firmware version 5.0.81.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * ISO/IEC 7816-4 File ID for the file to be created.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param iso_file_id ISO/IEC 7816-4 File ID for the file to be created
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateStdDataFile_no_auth_isoM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings, uint16_t iso_file_id,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                               uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                               uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                               uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                               uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                                   uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                   uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id,
                                                                      uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                      uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id,
                                                                      uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                      uint8_t read_write_key_no, uint8_t change_key_no,
                                                                      uint8_t communication_settings, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                     uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                     uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                  uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                  uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateBackupDataFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                     uint32_t file_size, uint8_t read_key_no, uint8_t write_key_no,
                                                                     uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. No authentication
    * From library version 5.0.96, and firmware version 5.0.79.
    * Function allows to create a file for the storage of unformatted user data within an existing application on the card. Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing         communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain keys within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If the value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    * Due to the mirror image a BackupDataFile  always consumes double quantity of the card’s memory compared to a StandardDataFile with the same specified file size.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param file_size file size in bytes
    * @param read_key_no key for reading [m]
    * @param write_key_no key for writing [n]
    * @param read_write_key_no key for reading and writing [o]
    * @param change_key_no key for changing this setting [p]
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateBackupDataFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, uint32_t file_size,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                    uint8_t change_key_no, uint8_t communication_settings,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support.
    * 128 bit AES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support.
    * 64 bit DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * 128 bit 2K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * 192 bit 3K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * Provided Key mode (PK)
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * 128 bit AES key provided key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * 64 bit DES key provided key
    * Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * 128 bit 2K3DES key provided key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * 192 bit 3K3DES key provided key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support. 
    * *only uFR CS with SAM support
    * 128 bit AES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 64 bit DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function deactivates a file within the currently selected application.
    * 
    * Multi reader support.
    * No authentication
    * Allocated memory blocks associated with deleted file not set free. Only format card function can delete the memory blocks. Is the application master key authentication is required, depending on the application master key settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplicationM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                           uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                               uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                               uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                               uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                               uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                               uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);
    /**
    * @brief Multi reader support. 128 bit AES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit AES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                      uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                         uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                         VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 192 bit 3K3DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                      uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                      uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                         uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                         VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                      uint8_t setting, uint8_t max_key_no, VAR uint16_t *card_status,
                                                                      VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 64 bit DES key provided key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                  uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. No authentication
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. No authentication
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. No authentication
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_isoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no,
                                                                   uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aes_isoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aes_isoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no,
                                                                   uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3des_isoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3des_isoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                         uint8_t max_key_no,
                                                                         uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3des_isoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3des_isoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3des_isoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                         uint8_t max_key_no,
                                                                         uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3des_isoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_des_isoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no,
                                                                   uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_des_isoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                      uint8_t max_key_no,
                                                                      uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_des_isoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                   uint8_t max_key_no,
                                                                   uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    // 121212
    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                                       uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief From library version 5.0.97, and firmware version 5.0.81.
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_aes_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                                          uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_aes_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                                       uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_3k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                          uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                          VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_3k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                             uint8_t setting, uint8_t max_key_no,
                                                                             uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                             VAR uint16_t *card_status,
                                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_3k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                          uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                          VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_2k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                          uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                          VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_2k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                             uint8_t setting, uint8_t max_key_no,
                                                                             uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                             VAR uint16_t *card_status,
                                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    *  ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_2k3des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                          uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                          VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                                       uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                                          uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_des_iso_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                                       uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    * Application specific Capability data enabled.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationAesAuthIsoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief From library version 5.0.97, and firmware version 5.0.81.
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationAesAuthIsoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationAesAuthIsoM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication3k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication3k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                           uint8_t max_key_no,
                                                                           uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication3k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationDesAuthIsoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplicationDesAuthIsoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplicationDesAuthIsoM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                                     uint8_t max_key_no,
                                                                     uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplication2k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreate3k3desApplication2k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                           uint8_t max_key_no,
                                                                           uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateDesApplication2k3desAuthIsoM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                        uint8_t max_key_no,
                                                                        uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_no_auth_isoM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreate3k3desApplication_no_auth_isoM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                          uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name pointer to ISO/IEC 7816-4 DF Name array
    * @param iso_df_name_len length of the ISO/IEC 7816-4 DF Name array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateDesApplication_no_auth_isoM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                       uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create a new application on the card. 
    * 
    * If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    * Application specific Capability data enabled.
    * Multi reader support
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name ISO/IEC 7816-4 DF (Dedicated File) name
    * @param iso_df_name_len DF name length
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateAesApplication_aes_iso_ascd_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                            uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support
    * Function allows to create a new application on the card. If the card master key authentication is required, depending on the card master key settings. Maximal number of applications on the card is 28. Each application is linked to a set of up 14 different user definable access keys.
    * ISO/IEC 7816-4 File Identifier, and ISO/IEC 7816-4 DF Name for this application must be defined.
    * Application specific Capability data enabled.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param setting application master key settings
    * @param max_key_no maximal number of keys into application (1 to 14)
    * @param iso_file_id ISO/IEC 7816-4 File Identifier
    * @param iso_df_name ISO/IEC 7816-4 DF (Dedicated File) name
    * @param iso_df_name_len DF name length
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateAesApplicationAesAuthIsoAscdM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting, uint8_t max_key_no,
                                                                         uint16_t iso_file_id, IN uint8_t *iso_df_name, uint8_t iso_df_name_len,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplicationM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 
    * 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_AesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplicationDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr  ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplicationd2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Function allows to deactivate application on the card.
    * 
    * Multi reader support. 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. Provided Key mode (PK)
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. 128 bit AES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. 64 bit DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid,
                                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDeleteApplication_app_master_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_AesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid,
                                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_DesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, VAR uint16_t *card_status,
                                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to deactivate application on the card. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Is the authentication with card master key or with the application master key is required, depending on the card master key settings. AID allocation is removed, but deleted memory blocks can only recovered by using Format card function.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDeleteApplication_app_master_2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid,
                                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfigurationM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 128 bit AES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 64 bit DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 128 bit 2K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint8_t random_uid,
                                                              uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 192 bit 3K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint8_t random_uid,
                                                              uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. Provided Key mode (PK)
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t random_uid,
                                                           uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 128 bit AES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t random_uid,
                                                               uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 64 bit DES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint8_t random_uid,
                                                               uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint8_t random_uid,
                                                                  uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetConfiguration_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint8_t random_uid,
                                                                  uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfigurationAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfiguration3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint8_t random_uid,
                                                                 uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfigurationDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint8_t random_uid, uint8_t format_disable,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to activate the Random ID option, and/or Format disable option.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * If these options are activated, then they can not be returned to the factory setting (Random ID disabled, Format card enabled). This operation requires authentication with the card master key.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param random_uid 0 - Random ID disabled, 1 - Random ID enabled
    * @param format_disable 0 - Format enabled, 1 - Format disabled
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetConfiguration2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint8_t random_uid,
                                                                 uint8_t format_disable, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting application key settings
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettingsM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                     VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 128 bit AES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting application key settings
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                         VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 64 bit DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                         VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                            VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                            VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, VAR uint8_t *setting,
                                                         VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, VAR uint8_t *setting,
                                                             VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, VAR uint8_t *setting,
                                                             VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                VAR uint8_t *setting, VAR uint8_t *max_key_no, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                VAR uint8_t *setting, VAR uint8_t *max_key_no, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettingsAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                            VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettings3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                               VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettingsDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                            VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetKeySettings2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, VAR uint8_t *setting,
                                                               VAR uint8_t *max_key_no, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to get card master key and application master key configuration settings. 
    * 
    * Multi reader support. No authentication
    * In addition it returns the maximum number of keys which can be stored within the selected application. Is authentication with the master key required, depending on the master key setting.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param max_key_no maximum number of keys within selected application
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetKeySettings_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid,
                                                              VAR uint8_t *setting, VAR uint8_t *max_key_no,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. Function allows to set card master key, and application master key configuration settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettingsM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. Provided Key mode (PK)
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t setting,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t setting,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t setting,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeKeySettings_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t setting,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 
    * *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettingsAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t setting,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 
    * *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettings3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t setting,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 
    * *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettingsDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t setting,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to set card master key, and application master key configuration settings.
    * 
    * Multi reader support. 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param setting pointer to settings variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeKeySettings2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t setting,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card.
    * 
    * Multi reader support. 
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr  ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key 16 bytes array that represent AES key
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key 16 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKeyM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                   IN uint8_t new_aes_key[16], uint8_t aid_key_no, IN uint8_t old_aes_key[16],
                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card. 
    * 
    * Multi reader support.
    * 128 bit AES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key_nr ordinal number of AES key in the reader
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key_nr ordinal number of AES key in the reader
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                       uint8_t new_aes_key_nr, uint8_t aid_key_no, uint8_t old_aes_key_nr,
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);
    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * Multi reader support. 64 bit DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr key index of DES key stored in the reader that will be new DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_desM(UFR_HANDLE hndUFR, uint8_t auth_des_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                       uint8_t new_des_key_nr, uint8_t aid_key_no, uint8_t old_des_key_nr,
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * Multi reader support. 64 bit DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des_key_nr ordinal number of authentication DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key_nr key index of 2K3DES key stored in the reader that will be new 2K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key_nr key index of 2K3DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_desM(UFR_HANDLE hndUFR, uint8_t auth_des_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                          uint8_t new_2k3des_key_nr, uint8_t aid_key_no, uint8_t old_2k3des_key_nr,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des2k_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr index of DES key stored in the reader that will be new DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_2k3desM(UFR_HANDLE hndUFR, uint8_t auth_des2k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                          uint8_t new_des_key_nr, uint8_t aid_key_no, uint8_t old_des_key_nr,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des2k_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key_nr key index of 2K3DES key stored in the reader that will be new 2K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key_nr key index of 2K3DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_2k3desM(UFR_HANDLE hndUFR, uint8_t auth_des2k_key_nr, uint32_t aid,
                                                             uint8_t aid_key_no_auth, uint8_t new_2k3des_key_nr, uint8_t aid_key_no,
                                                             uint8_t old_2k3des_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 3K3DES key on the card.
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des3k_key_nr ordinal number of authentication 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_3k3des_key_nr key index of 3K3DES key stored in the reader that will be new 3K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_3k3des_key_nr key index of 3K3DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange3K3DesKey_3k3desM(UFR_HANDLE hndUFR, uint8_t auth_des3k_key_nr, uint32_t aid,
                                                             uint8_t aid_key_no_auth, uint8_t new_3k3des_key_nr, uint8_t aid_key_no,
                                                             uint8_t old_3k3des_key_nr, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change master key of the card from any type to any type.
    * 
    * Multi reader support. Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_nr ordinal number of key in the reader
    * @param auth_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param new_key_nr key index of the key stored in the reader
    * @param new_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeMasterKeyM(UFR_HANDLE hndUFR, uint8_t auth_key_nr, uint8_t auth_key_type, uint8_t new_key_nr,
                                                      uint8_t new_key_type, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card.
    * 
    * Multi reader support. Provided Key mode (PK)
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key 16 bytes array that represent AES key
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key 16 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_no_auth,
                                                       IN uint8_t new_aes_key[16], uint8_t aid_key_no, IN uint8_t old_aes_key[16],
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card.
    * 
    * Multi reader support. 128 bit AES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key 16 bytes array that represent AES key
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key 16 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeAesKey_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_no_auth,
                                                           IN uint8_t new_aes_key[16], uint8_t aid_key_no, IN uint8_t old_aes_key[16],
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * Multi reader support. 64 bit DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des_key pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key 8 bytes array that represent DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key 8 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_des_key, uint32_t aid, uint8_t aid_key_no_auth,
                                                           IN uint8_t new_des_key[8], uint8_t aid_key_no, IN uint8_t old_des_key[8],
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * Multi reader support. 64 bit DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des_key pointer to 8 bytes array containing the DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key 16 bytes array that represent 2K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key 16 bytes array that represent current 2K3DES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_des_key, uint32_t aid,
                                                              uint8_t aid_key_no_auth, IN uint8_t new_2k3des_key[16], uint8_t aid_key_no,
                                                              IN uint8_t old_2k3des_key[16], VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des2k_key ordinal number of authentication 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key 8 bytes array that represent DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key 8 bytes array that represent current AES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeDesKey_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_des2k_key, uint32_t aid,
                                                              uint8_t aid_key_no_auth, IN uint8_t new_des_key[8], uint8_t aid_key_no,
                                                              IN uint8_t old_des_key[8], VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des2k_key ordinal number of authentication 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_2k3des_key 16 bytes array that represent 2K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_2k3des_key 16 bytes array that represent current 2K3DES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange2K3DesKey_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_des2k_key, uint32_t aid,
                                                                 uint8_t aid_key_no_auth, IN uint8_t new_2k3des_key[16], uint8_t aid_key_no,
                                                                 IN uint8_t old_2k3des_key[16], VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 3K3DES key on the card.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_des3k_key pointer to 32 bytes array containing the 3K3DES key
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_3k3des_key 24 bytes array that represent 3K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_3k3des_key 24 bytes array that represent current 3K3DES key that will be changed, if this is not key by which is made authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChange3K3DesKey_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_des3k_key, uint32_t aid,
                                                                 uint8_t aid_key_no_auth, IN uint8_t new_3k3des_key[24], uint8_t aid_key_no,
                                                                 IN uint8_t old_3k3des_key[24], VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change master key of the card from any type to any type.
    * 
    * Multi reader support. Provided Key mode (PK)
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key pointer to array contained AES key
    * @param auth_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param new_key pointer to array contained new AES key
    * @param new_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeMasterKey_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_key, uint8_t auth_key_type, IN uint8_t *new_key,
                                                          uint8_t new_key_type, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any AES key on the card. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of authentication AES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_aes_key_nr key index of AES key stored in the reader that will be new AES key
    * @param aid_key_no key number into application that will be changed
    * @param old_aes_key_nr key index of AES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeAesKey_AesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                           uint8_t new_aes_key_nr, uint8_t aid_key_no, uint8_t old_aes_key_nr,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 3K3DES key on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des3k_key_nr key index of 3K3DES key stored in the reader that will be new 3K3DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des3k_key_nr key index of 3K3DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChange3k3desKey_3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                                 uint8_t new_des3k_key_nr, uint8_t aid_key_no, uint8_t old_des3k_key_nr,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr index of DES key stored in the reader that will be new DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeDesKey_DesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                           uint8_t new_des_key_nr, uint8_t aid_key_no, uint8_t old_des_key_nr,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any 2K3DES key on the card.
    * 
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des2k_key_nr key index of DES key stored in the reader that will be new DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChange2k3desKey_DesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                              uint8_t new_des2k_key_nr, uint8_t aid_key_no, uint8_t old_des_key_nr,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change any DES key on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des_key_nr  key index of DES key stored in the reader that will be new DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des2k_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeDesKey_2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                              uint8_t new_des_key_nr, uint8_t aid_key_no, uint8_t old_des2k_key_nr,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Function allows you to change any AES key on the card. Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr  ordinal number of 2K3DES key in the reader
    * @param aid ID of application that uses this key (3 bytes long, 0x000000 for card master key)
    * @param aid_key_no_auth key number into application which uses for authentication
    * @param new_des2k_key_nr key index of DES key stored in the reader that will be new DES key
    * @param aid_key_no key number into application that will be changed
    * @param old_des2k_key_nr key index of DES key stored in the reader that will be used for authentication
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChange2k3desKey_2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_no_auth,
                                                                 uint8_t new_des2k_key_nr, uint8_t aid_key_no, uint8_t old_des2k_key_nr,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows you to change master key of the card from any type to any type.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * Changing the card master key requires current card master key authentication. Authentication for the application keys changing depends on the application master key settings (which key is used for authentication).
    * Important: When changing a card key to a 2K3DES key, the new 2K3DES key must have different first 8 bytes and second 8 bytes. For example, the new 2K3DES key should be: 11111111111111112222222222222222. New 2K3DES  key must not consist of all zeros (16 0x00 bytes).
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_nr ordinal number of key in the reader
    * @param auth_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param new_key_nr key index of a key stored in the reader that will be new key
    * @param new_key_type AES_KEY_TYPE = 0,        //AES 16 bytes DES3K_KEY_TYPE = 1,         //3K3DES 24 bytes DES_KEY_TYPE = 2,        //DES 8 bytes DES2K_KEY_TYPE        = 3 //2K3DES 16 bytes
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeMasterKeyM(UFR_HANDLE hndUFR, uint8_t auth_key_nr, uint8_t auth_key_type, uint8_t new_key_nr,
                                                      uint8_t new_key_type, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief
    *  Function writes AES key (16 bytes) into reader.
    *
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_no ordinal number of AES key in the reader (0 - 15)
    * @param aes_key pointer to 16 byte array containing the AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteAesKeyM(UFR_HANDLE hndUFR, uint8_t aes_key_no, IN uint8_t *aes_key);

    /**
    * @brief Multi reader support. Function writes AES key (16 bytes) into reader.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param key_no ordinal number of key in the reader (0 - 15)
    * @param key pointer to array containing the key
    * @param key_type enumerated key type (0 - 3)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteKeyM(UFR_HANDLE hndUFR, uint8_t key_no, IN uint8_t *key, uint8_t key_type);

    /**
    * @brief Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStddDataFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                       uint16_t offset, uint16_t data_length, uint8_t communication_settings, OUT uint8_t *data,
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStddDataFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                           uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                          uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                          uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                             uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                             uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                          uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                          uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                          uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                          uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array 
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array 
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                             uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array 
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array 
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                             uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array 
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadStdDataFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from Standard Data File, or from Backup Data File. 
    * 
    * Multi reader support. No authentication
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array 
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadStdDataFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                               OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                       uint16_t offset, uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                           uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                           uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. Provided Key mode (PK)
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                           uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 128 bit AES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                               uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                  uint8_t aid_key_nr, uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 64 bit DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                               uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                  uint8_t aid_key_nr, uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteStdDataFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to Standard Data File, or to Backup Data File.
    * 
    * Multi reader support. No authentication
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteStdDataFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 128 bit AES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 64 bit DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                              uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                  uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                     uint8_t aid_key_nr, uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                     uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                  uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @param hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                     uint8_t aid_key_nr, uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                     uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                    uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                    uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                 uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteBackupDataFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                    uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                                    uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to the Backup Data File. 
    * 
    * Multi reader support. No authentication
    * From library version 5.0.96, and firmware version 5.0.79.
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteBackupDataFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                                   IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                      int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled, uint8_t read_key_no,
                                                      uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                      uint8_t communication_settings, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 64 bit DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                          int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                          uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                          uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                             int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                             uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                             uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                             int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                             uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                             uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 128 bit AES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                          int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                          uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                          uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. Provided Key mode (PK)
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                          int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                          uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                          uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                              int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                              uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                              uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id,
                                                                 int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                                 uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                                 uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id,
                                                                 int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                                 uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                                 uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_aes_PK_M(UFR_HANDLE hndUFR, uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                              int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                              uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                              uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                             int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                             uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                             uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                                uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                             int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                             uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                             uint8_t read_write_key_no, uint8_t change_key_no, uint8_t communication_settings,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateValueFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                int32_t lower_limit, int32_t upper_limit, int32_t value,
                                                                uint8_t limited_credit_enabled, uint8_t read_key_no, uint8_t write_key_no,
                                                                uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for the storage and manipulation of 32 bit signed integer values within existing application on the card.
    * 
    * Multi reader support. No authentication
    * For uFR PLUS devices only.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depending on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param lower_limit lower limit which is valid for this file
    * @param upper_limit upper limit which is valid for this file
    * @param value initial value of the value file
    * @param limited_credit_enabled bit 0 - limited credit enabled (1 - yes, 0 - no) bit 1 - free get value (1 - yes, 0 - no)
    * @param read_key_no key for get and debit value
    * @param write_key_no key for get, debit and limited credit value
    * @param read_write_key_no for get, debit, limited credit and credit value
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateValueFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, int32_t lower_limit,
                                                               int32_t upper_limit, int32_t value, uint8_t limited_credit_enabled,
                                                               uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                               uint8_t change_key_no, uint8_t communication_settings, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                    uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 128 bit AES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                        uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 64 bit DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                        uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                        uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                           uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadValueFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              uint8_t file_id, uint8_t communication_settings, VAR int32_t *value,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allow to read value from value files. 
    * 
    * Multi reader support. No authentication
    * For uFR PLUS devices only.
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value pointer to value
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadValueFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                             uint8_t communication_settings, VAR int32_t *value, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                        uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                   uint8_t aid_key_nr, uint8_t file_id, uint8_t communication_settings,
                                                                   uint32_t value, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                   uint8_t aid_key_nr, uint8_t file_id, uint8_t communication_settings,
                                                                   uint32_t value, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                  uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                  uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. No authentication
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                     uint8_t communication_settings, uint32_t value,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                     uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                     VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                     uint8_t communication_settings, uint32_t value,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                     uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                     VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_AesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_DesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireIncreaseValueFile_TransMac_3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to increase a value stored in a value files. 
    * 
    * Multi reader support. No authentication
    * For uFR PLUS devices only.
    * Credit command requires a preceding authentication with the key specified for Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireIncreaseValueFile_TransMac_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          uint8_t communication_settings, uint32_t value,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFileM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                        uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                   uint8_t aid_key_nr, uint8_t file_id, uint8_t communication_settings,
                                                                   uint32_t value, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                   uint8_t aid_key_nr, uint8_t file_id, uint8_t communication_settings,
                                                                   uint32_t value, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                  uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                               uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                  uint8_t file_id, uint8_t communication_settings, uint32_t value,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. No authentication
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                 uint8_t communication_settings, uint32_t value, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                     uint8_t communication_settings, uint32_t value,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                     uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                     VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                     uint8_t communication_settings, uint32_t value,
                                                                     VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                     uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                     VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                        uint8_t communication_settings, uint32_t value,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_AesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_DesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireDecreaseValueFile_TransMac_3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_aes_PK_M(UFR_HANDLE hndUFR, uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_des_PK_M(UFR_HANDLE hndUFR, uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                         uint8_t communication_settings, uint32_t value,
                                                                         VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                         uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                         VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_2k3des_PK_M(UFR_HANDLE hndUFR, uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_3k3des_PK_M(UFR_HANDLE hndUFR, uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                            uint8_t communication_settings, uint32_t value,
                                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                            uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                            VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to decrease value from value files. 
    * 
    * Multi reader support. No authentication
    * For uFR PLUS devices only
    * Debit command requires a preceding authentication with on of the keys specified for Read, Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param communication_settings variable that contains communication settings
    * @param value value (must be a positive number)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireDecreaseValueFile_TransMac_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          uint8_t communication_settings, uint32_t value,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          VAR uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIdsM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, OUT uint32_t *application_ids,
                                                        VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                        VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. 128 bit AES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, OUT uint32_t *application_ids,
                                                            VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. 64 bit DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, OUT uint32_t *application_ids,
                                                            VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support. 128 bit 2K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, OUT uint32_t *application_ids,
                                                               VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. 192 bit 3K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, OUT uint32_t *application_ids,
                                                               VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIdsAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, OUT uint32_t *application_ids,
                                                               VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIds3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, OUT uint32_t *application_ids,
                                                                  VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIdsDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, OUT uint32_t *application_ids,
                                                               VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetApplicationIds2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, OUT uint32_t *application_ids,
                                                                  VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. Provided Key mode (PK)
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, OUT uint32_t *application_ids,
                                                            VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. 128 bit AES key provided key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param application_ids pointer to 8 bytes array containing the DES key
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, OUT uint32_t *application_ids,
                                                                VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. 64 bit DES key provided key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, OUT uint32_t *application_ids,
                                                                VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_2k3aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, OUT uint32_t *application_ids,
                                                                   VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, OUT uint32_t *application_ids,
                                                                   VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function returns the Application Identifiers for all active applications on a card.
    * 
    * Multi reader support. No authentication
    * For uFR PLUS devices only
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param application_ids array of application identifiers
    * @param number_of_aplication_ids  number of application identifiers
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetApplicationIds_no_auth_M(UFR_HANDLE hndUFR, OUT uint32_t *application_ids,
                                                                 VAR uint8_t *number_of_aplication_ids, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit AES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                 uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                 uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 64 bit DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                 uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                 uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                       uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                       uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                       uint8_t communication_settings, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateLinearRecordFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                       uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                       uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                       uint8_t communication_settings, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                     uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                     uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                                     uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                     uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                        uint8_t file_id, uint32_t record_size, uint32_t max_rec_no,
                                                                        uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                        uint8_t change_key_no, uint8_t communication_settings,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                        uint8_t file_id, uint32_t record_size, uint32_t max_rec_no,
                                                                        uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                        uint8_t change_key_no, uint8_t communication_settings,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. No authentication
    * Once the file is filled completely with data records, further writing to file is not possible  unless it is cleared.
    * Maximal number of files into the application is 32. The file will be created in the currently selected application. If the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If the value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateLinearRecordFile_no_authM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                     uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                     uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit AES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                 uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                 uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 64 bit DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                 uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                 uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 uint8_t communication_settings, VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFileAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFile3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id,
                                                                       uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                       uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                       uint8_t communication_settings, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                       uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                       uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                       uint8_t communication_settings, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFileDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                    uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                    uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    uint8_t communication_settings, VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateCyclicRecordFile2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id,
                                                                       uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                       uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                       uint8_t communication_settings, VAR uint16_t *card_status,
                                                                       VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id,
                                                                     uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                     uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id,
                                                                     uint32_t record_size, uint32_t max_rec_no, uint8_t read_key_no,
                                                                     uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid,
                                                                        uint8_t file_id, uint32_t record_size, uint32_t max_rec_no,
                                                                        uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                        uint8_t change_key_no, uint8_t communication_settings,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid,
                                                                        uint8_t file_id, uint32_t record_size, uint32_t max_rec_no,
                                                                        uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no,
                                                                        uint8_t change_key_no, uint8_t communication_settings,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to create file for multiple storage of structural data, within an existing application. 
    * 
    * Multi reader support. No authentication
    * Once the file filled completely with data records, the card automatically overwrites the oldest record with latest written one.
    * Maximal number of files into application is 32. The file will be created in the currently selected application. Is the application master key authentication is required, depend on the application master key settings.
    * Communication settings define communication mode between reader and card. The communication modes are:
    * - plain communication         communication settings value is 0x00
    * - plain communication secured by MACing        communication settings value is 0x01
    * - fully enciphered communication                communication settings value is 0x03
    * Access rights for read, write, read&write and changing, references certain key within application's keys (0 - 13). If value is 14, this means free access, independent of previous authentication. If value is 15, this means deny access (for example if write access is 15 then the file type is read only).
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param record_size size of record in bytes
    * @param max_rec_no maximal number of records in file
    * @param read_key_no key for reading
    * @param write_key_no key for writing
    * @param read_write_key_no key for reading and writing
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateCyclicRecordFile_no_authM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, uint32_t record_size,
                                                                     uint32_t max_rec_no, uint8_t read_key_no, uint8_t write_key_no,
                                                                     uint8_t read_write_key_no, uint8_t change_key_no,
                                                                     uint8_t communication_settings, VAR uint16_t *card_status,
                                                                     VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                      uint16_t offset, uint16_t data_length, uint8_t communication_settings, uint8_t *data,
                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                      uint16_t offset, uint16_t data_length, uint8_t communication_settings, uint8_t *data,
                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                         uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                         uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecordAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                         IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                            uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecordDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t data_length, uint8_t communication_settings,
                                                         IN uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                            uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                          uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                          uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                          uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                          uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                             uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t data_length,
                                                             uint8_t communication_settings, IN uint8_t *data, VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. No authentication
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_no_authM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                          uint16_t data_length, uint8_t communication_settings, IN uint8_t *data,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint16_t offset, uint16_t data_length,
                                                               uint8_t communication_settings, IN uint8_t *data,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                               uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                               OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                               uint16_t offset, uint16_t data_length,
                                                               uint8_t communication_settings, IN uint8_t *data,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                               uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                               OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                  uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                  uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                  OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                  uint16_t offset, uint16_t data_length,
                                                                  uint8_t communication_settings, IN uint8_t *data,
                                                                  VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                  uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                  OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_AesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length,
                                                                   uint8_t communication_settings, IN uint8_t *data,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                   uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                   OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_DesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length,
                                                                   uint8_t communication_settings, IN uint8_t *data,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                   uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                   OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                      uint16_t offset, uint16_t data_length,
                                                                      uint8_t communication_settings, IN uint8_t *data,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                      uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                      OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireWriteRecord_TransMac_3k3desAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                      uint16_t offset, uint16_t data_length,
                                                                      uint8_t communication_settings, IN uint8_t *data,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                      uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                      OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length,
                                                                   uint8_t communication_settings, IN uint8_t *data,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                   uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                   OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   uint16_t offset, uint16_t data_length,
                                                                   uint8_t communication_settings, IN uint8_t *data,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                   uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                   OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                      uint16_t offset, uint16_t data_length,
                                                                      uint8_t communication_settings, IN uint8_t *data,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                      uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                      OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                      uint16_t offset, uint16_t data_length,
                                                                      uint8_t communication_settings, IN uint8_t *data,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                      uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                      OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows writing data to a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. No authentication
    * Write command requires a preceding authentication either with the key specified for Write or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation is supported for Desfire Light and Desfire EV2. To use these features, a Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param data_length number of bytes into array number of data to be read
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireWriteRecord_TransMac_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                    uint16_t offset, uint16_t data_length,
                                                                    uint8_t communication_settings, IN uint8_t *data,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                    uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                    OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                      uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                      uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                      uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                      uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                         uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                         uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecordsAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                         uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecords3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                            uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecordsDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                         uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                         uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecords2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                            uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                            uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                          uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                          uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                          uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                          uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                             uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                             uint8_t file_id, uint16_t offset, uint16_t number_of_records, uint16_t record_size,
                                                             uint8_t communication_settings, OUT uint8_t *data, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. No authentication
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_no_authM(UFR_HANDLE hndUFR, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id, uint16_t offset,
                                                          uint16_t number_of_records, uint16_t record_size, uint8_t communication_settings,
                                                          uint8_t *data, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_aesM(UFR_HANDLE hndUFR,
                                                      uint8_t aes_key_nr,
                                                      uint32_t aid,
                                                      uint8_t aid_key_nr,
                                                      uint8_t file_id,
                                                      uint16_t offset,
                                                      uint16_t number_of_records,
                                                      uint16_t record_size,
                                                      uint8_t communication_settings,
                                                      OUT uint8_t *data,
                                                      VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_desM(UFR_HANDLE hndUFR,
                                                      uint8_t des_key_nr,
                                                      uint32_t aid,
                                                      uint8_t aid_key_nr,
                                                      uint8_t file_id,
                                                      uint16_t offset,
                                                      uint16_t number_of_records,
                                                      uint16_t record_size,
                                                      uint8_t communication_settings,
                                                      OUT uint8_t *data,
                                                      VAR uint16_t *card_status,
                                                      VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_2k3desM(UFR_HANDLE hndUFR,
                                                         uint8_t des2k_key_nr,
                                                         uint32_t aid,
                                                         uint8_t aid_key_nr,
                                                         uint8_t file_id,
                                                         uint16_t offset,
                                                         uint16_t number_of_records,
                                                         uint16_t record_size,
                                                         uint8_t communication_settings,
                                                         OUT uint8_t *data,
                                                         VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_3k3desM(UFR_HANDLE hndUFR,
                                                         uint8_t des3k_key_nr,
                                                         uint32_t aid,
                                                         uint8_t aid_key_nr,
                                                         uint8_t file_id,
                                                         uint16_t offset,
                                                         uint16_t number_of_records,
                                                         uint16_t record_size,
                                                         uint8_t communication_settings,
                                                         OUT uint8_t *data,
                                                         VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecordsAesAuthM(UFR_HANDLE hndUFR,
                                                         uint8_t aes_key_nr,
                                                         uint32_t aid,
                                                         uint8_t aid_key_nr,
                                                         uint8_t file_id,
                                                         uint16_t offset,
                                                         uint16_t number_of_records,
                                                         uint16_t record_size,
                                                         uint8_t communication_settings,
                                                         OUT uint8_t *data,
                                                         VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecords3k3desAuthM(UFR_HANDLE hndUFR,
                                                            uint8_t des3k_key_nr,
                                                            uint32_t aid,
                                                            uint8_t aid_key_nr,
                                                            uint8_t file_id,
                                                            uint16_t offset,
                                                            uint16_t number_of_records,
                                                            uint16_t record_size,
                                                            uint8_t communication_settings,
                                                            OUT uint8_t *data,
                                                            VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecordsDesAuthM(UFR_HANDLE hndUFR,
                                                         uint8_t des_key_nr,
                                                         uint32_t aid,
                                                         uint8_t aid_key_nr,
                                                         uint8_t file_id,
                                                         uint16_t offset,
                                                         uint16_t number_of_records,
                                                         uint16_t record_size,
                                                         uint8_t communication_settings,
                                                         OUT uint8_t *data,
                                                         VAR uint16_t *card_status,
                                                         VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireReadRecords2k3desAuthM(UFR_HANDLE hndUFR,
                                                            uint8_t des2k_key_nr,
                                                            uint32_t aid,
                                                            uint8_t aid_key_nr,
                                                            uint8_t file_id,
                                                            uint16_t offset,
                                                            uint16_t number_of_records,
                                                            uint16_t record_size,
                                                            uint8_t communication_settings,
                                                            OUT uint8_t *data,
                                                            VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_aes_PK_M(UFR_HANDLE hndUFR,
                                                          IN uint8_t *aes_key_ext,
                                                          uint32_t aid,
                                                          uint8_t aid_key_nr,
                                                          uint8_t file_id,
                                                          uint16_t offset,
                                                          uint16_t number_of_records,
                                                          uint16_t record_size,
                                                          uint8_t communication_settings,
                                                          OUT uint8_t *data,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_des_PK_M(UFR_HANDLE hndUFR,
                                                          IN uint8_t *des_key_ext,
                                                          uint32_t aid,
                                                          uint8_t aid_key_nr,
                                                          uint8_t file_id,
                                                          uint16_t offset,
                                                          uint16_t number_of_records,
                                                          uint16_t record_size,
                                                          uint8_t communication_settings,
                                                          OUT uint8_t *data,
                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_2k3des_PK_M(UFR_HANDLE hndUFR,
                                                             IN uint8_t *des2k_key_ext,
                                                             uint32_t aid,
                                                             uint8_t aid_key_nr,
                                                             uint8_t file_id,
                                                             uint16_t offset,
                                                             uint16_t number_of_records,
                                                             uint16_t record_size,
                                                             uint8_t communication_settings,
                                                             OUT uint8_t *data,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_3k3des_PK_M(UFR_HANDLE hndUFR,
                                                             IN uint8_t *des3k_key_ext,
                                                             uint32_t aid,
                                                             uint8_t aid_key_nr,
                                                             uint8_t file_id,
                                                             uint16_t offset,
                                                             uint16_t number_of_records,
                                                             uint16_t record_size,
                                                             uint8_t communication_settings,
                                                             OUT uint8_t *data,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows to read data from a record in a Linear Record File or Cyclic Record File. 
    * 
    * Multi reader support. No authentication
    * Read command requires a preceding authentication either with the key specified for Read or Read&Write access.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param offset start position for read operation within file
    * @param number_of_records number of records to be read
    * @param record_size size of record in bytes
    * @param communication_settings variable that contains communication settings
    * @param data pointer to data array
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireReadRecords_no_authM(UFR_HANDLE hndUFR,
                                                          uint32_t aid,
                                                          uint8_t aid_key_nr,
                                                          uint8_t file_id,
                                                          uint16_t offset,
                                                          uint16_t number_of_records,
                                                          uint16_t record_size,
                                                          uint8_t communication_settings,
                                                          uint8_t *data,
                                                          uint16_t *card_status,
                                                          uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aesM(UFR_HANDLE hndUFR,
                                                          uint8_t aes_key_nr,
                                                          uint32_t aid,
                                                          uint8_t file_id,
                                                          VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_desM(UFR_HANDLE hndUFR,
                                                          uint8_t des_key_nr,
                                                          uint32_t aid,
                                                          uint8_t file_id,
                                                          VAR uint16_t *card_status,
                                                          VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3desM(UFR_HANDLE hndUFR,
                                                             uint8_t des2k_key_nr,
                                                             uint32_t aid,
                                                             uint8_t file_id,
                                                             VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3desM(UFR_HANDLE hndUFR,
                                                             uint8_t des3k_key_nr,
                                                             uint32_t aid,
                                                             uint8_t file_id,
                                                             VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFileAesAuthM(UFR_HANDLE hndUFR,
                                                             uint8_t aes_key_nr,
                                                             uint32_t aid,
                                                             uint8_t file_id,
                                                             VAR uint16_t *card_status,
                                                             VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile3k3desAuthM(UFR_HANDLE hndUFR,
                                                                uint8_t des3k_key_nr,
                                                                uint32_t aid,
                                                                uint8_t file_id,
                                                                VAR uint16_t *card_status,
                                                                VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aes_PK_M(UFR_HANDLE hndUFR,
                                                              IN uint8_t *aes_key_ext,
                                                              uint32_t aid,
                                                              uint8_t file_id,
                                                              VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_des_PK_M(UFR_HANDLE hndUFR,
                                                              IN uint8_t *des_key_ext,
                                                              uint32_t aid,
                                                              uint8_t file_id,
                                                              VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3des_PK_M(UFR_HANDLE hndUFR,
                                                                 IN uint8_t *des2k_key_ext,
                                                                 uint32_t aid,
                                                                 uint8_t file_id,
                                                                 VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3des_PK_M(UFR_HANDLE hndUFR,
                                                                 IN uint8_t *des3k_key_ext,
                                                                 uint32_t aid,
                                                                 uint8_t file_id,
                                                                 VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. No authentication
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_no_authM(UFR_HANDLE hndUFR,
                                                              uint32_t aid,
                                                              uint8_t file_id,
                                                              VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aes_2M(UFR_HANDLE hndUFR,
                                                            uint8_t aes_key_nr,
                                                            uint32_t aid,
                                                            uint8_t aid_key_nr,
                                                            uint8_t file_id,
                                                            VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_des_2M(UFR_HANDLE hndUFR,
                                                            uint8_t des_key_nr,
                                                            uint32_t aid,
                                                            uint8_t aid_key_nr,
                                                            uint8_t file_id,
                                                            VAR uint16_t *card_status,
                                                            VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3des_2M(UFR_HANDLE hndUFR,
                                                               uint8_t des2k_key_nr,
                                                               uint32_t aid,
                                                               uint8_t aid_key_nr,
                                                               uint8_t file_id,
                                                               VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3des_2M(UFR_HANDLE hndUFR,
                                                               uint8_t des3k_key_nr,
                                                               uint32_t aid,
                                                               uint8_t aid_key_nr,
                                                               uint8_t file_id,
                                                               VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFileAesAuth_2M(UFR_HANDLE hndUFR,
                                                               uint8_t aes_key_nr,
                                                               uint32_t aid,
                                                               uint8_t aid_key_nr,
                                                               uint8_t file_id,
                                                               VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFileDesAuth_2M(UFR_HANDLE hndUFR,
                                                               uint8_t des_key_nr,
                                                               uint32_t aid,
                                                               uint8_t aid_key_nr,
                                                               uint8_t file_id,
                                                               VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile2k3desAuth_2M(UFR_HANDLE hndUFR,
                                                                  uint8_t des2k_key_nr,
                                                                  uint32_t aid,
                                                                  uint8_t aid_key_nr,
                                                                  uint8_t file_id,
                                                                  VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile3k3desAuth_2M(UFR_HANDLE hndUFR,
                                                                  uint8_t des3k_key_nr,
                                                                  uint32_t aid,
                                                                  uint8_t aid_key_nr,
                                                                  uint8_t file_id,
                                                                  VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. Provided Key mode (PK)
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_PK_2M(UFR_HANDLE hndUFR,
                                                           IN uint8_t *aes_key_ext,
                                                           uint32_t aid,
                                                           uint8_t aid_key_nr,
                                                           uint8_t file_id,
                                                           VAR uint16_t *card_status,
                                                           VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_aes_PK_2M(UFR_HANDLE hndUFR,
                                                               IN uint8_t *aes_key_ext,
                                                               uint32_t aid,
                                                               uint8_t aid_key_nr,
                                                               uint8_t file_id,
                                                               VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_des_PK_2M(UFR_HANDLE hndUFR,
                                                               IN uint8_t *des_key_ext,
                                                               uint32_t aid,
                                                               uint8_t aid_key_nr,
                                                               uint8_t file_id,
                                                               VAR uint16_t *card_status,
                                                               VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_2k3des_PK_2M(UFR_HANDLE hndUFR,
                                                                  IN uint8_t *des2k_key_ext,
                                                                  uint32_t aid,
                                                                  uint8_t aid_key_nr,
                                                                  uint8_t file_id,
                                                                  VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31)  ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_3k3des_PK_2M(UFR_HANDLE hndUFR,
                                                                  IN uint8_t *des3k_key_ext,
                                                                  uint32_t aid,
                                                                  uint8_t aid_key_nr,
                                                                  uint8_t file_id,
                                                                  VAR uint16_t *card_status,
                                                                  VAR uint16_t *exec_time);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_aesM(UFR_HANDLE hndUFR,
                                                                   uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                   uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                   OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_desM(UFR_HANDLE hndUFR,
                                                                   uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                   uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                   OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_2k3desM(UFR_HANDLE hndUFR,
                                                                      uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                      uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                      OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_3k3desM(UFR_HANDLE hndUFR,
                                                                      uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                      VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                      uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                      OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_AesAuthM(UFR_HANDLE hndUFR,
                                                                       uint8_t aes_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_DesAuthM(UFR_HANDLE hndUFR,
                                                                       uint8_t des_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_2k3desAuthM(UFR_HANDLE hndUFR,
                                                                          uint8_t des2k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireClearRecordFile_TransMac_3k3desAuthM(UFR_HANDLE hndUFR,
                                                                          uint8_t des3k_key_nr, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit AES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_aes_PK_M(UFR_HANDLE hndUFR,
                                                                       IN uint8_t *aes_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 64 bit DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_des_PK_M(UFR_HANDLE hndUFR,
                                                                       IN uint8_t *des_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                       VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                       uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                       OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_2k3des_PK_M(UFR_HANDLE hndUFR,
                                                                          IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_3k3des_PK_M(UFR_HANDLE hndUFR,
                                                                          IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t aid_key_nr, uint8_t file_id,
                                                                          VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                          uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                          OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function allows to reset a Linear Record File or Cyclic Record file to the empty state. 
    * 
    * Multi reader support. No authentication
    * Clear command requires a preceding authentication with the key specified for  Read&Write access.
    * Bug fix from library version 5.0.29. The aid key number was omitted in function parameters, so it was used application master key number 0 for Read&Write access. For compatibility reasons old functions were retained. New function names have the “_2” suffix.
    * From library version 5.0.29 and firmware version 5.0.32, Desfire Light supported.
    * NOTE: Transaction MAC file exist by factory default setting. For using this function, user must delete transaction MAC file first.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application. Function returns current Reader ID if they used, Previous Encrypted Reader ID, Transaction MAC counter, and Transaction MAC.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    * @param use_reader_id 0 - Reader ID is not used, 1- Reader ID is used
    * @param reader_id pointer to 16 bytes array containing the Reader ID
    * @param prev_enc_reader_id pointer to 16 bytes array containing the Previous Encrypted Reader ID
    * @param trans_mac_cnt pointer to value of Transaction MAC counter
    * @param trans_mac_value pointer to 8 bytes array containing Transaction MAC
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireClearRecordFile_TransMac_no_auth_M(UFR_HANDLE hndUFR,
                                                                        uint32_t aid, uint8_t file_id,
                                                                        VAR uint16_t *card_status, VAR uint16_t *exec_time,
                                                                        uint8_t use_reader_id, OUT uint8_t *reader_id, OUT uint8_t *prev_enc_reader_id,
                                                                        OUT uint32_t *trans_mac_cnt, OUT uint8_t *trans_mac_value);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_aes_M(UFR_HANDLE hndUFR,
                                                              uint8_t aes_key_nr,
                                                              uint32_t aid,
                                                              uint8_t file_id,
                                                              uint8_t read_key_no,
                                                              uint8_t commit_reader_id_key_no,
                                                              uint8_t change_key_no,
                                                              uint8_t communication_settings,
                                                              IN uint8_t *trans_mac_key,
                                                              VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_des_M(UFR_HANDLE hndUFR,
                                                              uint8_t des_key_nr,
                                                              uint32_t aid,
                                                              uint8_t file_id,
                                                              uint8_t read_key_no,
                                                              uint8_t commit_reader_id_key_no,
                                                              uint8_t change_key_no,
                                                              uint8_t communication_settings,
                                                              IN uint8_t *trans_mac_key,
                                                              VAR uint16_t *card_status,
                                                              VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_2k3des_M(UFR_HANDLE hndUFR,
                                                                 uint8_t des2k_key_nr,
                                                                 uint32_t aid,
                                                                 uint8_t file_id,
                                                                 uint8_t read_key_no,
                                                                 uint8_t commit_reader_id_key_no,
                                                                 uint8_t change_key_no,
                                                                 uint8_t communication_settings,
                                                                 IN uint8_t *trans_mac_key,
                                                                 VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_3k3des_M(UFR_HANDLE hndUFR,
                                                                 uint8_t des3k_key_nr,
                                                                 uint32_t aid,
                                                                 uint8_t file_id,
                                                                 uint8_t read_key_no,
                                                                 uint8_t commit_reader_id_key_no,
                                                                 uint8_t change_key_no,
                                                                 uint8_t communication_settings,
                                                                 IN uint8_t *trans_mac_key,
                                                                 VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_aes_PK_M(UFR_HANDLE hndUFR,
                                                                 IN uint8_t *aes_key_ext,
                                                                 uint32_t aid,
                                                                 uint8_t file_id,
                                                                 uint8_t read_key_no,
                                                                 uint8_t commit_reader_id_key_no,
                                                                 uint8_t change_key_no,
                                                                 uint8_t communication_settings,
                                                                 IN uint8_t *trans_mac_key,
                                                                 VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_des_PK_M(UFR_HANDLE hndUFR,
                                                                 IN uint8_t *des_key_ext,
                                                                 uint32_t aid,
                                                                 uint8_t file_id,
                                                                 uint8_t read_key_no,
                                                                 uint8_t commit_reader_id_key_no,
                                                                 uint8_t change_key_no,
                                                                 uint8_t communication_settings,
                                                                 IN uint8_t *trans_mac_key,
                                                                 VAR uint16_t *card_status,
                                                                 VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multireader support. 128 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_2k3des_PK_M(UFR_HANDLE hndUFR,
                                                                   IN uint8_t *des2k_key_ext,
                                                                   uint32_t aid,
                                                                   uint8_t file_id,
                                                                   uint8_t read_key_no,
                                                                   uint8_t commit_reader_id_key_no,
                                                                   uint8_t change_key_no,
                                                                   uint8_t communication_settings,
                                                                   IN uint8_t *trans_mac_key,
                                                                   VAR uint16_t *card_status,
                                                                   VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireCreateTransMacFile_3k3des_PK_M(UFR_HANDLE hndUFR,
                                                                    IN uint8_t *des3k_key_ext,
                                                                    uint32_t aid,
                                                                    uint8_t file_id,
                                                                    uint8_t read_key_no,
                                                                    uint8_t commit_reader_id_key_no,
                                                                    uint8_t change_key_no,
                                                                    uint8_t communication_settings,
                                                                    IN uint8_t *trans_mac_key,
                                                                    VAR uint16_t *card_status,
                                                                    VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFileAesAuthM(UFR_HANDLE hndUFR,
                                                                uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, IN uint8_t *trans_mac_key,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFileDesAuthM(UFR_HANDLE hndUFR,
                                                                uint8_t des_key_nr, uint32_t aid, uint8_t file_id,
                                                                uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
                                                                uint8_t communication_settings, IN uint8_t *trans_mac_key,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no ey for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFile2k3desAuthM(UFR_HANDLE hndUFR,
                                                                   uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                   uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, IN uint8_t *trans_mac_key,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function creates Transaction MAC file in application.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param read_key_no key for reading
    * @param commit_reader_id_key_no key for commit Reader ID command
    * @param change_key_no key for changing this setting
    * @param communication_settings variable that contains communication settings
    * @param trans_mac_key pointer to 16 bytes array containing Transaction MAC key
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireCreateTransMacFile3k3desAuthM(UFR_HANDLE hndUFR,
                                                                   uint8_t aes_key_nr, uint32_t aid, uint8_t file_id,
                                                                   uint8_t read_key_no, uint8_t commit_reader_id_key_no, uint8_t change_key_no,
                                                                   uint8_t communication_settings, IN uint8_t *trans_mac_key,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. No authentication
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_no_auth_M(UFR_HANDLE hndUFR, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_aes_M(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_des_M(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_2k3des_M(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetStdFileSize_3k3des_M(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSizeAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSize3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSizeDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function retrieves the information about the size of the standard data file stored on the tag.
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_size pointer to file size variable
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetStdFileSize2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr, uint32_t aid, uint8_t file_id, VAR uint32_t *file_size, uint16_t *card_status, uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 128 bit AES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext,
                                                              uint32_t aid, uint8_t file_id,
                                                              VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                              VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                              VAR uint32_t *file_size,
                                                              VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                              VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                              VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 64 bit DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext,
                                                              uint32_t aid, uint8_t file_id,
                                                              VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                              VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                              VAR uint32_t *file_size,
                                                              VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                              VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                              VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 128 bit 2K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext,
                                                                 uint32_t aid, uint8_t file_id,
                                                                 VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                                 VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                                 VAR uint32_t *file_size,
                                                                 VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                                 VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                                 VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 192 bit 3K3DES key provided key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext,
                                                                 uint32_t aid, uint8_t file_id,
                                                                 VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                                 VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                                 VAR uint32_t *file_size,
                                                                 VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                                 VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                                 VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. No authentication
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_no_auth_M(UFR_HANDLE hndUFR,
                                                               uint32_t aid, uint8_t file_id,
                                                               VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                               VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                               VAR uint32_t *file_size,
                                                               VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                               VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                               VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                               VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_aes_M(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                           uint32_t aid, uint8_t file_id,
                                                           VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                           VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                           VAR uint32_t *file_size,
                                                           VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                           VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                           VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_des_M(UFR_HANDLE hndUFR, uint8_t des_key_nr,
                                                           uint32_t aid, uint8_t file_id,
                                                           VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                           VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                           VAR uint32_t *file_size,
                                                           VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                           VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                           VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                           VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_2k3des_M(UFR_HANDLE hndUFR, uint8_t des2k_key_nr,
                                                              uint32_t aid, uint8_t file_id,
                                                              VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                              VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                              VAR uint32_t *file_size,
                                                              VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                              VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                              VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettings_3k3des_M(UFR_HANDLE hndUFR, uint8_t des3k_key_nr,
                                                              uint32_t aid, uint8_t file_id,
                                                              VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                              VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                              VAR uint32_t *file_size,
                                                              VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                              VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                              VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit AES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettingsAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                             uint32_t aid, uint8_t file_id,
                                                             VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                             VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                             VAR uint32_t *file_size,
                                                             VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                             VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                             VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 64 bit DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettingsDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr,
                                                             uint32_t aid, uint8_t file_id,
                                                             VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                             VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                             VAR uint32_t *file_size,
                                                             VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                             VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                             VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettings2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr,
                                                                uint32_t aid, uint8_t file_id,
                                                                VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                                VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                                VAR uint32_t *file_size,
                                                                VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                                VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                                VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support. *only uFR CS with SAM support
    * 192 bit 3K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param lower_limit value file lower limit
    * @param upper_limit value file upper limit
    * @param limited_credit_value value file limited credit value
    * @param limited_credit_enable value file limited credit enable (0 - disabled, 1 - enabled)
    * @param record_size record file size of record
    * @param max_number_of_rec record file maximal number of record
    * @param curr_number_of_rec record file number of used record
    * @param tm_key_type TMC file key type AES
    * @param tm_key_version TMC key version
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettings3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr,
                                                                uint32_t aid, uint8_t file_id,
                                                                VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                                VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                                VAR uint32_t *file_size,
                                                                VAR int32_t *lower_limit, VAR int32_t *upper_limit, VAR uint32_t *limited_credit_value, VAR uint8_t *limited_credit_enable,
                                                                VAR uint32_t *record_size, VAR uint32_t *max_number_of_rec, VAR uint32_t *curr_number_of_rec,
                                                                VAR uint8_t *tm_key_type, VAR uint8_t *tm_key_version,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support.
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param sdm_enable Secure Dynamic Messaging enable status
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettingsSdm_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext,
                                                                 uint32_t aid, uint8_t file_id,
                                                                 VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                                 VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                                 VAR uint32_t *file_size, VAR uint8_t *sdm_enable,
                                                                 VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                                 VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                                 VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                                 VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support.
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param sdm_enable Secure Dynamic Messaging enable status
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireGetFileSettingsSdm_aes_M(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                              uint32_t aid, uint8_t file_id,
                                                              VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                              VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                              VAR uint32_t *file_size, VAR uint8_t *sdm_enable,
                                                              VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                              VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                              VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                              VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                              VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function returns file settings. 
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * 128 bit 2K3DES key
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_id ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param file_type file type 0 - standard data file,  1 - backup data file, 2 - value file, 3 - linear record file, 4 - cyclic record file, 5 - transaction MAC file
    * @param communication_mode communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param file_size standard data file size
    * @param sdm_enable Secure Dynamic Messaging enable status
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireGetFileSettingsSdmAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                                uint32_t aid, uint8_t file_id,
                                                                VAR uint8_t *file_type, VAR uint8_t *communication_mode,
                                                                VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                                VAR uint32_t *file_size, VAR uint8_t *sdm_enable,
                                                                VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                                VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                                VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                                VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * 
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                             uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                             uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_desM(UFR_HANDLE hndUFR, uint8_t des_key_nr,
                                                             uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                             uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                             VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Multi reader support.
    * Function allows changing of file settings
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_2k3desM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr,
                                                                uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_3k3desM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr,
                                                                uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    Multi reader support.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext,
                                                                 uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_ext pointer to 8 bytes array containing the DES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des_key_ext,
                                                                 uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                 uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                 VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_ext pointer to 16 bytes array containing the 2K3DES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des2k_key_ext,
                                                                    uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_ext pointer to 24 bytes array containing the 3K3DES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettings_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *des3k_key_ext,
                                                                    uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                    uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                    VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettingsAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                                uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des_key_nr ordinal number of DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettingsDesAuthM(UFR_HANDLE hndUFR, uint8_t des_key_nr,
                                                                uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des2k_key_nr ordinal number of 2K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettings2k3desAuthM(UFR_HANDLE hndUFR, uint8_t des2k_key_nr,
                                                                   uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                   uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param des3k_key_nr ordinal number of 3K3DES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file (0 – 31)
    * @param comm_settings communication mode 0 - Plain, 1 - MACed, 3 - Enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettings3k3desAuthM(UFR_HANDLE hndUFR, uint8_t des3k_key_nr,
                                                                   uint32_t aid, uint8_t file_no, uint8_t comm_settings,
                                                                   uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                   VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * Security Dynamic Messaging settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param communication_settings communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettingsSdmM(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                            uint32_t aid, uint8_t file_no, uint8_t communication_settings,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                            uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                            uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                            uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                            uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * Security Dynamic Messaging settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param file_no ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param communication_settings communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireChangeFileSettingsSdm_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext,
                                                                uint32_t aid, uint8_t file_no, uint8_t communication_settings,
                                                                uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                                uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                                uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                                uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                                uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                                VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function allows changing of file settings
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * Security Dynamic Messaging settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param file_no ID of file that will be created (0 - 31) ID of file (0 - 31)
    * @param communication_settings communication mode 0 - plain, 1 - maced, 3 - enciphered
    * @param read_key_no read key number
    * @param write_key_no write key number
    * @param read_write_key_no read write key number
    * @param change_key_no change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 13, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 13, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 13, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireChangeFileSettingsSdmM(UFR_HANDLE hndUFR, uint8_t aes_key_nr,
                                                            uint32_t aid, uint8_t file_no, uint8_t communication_settings,
                                                            uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                            uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                            uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                            uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                            uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                            VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function set value of application transaction timer.
    * 
    * Multi reader support.
    * Desfire EV3 only.
    * At the current application specific capability data option must be enabled.
    * Application must be created by function uFR_int_DesfireCreateAesApplication_aes_iso_ascd.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_ext pointer to 16 bytes array containing the AES key
    * @param aid ID of application that contains the file
    * @param transaction_timer 0 - disabled, 1 - 1 - 3 seconds, 2 - 10 - 30 seconds, 3 - 100 - 300 seconds
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetTransactionTimer_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint32_t aid, uint8_t transaction_timer, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function set value of application transaction timer.
    * 
    * Multi reader support.
    * Desfire EV3 only.
    * At the current application specific capability data option must be enabled.
    * Application must be created by function uFR_int_DesfireCreateAesApplication_aes_iso_ascd.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param transaction_timer 0 - disabled, 1 - 1 - 3 seconds, 2 - 10 - 30 seconds, 3 - 100 - 300 seconds
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireSetTransactionTimer_aesM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t transaction_timer, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function set value of application transaction timer.
    * 
    * Multi reader support.
    * *only uFR CS with SAM support
    * Desfire EV3 only.
    * At the current application specific capability data option must be enabled.
    * Application must be created by function uFR_int_DesfireCreateAesApplication_aes_iso_ascd.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key in the reader
    * @param aid ID of application that contains the file
    * @param transaction_timer 0 - disabled, 1 - 1 - 3 seconds, 2 - 10 - 30 seconds, 3 - 100 - 300 seconds
    * @param card_status pointer to card error variable
    * @param exec_time function's execution time
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_SAM_DesfireSetTransactionTimerAesAuthM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint32_t aid, uint8_t transaction_timer, VAR uint16_t *card_status, VAR uint16_t *exec_time);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA).  .
    * 
    * Multi reader support.
    * From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 64 bit DES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param lpucECCSignature 56 bytes ECC signature
    * @param card_uid 7 bytes length card UID
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireUidReadECCSignatureM(UFR_HANDLE hndUFR, OUT uint8_t *lpucECCSignature, OUT uint8_t *card_uid, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 64 bit DES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                  OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit 2K3DES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_2k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                     OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 192 bit 3K3DES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_3k3des_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                     OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit AES key provided key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_ext pointer to array containing the key auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_aes_PK_M(UFR_HANDLE hndUFR, IN uint8_t *auth_key_ext, uint32_t aid, uint8_t aid_key_nr,
                                                                  OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 64 bit DES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_desM(UFR_HANDLE hndUFR, uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit 2K3DES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_2k3desM(UFR_HANDLE hndUFR, uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 192 bit 3K3DES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_3k3desM(UFR_HANDLE hndUFR, uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                                 OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    /**
    * @brief Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA). 
    * 
    * Multi reader support. From library version 5.0.45 and firmware version 5.0.44. For Desfire Light, and Desfire EV2.
    * 128 bit AES key
    * If the Random ID is activated, then authentication with a valid key is required.
    *
    * @ingroup Card_Tag_Mifare_Desfire_M
    *
    * @param hndUFR hndUFR handle of the uFR device
    * @param auth_key_nr ordinal number of key in the reader
    * @param aid ID of application that contains the file
    * @param aid_key_nr key number into application
    * @param card_uid 7 bytes length card UID
    * @param lpucECCSignature 56 bytes ECC signature
    * @param lpucDlogicCardType pointer to variable which will (in case of successfully executed operation) receive DlogicCardType. Returned here for convenience. For DlogicCardType uFR API uses the same constants as with GetDlogicCardType() function (see Appendix: DLogic CardType enumeration).
    *
    * @return Operation status
    */
    UFR_STATUS DL_API uFR_int_DesfireRidReadECCSignature_aesM(UFR_HANDLE hndUFR, uint8_t auth_key_nr, uint32_t aid, uint8_t aid_key_nr,
                                                              OUT uint8_t *card_uid, OUT uint8_t *lpucECCSignature, VAR uint8_t *lpucDlogicCardType);

    //------------------------------------------------------------------------------------------

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_Signalization_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GreenLedBlinkingTurnOnM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The function prohibits the blinking of the green diode independently of the user's signaling command. LED and sound signaling occurs only on the user command. This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_Signalization_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GreenLedBlinkingTurnOffM(UFR_HANDLE hndUFR);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbInternalTurnOnM(UFR_HANDLE hndUFR);

    /**
    * @ingroup UNDOCUMENTED
    *
    * @return Operation status
    */
    UFR_STATUS DL_API RgbInternalTurnOffM(UFR_HANDLE hndUFR);

    /////////////////////////////////////////////////////////////////////

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeAM(UFR_HANDLE hndUFR, uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp,
                                                 uint8_t RxGain, uint8_t RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeBM(UFR_HANDLE hndUFR, uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel, uint8_t RFLevelAmp,
                                                 uint8_t RxGain, uint8_t RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_212M(UFR_HANDLE hndUFR, uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel,
                                                        uint8_t RFLevelAmp, uint8_t RxGain, uint8_t RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_424M(UFR_HANDLE hndUFR, uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel,
                                                        uint8_t RFLevelAmp, uint8_t RxGain, uint8_t RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeADefaultM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeBDefaultM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_212DefaultM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersISO14443_424DefaultM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg RxGain
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeAM(UFR_HANDLE hndUFR, VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel,
                                                 VAR uint8_t *RFLevelAmp, VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg RxGain
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeBM(UFR_HANDLE hndUFR, VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel,
                                                 VAR uint8_t *RFLevelAmp, VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg RxGain
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersISO14443_212M(UFR_HANDLE hndUFR, VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel,
                                                        VAR uint8_t *RFLevelAmp, VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg RxGain
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersISO14443_424M(UFR_HANDLE hndUFR, VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel,
                                                        VAR uint8_t *RFLevelAmp, VAR uint8_t *RxGain, VAR uint8_t *RFLevel);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param CWGsNOff value in range 0 - 15, part of GsNOffReg
    * @param ModGsNOff value in range 0 - 15, part of GsNOffReg ModGsP value of ModGsPReg (0 - 47)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeATransM(UFR_HANDLE hndUFR, uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel,
                                                      uint8_t RFLevelAmp, uint8_t RxGain, uint8_t RFLevel, uint8_t CWGsNOn, uint8_t ModGsNOn,
                                                      uint8_t CWGsP, uint8_t CWGsNOff, uint8_t ModGsNOff);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param ModGsP value of ModGsPReg (0 - 47)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SetRfAnalogRegistersTypeBTransM(UFR_HANDLE hndUFR, uint8_t ThresholdMinLevel, uint8_t ThresholdCollLevel,
                                                      uint8_t RFLevelAmp, uint8_t RxGain, uint8_t RFLevel, uint8_t CWGsNOn, uint8_t ModGsNOn,
                                                      uint8_t CWGsP, uint8_t ModGsP);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param CWGsNOff value in range 0 - 15, part of GsNOffReg
    * @param ModGsNOff value in range 0 - 15, part of GsNOffReg
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeATransM(UFR_HANDLE hndUFR, VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel,
                                                      VAR uint8_t *RFLevelAmp, VAR uint8_t *RxGain, VAR uint8_t *RFLevel, VAR uint8_t *CWGsNOn,
                                                      VAR uint8_t *ModGsNOn, VAR uint8_t *CWGsP, VAR uint8_t *CWGsNOff, VAR uint8_t *ModGsNOff);

    /**
    * @brief Multi reader support. The function allows the blinking of the green diode independently of the user's signaling command (default setting). This setting writes into the reader's EEPROM, and it loads when the reader starts up.
    *
    * @ingroup ReaderAndLibrary_uFRSpecificFeatures_RFAnalogRegisterSettings_M
    *
    * @param hndUFR handle of the uFR device
    * @param ThresholdMinLevel value in range 0 - 15, part of RxThresholdReg
    * @param ThresholdCollLevel value in range 0 - 7, part of RxThresholdReg
    * @param RFLevelAmp 0 or 1, part of RFCfgReg
    * @param RxGain value in range 0 - 7, part of RFCfgReg
    * @param RFLevel value in range 0 - 15, part of RFCfgReg
    * @param CWGsNOn value in range 0 - 15, part of GsNOnReg
    * @param ModGsNOn value in range 0 - 15, part of GsNOnReg
    * @param CWGsP value of CWGsPReg (0 - 47)
    * @param ModGsP value of ModGsPReg (0 - 47)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API GetRfAnalogRegistersTypeBTransM(UFR_HANDLE hndUFR, VAR uint8_t *ThresholdMinLevel, VAR uint8_t *ThresholdCollLevel,
                                                      VAR uint8_t *RFLevelAmp, VAR uint8_t *RxGain, VAR uint8_t *RFLevel, VAR uint8_t *CWGsNOn,
                                                      VAR uint8_t *ModGsNOn, VAR uint8_t *CWGsP, VAR uint8_t *ModGsP);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API FastFlashCheckM(UFR_HANDLE hndUFR);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API DefaultBaudrateFlashCheckM(UFR_HANDLE hndUFR);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetReaderParametersM(UFR_HANDLE hndUFR, uint8_t *mui, uint8_t *serial_nr, uint8_t *hw_type, uint8_t *hw_ver,
                                           uint8_t *device_type, uint8_t *fw_ver_major, uint8_t *fw_ver_minor, uint8_t *fw_ver_build);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetReaderParametersDefaultBaudrateM(UFR_HANDLE hndUFR, OUT uint8_t *mui, OUT uint8_t *serial_nr, VAR uint8_t *hw_type, VAR uint8_t *hw_ver,
                                                          VAR uint8_t *device_type, VAR uint8_t *fw_ver_major, VAR uint8_t *fw_ver_minor,
                                                          VAR uint8_t *fw_ver_build);

    /**
    * @ingroup INTERNAL
    * EXCLUDE FROM DOCUMENTATION
    */
    UFR_STATUS DL_API GetReaderParametersPN7462_M(UFR_HANDLE hndUFR, uint8_t *die_id, uint8_t *serial_nr,

                                                  uint8_t *hw_type, uint8_t *hw_ver, uint8_t *device_type,
                                                  uint8_t *fw_ver_major, uint8_t *fw_ver_minor, uint8_t *fw_ver_build);

    // SAM
    /**
    * @brief Multi reader support. Function returns manufacturing related data of the MIFARE SAM. For more information refer to  NXP documentation.
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param data pointer to array containing version data
    * @param length pointer to length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_get_version_rawM(UFR_HANDLE hndUFR, OUT uint8_t *data, VAR uint8_t *length);

    /**
    * @brief Multi reader support. Function returns manufacturing related data of the MIFARE SAM. For more information refer to  NXP documentation.
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param sam_type pointer to SAM type variable
    * @param sam_uid pointer to array containing 7 bytes  UID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_get_versionM(UFR_HANDLE hndUFR, VAR SAM_HW_TYPE *sam_type, VAR uint8_t *sam_uid);

    /**
    * @brief Multi reader support. Function allows reading the contents of the key entry specified in the parameter key_no. For more information refer to  NXP documentation.
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_no key reference number (0 - 127)
    * @param key_entry pointer to array containing key entry data
    * @param key_length pointer to key entry length variable
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_get_key_entry_rawM(UFR_HANDLE hndUFR, uint8_t key_no, OUT uint8_t *key_entry, VAR uint8_t *key_length,
                                             OUT uint8_t *apdu_sw);

    /**
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_no key reference number (0 - 127)
    * @param key_v ADD DESCRIPTION
    * @param des_key ADD DESCRIPTION
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_authenticate_host_no_div_desM(UFR_HANDLE hndUFR, uint8_t key_no, uint8_t key_v, IN uint8_t *des_key);

    /**
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ver_a pointer to array containing 16 bytes of first AES key
    * @param ver_a key version of first key (0 - 255)
    * @param aes_key_ver_b pointer to array containing 16 bytes of second AES key
    * @param ver_b key version of second key (0 - 255)
    * @param aes_key_ver_c pointer to array containing 16 bytes of third AES key
    * @param ver_c key version of third key (0 - 255)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_pre_pesonalization_master_AES128_keyM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ver_a, uint8_t ver_a,
                                                                IN uint8_t *aes_key_ver_b, uint8_t ver_b, IN uint8_t *aes_key_ver_c,
                                                                uint8_t ver_c, OUT uint8_t *apdu_sw);

    /**
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param master_aes_key ADD DESCRIPTION
    * @param key_version key version (0 - 255)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_pre_personalization_switch_to_AV2_modeM(UFR_HANDLE hndUFR, IN uint8_t *master_aes_key, uint8_t key_version,
                                                                  OUT uint8_t *apdu_sw);

    /**
    * @brief Multi reader support. Function is used to run a mutual 3-pass authentication between the MIFARE SAM AV2 and PC. A host authentication is required to:
    * • Load or update keys into the MIFARE SAM AV2
    * • Activate the MIFARE SAM AV2 after reset (if configured accordingly in the configuration settings of master key key_no 00h)
    * The communication in this process is plain, so key will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param host_aes_key pointer to array containing 16 bytes AES key
    * @param key_nr key reference number (0 - 127)
    * @param key_version key version (0 - 255)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_authenticate_host_AV2_plainM(UFR_HANDLE hndUFR, IN uint8_t *host_aes_key, uint8_t key_nr, uint8_t key_version,
                                                       OUT uint8_t *apdu_sw);

    /**
    * @brief Multi reader support. Function allows changing KST containing two Crypto 1 keys (KeyA and KeyB) for authentication to Mifare Classic or Mifare Plus card in SL1 mode.
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_entry_no key reference number (1 - 127)
    * @param keyA pointer to array containing 6 bytes Crypto 1 key A
    * @param keyB pointer to array containing 6 bytes Crypto 1 key B
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_mifare_AV2_plain_one_keyM(UFR_HANDLE hndUFR, uint8_t key_entry_no, IN uint8_t *keyA,
                                                                     IN uint8_t *keyB, uint8_t key_no_CEK, uint8_t key_v_CEK,
                                                                     uint8_t ref_no_KUC, OUT uint8_t *apdu_sw);

    /**
    * @brief Multi reader support. Function allows changing KST containing AES key for authentication to Mifare Desfire or Mifare Plus card in SL3 mode.
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_entry_no key reference number (1 - 127)
    * @param key pointer to array containing 16 bytes of AES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_AES_AV2_plain_one_keyM(UFR_HANDLE hndUFR, uint8_t key_entry_no, IN uint8_t *key, uint8_t key_no_CEK,
                                                                  uint8_t key_v_CEK, uint8_t ref_no_KUC, OUT uint8_t *apdu_sw);

    /**
    * @brief Multi reader support. Function allows changing KST containing 3K3DES key for authentication to Mifare Desfire card.
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_entry_no key reference number (1 - 127)
    * @param key pointer to array containing 24 bytes of 3K3DES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_3K3DES_AV2_plain_one_keyM(UFR_HANDLE hndUFR, uint8_t key_entry_no, IN uint8_t *key,
                                                                     uint8_t key_no_CEK, uint8_t key_v_CEK, uint8_t ref_no_KUC,
                                                                     OUT uint8_t *apdu_sw);

    /**
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_entry_no key reference number (0 - 127)
    * @param key pointer to array containing 24 bytes of 2K3DES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_2K3DES_AV2_ULC_plain_one_keyM(UFR_HANDLE hndUFR, uint8_t key_entry_no, IN uint8_t *key,
                                                                         uint8_t key_no_CEK, uint8_t key_v_CEK, uint8_t ref_no_KUC,
                                                                         OUT uint8_t *apdu_sw);

    /**
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param key_entry_no key reference number (0 - 127)
    * @param key pointer to array containing 24 bytes of 2K3DES key
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_2K3DES_AV2_desfire_plain_one_keyM(UFR_HANDLE hndUFR, uint8_t key_entry_no, IN uint8_t *key,
                                                                             uint8_t key_no_CEK, uint8_t key_v_CEK, uint8_t ref_no_KUC,
                                                                             OUT uint8_t *apdu_sw);

    /**
    * @brief Multi reader support. Function allows changing KST (Key Storage Table) containing 3 AES-128 keys, and their versions.
    * The communication in this process is plain, so keys will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_entry_no key reference number (0 - 127)
    * @param aes_key_ver_a pointer to array containing 16 bytes of first  AES key
    * @param ver_a key version of first key (0 - 255)
    * @param aes_key_ver_b pointer to array containing 16 bytes of second AES key
    * @param ver_b key version of second key (0 - 255)
    * @param aes_key_ver_c pointer to array containing 16 bytes of third AES key
    * @param ver_c key version of third key (0 - 255)
    * @param key_no_CEK reference number of CEK (Change Entry Key). (future host authentication for change this KST must be with AES key with key_no_CEK key reference number)
    * @param key_v_CEK version of CEK (future host authentication for change this KST must be with AES key with key_ver_CEK key version)
    * @param ref_no_KUC reference number of KUC (Key Usage Counter) (not support jet, unlimited number of authentication ref_no_KUC = 0xFF)
    * @param sam_lock_unlock SAM lock/unlock ability. If key_entry_no = 0 (master key), then the SAM will be locked after power up or reset, and minimal set of commands will be available.
    * @param sam_auth_host Host authentication ability. If key_entry_no = 0 (master key), then the authentication with host key is mandatory after power up or reset, in opposition minimal set of commands will be available.
    * @param apdu_sw pointer to array containing SW1 and SW2  APDU status bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API SAM_change_key_entry_aes_AV2_plain_host_keyM(UFR_HANDLE hndUFR, uint8_t key_entry_no, IN uint8_t *aes_key_ver_a,
                                                                   uint8_t ver_a, IN uint8_t *aes_key_ver_b, uint8_t ver_b,
                                                                   IN uint8_t *aes_key_ver_c, uint8_t ver_c, uint8_t key_no_CEK,
                                                                   uint8_t key_v_CEK, uint8_t ref_no_KUC, uint8_t sam_lock_unlock,
                                                                   uint8_t sam_auth_host, OUT uint8_t *apdu_sw);

    /**
    * @brief Multi reader support. If master key has enabled lock/unlock parameter, then SAM unlock with key with lock/unlock ability is required. uFR reader tries to unlock SAM with key which stored into reader by this function. If internal reader keys locked, then they must be unlocked first, with function ReaderKeysUnlock.
    * The communication in this process is plain, so key will be exposed during function execution. Use this function in security environment (disconnect LAN).
    *
    * @ingroup ReaderAndLibrary_NXPSAM_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_no key reference number (0 - 127)
    * @param key_ver key version (0 - 255)
    * @param aes_key pointer to array containing 16 bytes of AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteSamUnlockKeyM(UFR_HANDLE hndUFR, uint8_t key_no, uint8_t key_ver, IN uint8_t *aes_key);

    /**
    * @brief Function tries to change the UID on the card. 
    * Multi reader support. 
    * On some cards (e.g. Magic Classic) changing UID is possible. If theed card is that type of card, then the function returns UFR_OK.
    * 
    * @ingroup Miscellaneous_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API CheckUidChangeableM(UFR_HANDLE hndUFR);

    /**
    * @brief Function reset RF field at the reader. The RF field will be off, and then on after 50ms.
    * 
    * Multi reader support. 
    * 
    * @ingroup Miscellaneous_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderRfResetM(UFR_HANDLE hndUFR);

    /**
    * @brief Function switch on RF field at the reader. 
    * 
    * For proper functionality the reader must be in the multi card mode. 
    * Multi reader support.
    * From library version 5.0.48, and firmware version 5.0.51.
    *
    * @ingroup Miscellaneous_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderRfOnM(UFR_HANDLE hndUFR);

    /**
    * @brief Function switch off RF field at the reader. 
    * 
    * Multi reader support. 
    * From library version 5.0.48, and firmware version 5.0.51.
    * For proper functionality the reader must be in the multi card mode. The RF field can be switched on by functions ReaderRfOn, EnumCards, or  DisableAnticolision.
    * 
    * @ingroup Miscellaneous_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReaderRfOffM(UFR_HANDLE hndUFR);

    /**
    * EXCLUDE FROM DOCUMENTATION
    * @ingroup INTERNAL
    */
    UFR_STATUS DL_API WriteReaderIdM(UFR_HANDLE hndUFR, uint8_t *reader_id);

    /**
    * @brief Multi reader support. Security level 0 command.
    * Function is used to change the data and AES keys from the initial delivery configuration to a customer specific value.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param address Number of block or key
    * @param data Value of data or AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_WritePersoM(UFR_HANDLE hndUFR, uint16_t address, IN uint8_t *data);

    /**
    * @brief Multi reader support. Security level 0 command.
    * Function is used to finalize the personalization and switch up to security level 1.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_CommitPersoM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. Security level 0 command.
    * Function is used for card personalization. The minimum number of AES keys is entered into the card. There are card master key, card configuration key, key for switch to security level 2, key for switch to security level 3, security level 1 authentication key, virtual card select key, proximity check key, VC polling ENC and VC poling MAC key. Keys can not be changed at security level 1.
    * Other keys that are not personalized will have value 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF)
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param card_master_key pointer to 16 byte array containing the card master key
    * @param card_config_key pointer to 16 byte array containing the card configuration key
    * @param level_2_switch_key pointer to 16 byte array containing the key for switch to security level 2
    * @param level_3_switch_key pointer to 16 byte array containing the key for switch to security level 3
    * @param level_1_auth_key pointer to 16 byte array containing the key for optional authentication at security level 1
    * @param select_vc_key pointer to 16 byte array containing the key for virtual card selection
    * @param prox_chk_key pointer to 16 byte array containing the key for proximity check
    * @param vc_poll_enc_key pointer to 16 byte array containing the ENC key for virtual card polling
    * @param vc_poll_mac_key pointer to 16 byte array containing the MAC key for virtual card polling
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_PersonalizationMinimalM(UFR_HANDLE hndUFR, IN uint8_t *card_master_key, IN uint8_t *card_config_key,
                                                  IN uint8_t *level_2_switch_key, IN uint8_t *level_3_switch_key, IN uint8_t *level_1_auth_key,
                                                  IN uint8_t *select_vc_key, IN uint8_t *prox_chk_key, IN uint8_t *vc_poll_enc_key,
                                                  IN uint8_t *vc_poll_mac_key);

    /**
    * @brief Multi reader support. Security level 1 or 2 command.
    * Function is used to switch to security level 3.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index ordinary number of AES key stored into reader (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_SwitchToSecurityLevel3M(UFR_HANDLE hndUFR, uint8_t key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 1 or 2 command.
    * Function is used to switch to security level 3.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key pointer to 16 byte array containing the AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_SwitchToSecurityLevel3_PKM(UFR_HANDLE hndUFR, IN uint8_t *aes_key);

    /**
    * @brief Multi reader support. Security level 1 command.
    * Security level 1 offers the same functionality as a MIFARE Classic card.
    * Function is used to optional AES authentication.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index ordinary number of AES key stored into reader (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_AesAuthSecurityLevel1M(UFR_HANDLE hndUFR, uint8_t key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 1 command.
    * Security level 1 offers the same functionality as a MIFARE Classic card.
    * Function is used to optional AES authentication.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key pointer to 16 byte array containing the AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_AesAuthSecurityLevel1_PKM(UFR_HANDLE hndUFR, IN uint8_t *aes_key);

    /**
    * @brief Multi reader support. Security level 3 command.
    * The function is used to change the AES card master key value.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index ordinary number of current configuration key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key pointer to 16 byte array containing the new master key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeMasterKeyM(UFR_HANDLE hndUFR, uint8_t key_index, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES card master key value.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index ordinary number of current configuration key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key_index ordinary number of current configuration key stored into reader that will become new key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeMasterKeySamKeyM(UFR_HANDLE hndUFR, uint8_t key_index, uint8_t new_key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES card master key value.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param old_key pointer to 16 byte array containing the current master key
    * @param new_key pointer to 16 byte array containing the new master key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeMasterKey_PKM(UFR_HANDLE hndUFR, IN uint8_t *old_key, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. Security level 3 command.
    * The function is used to change the AES card configuration key value.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index ordinary number of current configuration key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key pointer to 16 byte array containing the new configuration key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeConfigurationKeyM(UFR_HANDLE hndUFR, uint8_t key_index, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES card configuration key value.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index ordinary number of current configuration key stored into reader (0 - 15) or in SAM (1 - 127)
    * @param new_key_index ordinary number of current configuration key stored into reader that will become new key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeConfigurationKeySamKeyM(UFR_HANDLE hndUFR, uint8_t key_index, uint8_t new_key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES card configuration key value.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param old_key pointer to 16 byte array containing the current configuration key
    * @param new_key pointer to 16 byte array containing the new configuration key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeConfigurationKey_PKM(UFR_HANDLE hndUFR, IN uint8_t *old_key, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. Security level 3 command.
    * Function is used for definition of using Random ID and Proximity check options. Authentication with AES card configuration key required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key_index ordinary number of configuration key stored into reader (0 - 15)
    * @param rid_use 1 - Randnom ID enabled, 0 - Random ID disabled
    * @param prox_check_use 1- Proximity check is mandatory, 0 - Proximity check is not mandatory
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_FieldConfigurationSetM(UFR_HANDLE hndUFR, uint8_t configuration_key_index, uint8_t rid_use, uint8_t prox_check_use);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Security level 3 command.
    * Function is used for definition of using Random ID and Proximity check options. Authentication with AES card configuration key required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key_index ordinary number of configuration key stored into reader (0 - 15)
    * @param rid_use 1 - Randnom ID enabled, 0 - Random ID disabled
    * @param prox_check_use 1- Proximity check is mandatory, 0 - Proximity check is not mandatory
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_FieldConfigurationSetSamKeyM(UFR_HANDLE hndUFR, uint8_t configuration_key_index, uint8_t rid_use,
                                                       uint8_t prox_check_use);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 3 command.
    * Function is used for definition of using Random ID and Proximity check options. Authentication with AES card configuration key required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key pointer to 16 byte array containing the configuration key
    * @param rid_use 1 - Randnom ID enabled, 0 - Random ID disabled
    * @param prox_check_use 1- Proximity check is mandatory, 0 - Proximity check is not mandatory
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_FieldConfigurationSet_PKM(UFR_HANDLE hndUFR, IN uint8_t *configuration_key, uint8_t rid_use, uint8_t prox_check_use);

    /**
    * @brief Multi reader support. Security level 3 command.
    * In order to access the block in sector data, AES authentication is needed. Each sector has two AES keys that can be used for authentication (Key A and Key B).
    * Default value if key is not personalized is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF).
    * For linear read part of card, enter the same value of sector keys for all sectors which will be read at once.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card.
    * @param auth_mode MIFARE_AUTHENT1A for Key A  or MIFARE_AUTHENT1B for Kye B
    * @param key_index ordinary number of current sector key stored into reader (0 - 15)
    * @param new_key pointer to 16 byte array containing the new sector key (A or B)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKeyM(UFR_HANDLE hndUFR, uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Security level 3 command.
    * In order to access the block in sector data, AES authentication is needed. Each sector has two AES keys that can be used for authentication (Key A and Key B).
    * Default value if key is not personalized is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF).
    * For linear read part of card, enter the same value of sector keys for all sectors which will be read at once.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card.
    * @param auth_mode MIFARE_AUTHENT1A for Key A  or MIFARE_AUTHENT1B for Kye B
    * @param key_index ordinary number of current sector key stored into reader (0 - 15)
    * @param new_key_index ordinary number of current configuration key stored into reader that will become new key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKeySamKeyM(UFR_HANDLE hndUFR, uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index,
                                                 uint8_t new_key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 3 command.
    * In order to access the block in sector data, AES authentication is needed. Each sector has two AES keys that can be used for authentication (Key A and Key B).
    * Default value if key is not personalized is 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (16 x 0xFF).
    * For linear read part of card, enter the same value of sector keys for all sectors which will be read at once.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card.
    * @param auth_mode MIFARE_AUTHENT1A for Key A  or MIFARE_AUTHENT1B for Kye B
    * @param old_key pointer to 16 byte array containing the current sector key (A or B)
    * @param new_key pointer to 16 byte array containing the new sector key (A or B)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKey_PKM(UFR_HANDLE hndUFR, uint8_t sector_nr, uint8_t auth_mode, IN uint8_t *old_key, IN uint8_t *new_key);

    /**
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card
    * @param auth_mode MIFARE_AUTHENT1A for Key A or MIFARE_AUTHENT1B for Kye B
    * @param key_index ordinary number of current sector key stored into reader (0 - 15)
    * @param new_key pointer to 16 byte array containing the new sector key (A or B)
    * @param new_key_type AES_KEY_TYPE = 0, //AES 16 bytes DES3K_KEY_TYPE = 1, //3K3DES 24 bytes DES_KEY_TYPE = 2, //DES 8 bytes DES2K_KEY_TYPE = 3 //2K3DES 16 bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorExtKeyM(UFR_HANDLE hndUFR, uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index, IN uint8_t *new_key,
                                              uint8_t new_key_type);

    /**
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card
    * @param auth_mode MIFARE_AUTHENT1A for Key A or MIFARE_AUTHENT1B for Kye B
    * @param key_index ordinary number of current sector key stored into reader (0 - 15)
    * @param new_key_index ADordinary number of current sector key stored into reader that wile become new key
    * @param new_key_type AES_KEY_TYPE = 0, //AES 16 bytes DES3K_KEY_TYPE = 1, //3K3DES 24 bytes DES_KEY_TYPE = 2, //DES 8 bytes DES2K_KEY_TYPE = 3 //2K3DES 16 bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKeySamExtKeyM(UFR_HANDLE hndUFR, uint8_t sector_nr, uint8_t auth_mode, uint8_t key_index,
                                                    uint8_t new_key_index, uint8_t new_key_type);

    /**
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    * @ingroup UNDOCUMENTED
    *
    * @param hndUFR handle of the uFR device
    * @param sector_nr ordinary number of sector (0 - 31) for 2K card, or (0 - 39) for 4K card
    * @param auth_mode MIFARE_AUTHENT1A for Key A or MIFARE_AUTHENT1B for Kye B
    * @param old_key pointer to 16 byte array containing the current sector key (A or B)
    * @param new_key pointer to 16 byte array containing the new sector key (A or B)
    * @param new_key_type AES_KEY_TYPE = 0, //AES 16 bytes DES3K_KEY_TYPE = 1, //3K3DES 24 bytes DES_KEY_TYPE = 2, //DES 8 bytes DES2K_KEY_TYPE = 3 //2K3DES 16 bytes
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeSectorKeyExt_PKM(UFR_HANDLE hndUFR, uint8_t sector_nr, uint8_t auth_mode, IN uint8_t *old_key, IN uint8_t *new_key,
                                                 uint8_t new_key_type);

    /**
    * @brief Multi reader support. Security level 3 command.
    * Function is used to read UID if Random ID is enabled. Authentication with AES VC Polling ENC Key and VC Polling MAC Key is mandatory.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index_vc_poll_enc_key pointer to 16 byte array containing VC polling ENC key
    * @param key_index_vc_poll_mac_key pointer to 16 byte array containing VC polling MAC key
    * @param uid pointer to byte array containing the card UID
    * @param uid_len pointer to UID length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_GetUidM(UFR_HANDLE hndUFR, uint8_t key_index_vc_poll_enc_key, uint8_t key_index_vc_poll_mac_key, OUT uint8_t *uid,
                                  VAR uint8_t *uid_len);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Security level 3 command.
    * Function is used to read UID if Random ID is enabled. Authentication with AES VC Polling ENC Key and VC Polling MAC Key is mandatory.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param key_index_vc_poll_enc_key pointer to 16 byte array containing VC polling ENC key
    * @param key_index_vc_poll_mac_key pointer to 16 byte array containing VC polling MAC key
    * @param uid pointer to byte array containing the card UID
    * @param uid_len pointer to UID length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_GetUidSamKeyM(UFR_HANDLE hndUFR, uint8_t key_index_vc_poll_enc_key, uint8_t key_index_vc_poll_mac_key,
                                        OUT uint8_t *uid, VAR uint8_t *uid_len);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 3 command.
    * Function is used to read UID if Random ID is enabled. Authentication with AES VC Polling ENC Key and VC Polling MAC Key is mandatory.
    *
    * @param hndUFR handle of the uFR device
    * @param vc_poll_enc_key pointer to 16 byte array containing the ENC key for virtual card polling pointer to 16 byte array containing VC polling ENC key
    * @param vc_poll_mac_key pointer to 16 byte array containing VC polling MAC key
    * @param uid pointer to byte array containing the card UID
    * @param uid_len pointer to UID length variable
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_GetUid_PKM(UFR_HANDLE hndUFR, IN uint8_t *vc_poll_enc_key, IN uint8_t *vc_poll_mac_key, OUT uint8_t *uid,
                                     VAR uint8_t *uid_len);

    /**
    * @brief Multi reader support. Security level 3 command.
    * The function is used to change the AES VC polling ENC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key_index ordinary number of card configuration key stored into reader (0 - 15)
    * @param new_key pointer to 16 byte array containing new VC Polling ENC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingEncKeyM(UFR_HANDLE hndUFR, uint8_t configuration_key_index, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES VC polling ENC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key_index ordinary number of card configuration key stored into reader (0 - 15)
    * @param new_key_index ordinary number of card configuration key stored into reader that will become new key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingEncKeySamKeyM(UFR_HANDLE hndUFR, uint8_t configuration_key_index, uint8_t new_key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES VC polling ENC key value. Authentication with AES card configuration key is required.
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key pointer to 16 byte array containing card configuration key
    * @param new_key pointer to 16 byte array containing new VC Polling ENC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingEncKey_PKM(UFR_HANDLE hndUFR, IN uint8_t *configuration_key, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. Security level 3 command.
    * The function is used to change the AES VC polling MAC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key_index ordinary number of card configuration key stored into reader (0 - 15)
    * @param new_key pointer to 16 byte array containing new VC Polling MAC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingMacKeyM(UFR_HANDLE hndUFR, uint8_t configuration_key_index, IN uint8_t *new_key);

    /**
    * @brief Multi reader support. *only uFR CS with SAM support
    * Security level 3 command.
    * The function is used to change the AES VC polling MAC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key_index ordinary number of card configuration key stored into reader (0 - 15)
    * @param new_key_index ordinary number of card configuration key stored into reader that will become new key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingMacKeySamKeyM(UFR_HANDLE hndUFR, uint8_t configuration_key_index, uint8_t new_key_index);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Security level 3 command.
    * The function is used to change the AES VC polling MAC key value. Authentication with AES card configuration key is required.
    *
    * @ingroup Card_Tag_Mifare_Plus_M
    *
    * @param hndUFR handle of the uFR device
    * @param configuration_key pointer to 16 byte array containing card configuration key
    * @param new_key pointer to 16 byte array containing new VC Polling MAC key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API MFP_ChangeVcPollingMacKey_PKM(UFR_HANDLE hndUFR, IN uint8_t *configuration_key, IN uint8_t *new_key);

    // ULTRALIGHT C
    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * The 3DES authentication is executed using the transceive mode of reader. Pointer to array which contains 2K 3DES key (16 bytes ) is parameter of this functions. Function don’t use the key which stored into reader. DES algorithm for authentication executes in host device, not in reader.
    * After authentication, the reader leaves the transceive mode, but stay in mode where the HALT command doesn’t sending to the card. In this mode user can use functions for block and linear reading or writing. Reader stay into this mode, until the error during reading data from card,  or writing data into card occurs, or until the user calls function card_halt_enable().
    *
    * @ingroup Card_Tag_Ultralight_C_M
    *
    * @param hndUFR handle of the uFR device
    * @param key pointer to data array of 16 bytes which contains 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_ExternalAuth_PKM(UFR_HANDLE hndUFR, IN uint8_t *key);

    /**
    * @brief Multi reader support. No authentication
    * This function puts the reader in an “anti-collision” mode of operation.
    *
    * @ingroup Card_Tag_Ultralight_C_M
    *
    * @param hndUFR handle of the uFR device
    * @param new_3des_key pointer to array of 16 bytes which contains new 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_write_3des_key_no_authM(UFR_HANDLE hndUFR, IN uint8_t *new_3des_key);

    /**
    * @brief Multi reader support. This function puts the reader in an “anti-collision” mode of operation.
    *
    * @ingroup Card_Tag_Ultralight_C_M
    *
    * @param hndUFR handle of the uFR device
    * @param new_3des_key pointer to array of 16 bytes which contains new 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_write_3des_key_factory_keyM(UFR_HANDLE hndUFR, IN uint8_t *new_3des_key);

    /**
    * @brief Multi reader support. This function puts the reader in an “anti-collision” mode of operation.
    *
    * @ingroup Card_Tag_Ultralight_C_M
    *
    * @param hndUFR handle of the uFR device
    * @param new_3des_key pointer to array of 16 bytes which contains new 2K 3DES key
    * @param old_3des_key pointer to array of 16 bytes which contains current 2K 3DES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ULC_write_3des_keyM(UFR_HANDLE hndUFR, IN uint8_t *new_3des_key, IN uint8_t *old_3des_key);

    // ESP32
    /**
    * @brief Function enables sending data to the uFR Online. A string of data contains information about the intensity of color in each cell of the LED indication. 
    * 
    * Each cell has three LEDs (red, green and blue). For each cell of the three bytes is necessary. The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. For example, if the display has 2 cells, an array contains 6 bytes. Value of intensity is in the range from 0 to 255. On uFR Online, there are 2 cells.From firmware version 2.7.6, RGB LEDs can be connected to pin 5 of P5 connector (GPIO connector - ESP pin 18). First 6 bytes in display_data array will be sent to internal RGB LEDs, additional bytes will be sent to external connected RGB. There is no limit for number of external cells.
    * Array data example: 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    * First 6 bytes will be sent to internal RGB and additional 3 bytes will be sent to first cell of external RGB.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param display_data pointer to data array
    * @param data_length number of bytes into array
    * @param duration number of milliseconds to light. if value is 0, then rgb will light infinitely
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetDisplayData(IN uint8_t *display_data, IN uint8_t data_length, uint16_t duration);

    /**
    * @brief Physical reset of uFR reader communication port.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspReaderReset(void);

    /**
    * @brief It defines/changes password which I used for:
    * * Writing in EEPROM
    * * Setting date/time of RTC
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param old_password pointer to the 8 bytes array containing current password
    * @param new_password pointer to the 8 bytes array containing new password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspChangeReaderPassword(IN uint8_t *old_password, IN uint8_t *new_password);

    /**
    * @brief Function writes array of data into EEPROM of uFR Online. 
    * 
    * Maximal length of the array is 128 bytes. Function requires a password which is 8 bytes. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param data pointer to  array containing data from EEPROM
    * @param address address of first data
    * @param size length of array
    * @param password pointer to array containing password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspReaderEepromWrite(IN uint8_t *data, uint32_t address, uint32_t size, IN uint8_t *password);

    /**
    * @brief Function returns array of data read from EEPROM of uFR Online. Maximal length of the array is 128 bytes.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param data pointer to  array containing data from EEPROM
    * @param address address of first data
    * @param size length of array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspReaderEepromRead(OUT uint8_t *data, uint32_t address, uint32_t size);

    /**
    * @brief Function returns 6 bytes array of uint8_t that represents current date and time into uFR Online RTC.
    * 
    * * Byte 0 represent year (current year - 2000)
    * * Byte 1 represent month (1 - 12)
    * * Byte 2 represent day of the month (1 - 31)
    * * Byte 3 represent hour (0 - 23)
    * * Byte 4 represent minute (0 - 59)
    * * Byte 5 represent second (0 - 59)
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param time pointer to the array containing current date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetReaderTime(OUT uint8_t *time);

    /**
    * @brief Function sets the date and time into uFR Online RTC.
    * 
    * Function requires the 8 bytes password entry to set  date and time. Date and time are represented into a 6 bytes array in the same way as in EspGetReaderTime function. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param password pointer to the 8 bytes array containing password
    * @param time pointer to the 6 bytes array containing date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetReaderTime(IN uint8_t *password, IN uint8_t *time);

    /**
    * @brief Function sets uFR Online IO pin state.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param pin IO pin number (1 - 6)
    * @param state IO pin state 0 - low level, 1 - high level, 2 - input
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetIOState(uint8_t pin, uint8_t state);

    /**
    * @brief Function returns 6 bytes array of uint8_t that represented IO pins logic level state.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param state pointer to the 6 bytes array containing IO pins states
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetIOState(OUT uint8_t *state);

    /**
    * @brief Function sets uFR Online transparent reader.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param reader Transparent reader number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetTransparentReader(uint8_t reader);

    /**
    * @brief Returns uFR Online reader serial number as a pointer to 4 byte value.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param SerialNumber  pointer to SerialNumber variable. “SerialNumber “ as result holds 4 byte serial number value.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetReaderSerialNumber(VAR uint32_t *SerialNumber);

    /**
    * @brief Returns uFR Online reader firmware version.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param major Major firmware version
    * @param minor Minor firmware version
    * @param build Build firmware version
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetFirmwareVersion(OUT uint8_t *major, OUT uint8_t *minor, OUT uint8_t *build);

    /**
    * @brief Turn off uFR Online device.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspTurnOff(void);

    /**
    * @brief  This option is only avaliable in BT/BLE mode. Disable Wifi on uFR Online device when working in BLE/BT mode. This option is saved in flash and Wifi will stay turned off device restart. 
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspDisableWifi(void);

    /**
    * @brief This option is only avaliable in BT/BLE mode. Enable Wifi on uFR Online device when working in BLE/BT mode. This option is saved in flash and Wifi will stay turned on device restart. 
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspEnableWifi(void);

    
    /**
    * @brief uFR Zero Online update callback prototype
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @param status Get status based on READER_PROGRESS_STATUS enumeration. Can be transfer or process
    * @param progress Progress in percentage from 0 to 100
    * @param arg Additional oprional argument provided by EspUpdateFirmware function
    * 
    * @return 
    */
    typedef void (*UpdateProgressCallback)(READER_PROGRESS_STATUS status, int progress, void *arg);

    /**
    * @brief uFR Zero Online get firmware list from server for connected device
    * NOTE: Supports only uFR Online Zero series firmware version >= 3.0.34 
    * 
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @param option Option for setting uFR Zero Online main device or NFC part
    * @param current_version Returns current version of installed firmware. In case there is not firmware, it will return 0.0.0
    * @param versions Returns list of firmware versions and descriptions as string. Memory must be already allocated in main program. It must be two dimensional array
    * @param versions_size versions array size. This is maximum number of elements in array
    * @param returned_versions_size Returns how many elements are populated in array. This will be same as number of avaliable firmwares
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetFirmwaresList(READER_FLASH_OPTION option, char *current_version, char **versions, int versions_size, int *returned_versions_size);

    /**
    * @brief uFR Zero Online start firmware update
    * NOTE: Supports only uFR Online Zero series firmware version >= 3.0.34
    * 
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @param option Option for setting uFR Zero Online main device or NFC part
    * @param current_version Provide version to be updated. In must be in x.x.x or x.x.x - description
    * @param token Provide token in case of premium firmwares. It can be empty.
    * @param callback Pointer to update progress callback function
    * @param arg Optional argument that will be provided to callback function
    * 
    * @return Operation status. In case of UFR_AUTH_ERROR token must be provided
    */
    UFR_STATUS DL_API EspUpdateFirmware(READER_FLASH_OPTION option, const char *version, const char *token, UpdateProgressCallback callback, void *arg);


    // NDEF MESSAGES
    //----------------------------------------------------------

    enum NDEF_STORAGE_MODE
    {
        STORE_INTO_READER = 0,
        STORE_INTO_CARD
    };

    enum NDEF_SKYPE_ACTION
    {
        CALL = 0,
        CHAT
    };

    // WiFi NDEF authentication type
    enum WIFI_AUTH_TYPE
    {
        OPEN = 0,
        WPA_PERSONAL,
        WPA_ENTERPRISE,
        WPA2_ENTERPRISE,
        WPA2_PERSONAL
    };

    // WiFi NDEF encryption type
    enum WIFI_ENC_TYPE
    {
        NONE = 0,
        WEP,
        TKIP,
        AES,
        AES_TKIP
    };

    /**
    * @brief
    * Store WiFi configuration as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param ssid Pointer to the null-terminated string that should contain SSID name we want to connect to
    * @param auth_type Authentication type: 0 - OPEN 1 - WPA Personal 2 - WPA Enterprise 3 - WPA2 Enterprise 4 - WPA2 Personal
    * @param encryption_type Encryption type: 0 - NONE 1 - WEP 2 - TKIP 3 - AES 4 - AES/TKIP
    * @param password Pointer to the null-terminated string that should contain password of the SSID we want to connect to
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_WiFi(uint8_t ndef_storage, IN const char *ssid, uint8_t auth_type, uint8_t encryption_type,
                                           IN const char *password);

    /**
    * @brief Store BT MAC address for pairing as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param bt_mac_address Pointer to the null-terminated string that should contain BT MAC address for pairing in hex format (12 characters)(e.g.: “AABBCCDDEEFF”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_BT(uint8_t ndef_storage, IN const char *bt_mac_address);

    /**
    * @brief Store phone number and message data as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param phone_number Pointer to char array containing phone number
    * @param message Pointer to the null-terminated string that should contain message data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_SMS(uint8_t ndef_storage, IN const char *phone_number, IN const char *message);

    /**
    * @brief Store bitcoin address, amount and donation message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param bitcoin_address Pointer to the null-terminated string that should contain bitcoin address
    * @param amount Pointer to the null-terminated string that should contain amount (e.g.: “1.0”)
    * @param message Pointer to the null-terminated string that should contain donation message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Bitcoin(uint8_t ndef_storage, IN const char *bitcoin_address, IN const char *amount,
                                              IN const char *message);

    /**
    * @brief Store latitude and longitude as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    *  @param latitude Pointer to the null-terminated string that should contain latitude (e.g.: “44.6229337”)
    * @param longitude Pointer to the null-terminated string that should contain longitude (e.g.: “21.1787368”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_GeoLocation(uint8_t ndef_storage, IN const char *latitude, IN const char *longitude);

    /**
    * @brief Store wanted destination as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param destination Pointer to the null-terminated string that should contain city, street name or some other destination
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_NaviDestination(uint8_t ndef_storage, IN const char *destination);

    /**
    * @brief Store email message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param email_address Pointer to the null-terminated string that should contain recipient email address
    * @param subject Pointer to the null-terminated string that should contain subject
    * @param message Pointer to the null-terminated string that should contain message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Email(uint8_t ndef_storage, IN const char *email_address, IN const char *subject, IN const char *message);

    /**
    * @brief Store address (city, street name, etc) as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param address Pointer to the null-terminated string that should contain city name, street name, etc.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Address(uint8_t ndef_storage, IN const char *address);

    /**
    * @brief Store android app package name as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param package_name Pointer to the null-terminated string that should contain android app packagne name
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_AndroidApp(uint8_t ndef_storage, IN const char *package_name);

    /**
    * @brief Store text as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param text Pointer to the null-terminated string that should contain text
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Text(uint8_t ndef_storage, IN const char *text);

    /**
    * @brief Store latitude and longitude as NDEF message into reader or into card for Google StreetView.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param latitude Pointer to the null-terminated string that should contain latitude (e.g.: “44.6229337”)
    * @param longitude Pointer to the null-terminated string that should contain longitude (e.g.: “21.1787368”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_StreetView(uint8_t ndef_storage, IN const char *latitude, IN const char *longitude);

    /**
    * @brief Store skype username as NDEF message into reader or into card for call or chat.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param user_name pointer to the null-terminated string that should contain skype username
    * @param action Action type: call - 0 chat - 1
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Skype(uint8_t ndef_storage, IN const char *user_name, uint8_t action);

    /**
    * @brief Store Whatsapp message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param message Pointer to the null-terminated string that should contain Whatsapp message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Whatsapp(uint8_t ndef_storage, IN const char *message);

    /**
    * @brief Store Viber message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param message Pointer to the null-terminated string that should contain Viber message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Viber(uint8_t ndef_storage, IN const char *message);

    /**
    * @brief Store phone contact as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param name pointer to the null-terminated string that should contain contact display name
    * @param company pointer to the null-terminated string that should contain contact company name
    * @param address Pointer to the null-terminated string that should contain contact residental address
    * @param phone pointer to the null-terminated string that should contain contact phone number
    * @param email pointer to the null-terminated string that should contain contact email address
    * @param website pointer to the null-terminated string that should contain contact website
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Contact(uint8_t ndef_storage, IN const char *name, IN const char *company, IN const char *address,
                                              IN const char *phone, IN const char *email, IN const char *website);

    /**
    * @brief Store phone_number as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param phone_number Pointer to char array containing phone number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_Phone(uint8_t ndef_storage, IN const char *phone_number);

    /**
    * @brief Multi reader support. Store WiFi configuration as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param ssid Pointer to the null-terminated string that should contain SSID name we want to connect to
    * @param auth_type Authentication type: 0 - OPEN 1 - WPA Personal 2 - WPA Enterprise 3 - WPA2 Enterprise 4 - WPA2 Personal
    * @param encryption_type Encryption type: 0 - NONE 1 - WEP 2 - TKIP 3 - AES 4 - AES/TKIP
    * @param password Pointer to the null-terminated string that should contain password of the SSID we want to connect to
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_WiFiM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *ssid, uint8_t auth_type,
                                            uint8_t encryption_type, IN const char *password);

    /**
    * @brief Multi reader support. Store BT MAC address for pairing as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param bt_mac_address Pointer to the null-terminated string that should contain BT MAC address for pairing in hex format (12 characters) (e.g.: “AABBCCDDEEFF”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_BTM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *bt_mac_address);

    /**
    * @brief Multi reader support. Store phone number and message data as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param phone_number Pointer to char array containing phone number
    * @param message Pointer to the null-terminated string that should contain message data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_SMSM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *phone_number, IN const char *message);

    /**
    * @brief Multi reader support. Store bitcoin address, amount and donation message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param bitcoin_address Pointer to the null-terminated string that should contain bitcoin address
    * @param amount Pointer to the null-terminated string that should contain amount (e.g.: “1.0”)
    * @param message Pointer to the null-terminated string that should contain donation message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_BitcoinM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *bitcoin_address, IN const char *amount,
                                               IN const char *message);

    /**
    * @brief Multi reader support. Store latitude and longitude as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    *  @param latitude Pointer to the null-terminated string that should contain latitude (e.g.: “44.6229337”)
    * @param longitude Pointer to the null-terminated string that should contain longitude (e.g.: “21.1787368”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_GeoLocationM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *latitude, IN const char *longitude);

    /**
    * @brief Multi reader support. Store wanted destination as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param destination Pointer to the null-terminated string that should contain city, street name or some other destination
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_NaviDestinationM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *destination);

    /**
    * @brief Multi reader support. Store email message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param email_address Pointer to the null-terminated string that should contain recipient email address
    * @param subject Pointer to the null-terminated string that should contain subject
    * @param message Pointer to the null-terminated string that should contain message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_EmailM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *email_address, IN const char *subject,
                                             IN const char *message);

    /**
    * @brief Multi reader support. Store address (city, street name, etc) as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param address Pointer to the null-terminated string that should contain city name, street name, etc.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_AddressM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *address);

    /**
    * @brief Multi reader support. Store android app package name as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param package_name Pointer to the null-terminated string that should contain android app packagne name
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_AndroidAppM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *package_name);

    /**
    * @brief Multi reader support. Store text as NDEF message into reader or into card.
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param text Pointer to the null-terminated string that should contain text
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_TextM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *text);

    /**
    * @brief Multi reader support. Store latitude and longitude as NDEF message into reader or into card for Google StreetView.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param latitude Pointer to the null-terminated string that should contain latitude (e.g.: “44.6229337”)
    * @param longitude Pointer to the null-terminated string that should contain longitude (e.g.: “21.1787368”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_StreetViewM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *latitude, IN const char *longitude);

    /**
    * @brief Multi reader support. Store skype username as NDEF message into reader or into card for call or chat.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param user_name pointer to the null-terminated string that should contain skype username
    * @param action Action type: call - 0 chat - 1
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_SkypeM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *user_name, uint8_t action);

    /**
    * @brief Multi reader support. Store Whatsapp message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param message Pointer to the null-terminated string that should contain Whatsapp message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_WhatsappM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *message);

    /**
    * @brief Multi reader support. Store Viber message as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param message Pointer to the null-terminated string that should contain Viber message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_ViberM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *message);

    /**
    * @brief Multi reader support. Store phone contact as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param name pointer to the null-terminated string that should contain contact display name
    * @param company pointer to the null-terminated string that should contain contact company name
    * @param address Pointer to the null-terminated string that should contain contact residental address
    * @param phone pointer to the null-terminated string that should contain contact phone number
    * @param email pointer to the null-terminated string that should contain contact email address
    * @param website pointer to the null-terminated string that should contain contact website
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_ContactM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *name, IN const char *company,
                                               IN const char *address, IN const char *phone, IN const char *email, IN const char *website);

    /**
    * @brief Multi reader support. Store phone_number as NDEF message into reader or into card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ndef_storage Store NDEF into: reader - 0, card - 1 From library 5.0.31 and firmware 5.0.33 2 - reader RAM
    * @param phone_number Pointer to char array containing phone number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API WriteNdefRecord_PhoneM(UFR_HANDLE hndUFR, uint8_t ndef_storage, IN const char *phone_number);
    //---------------------------------------------------------------------------------------------
    /**
    * @brief Reads NDEF WiFi configuration from card..
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param ssid Pointer to char array containing SSID name
    * @param auth_type Pointer to char array containing authentication type
    * @param encryption_type Pointer to char array containing encryption type
    * @param password Pointer to char array containing password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_WiFi(OUT char *ssid, OUT char *auth_type, OUT char *encryption_type, OUT char *password);

    /**
    * @brief Reads NDEF bitcoin address, amount and donation message from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param bitcoin_address Pointer to char array containing bitcoin_address
    * @param amount Pointer to char array containing bitcoin amount
    * @param message Pointer to char array containing donation message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Bitcoin(OUT char *bitcoin_address, OUT char *amount, OUT char *message);

    /**
    * @brief Reads NDEF latitude and longitude from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param latitude Pointer to char array containing latitude
    * @param longitude Pointer to char array containing longitude
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_GeoLocation(OUT char *latitude, OUT char *longitude);

    /**
    * @brief Reads NDEF navigation destination from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param destination Pointer to char array containing destination
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_NaviDestination(OUT char *destination);

    /**
    * @brief Reads NDEF email address, subject and message from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param email_address Pointer to char array containing recipient email address
    * @param subject Pointer to char array containing subject
    * @param message Pointer to char array containing message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Email(OUT char *email_address, OUT char *subject, OUT char *message);

    /**
    * @brief Reads NDEF address (city, street name,etc) from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param address Pointer to char array containing address
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Address(OUT char *address);

    /**
    * @brief Reads android app package name stored as NDEF record
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param package_name Pointer to the null-terminated string that should contain android app package name
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_AndroidApp(OUT char *package_name);

    /**
    * @brief Reads NDEF text from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param text Pointer to char array containing text
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Text(OUT char *text);

    /**
    * @brief Reads NDEF latitude and longitude for Google StreetView from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param latitude Pointer to char array containing latitude
    * @param longitude Pointer to char array containing longitude
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_StreetView(OUT char *latitude, OUT char *longitude);

    /**
    * @brief Reads NDEF skype username and action from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param user_name pointer to the null-terminated string that should contain skype username
    * @param action Pointer to char array containing Skype action (“call” or “chat”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Skype(OUT char *user_name, OUT char *action);

    /**
    * @brief Reads NDEF Whatsapp message from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message Pointer to char array containing Whatsapp message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Whatsapp(OUT char *message);

    /**
    * @brief Reads NDEF Viber message from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param message Pointer to char array containing Viber message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Viber(OUT char *message);

    /**
    * @brief Reads NDEF phone contact from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param vCard Pointer to char array containing phone contact data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Contact(OUT char *vCard);

    /**
    * @brief Reads NDEF phone number from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param phone_number Pointer to char array containing phone number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_Phone(OUT char *phone_number);

    /**
    * @brief Reads NDEF phone number and message from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param phone_number Pointer to char array containing phone number
    * @param message Pointer to char array containing message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_SMS(OUT char *phone_number, OUT char *message);

    /**
    * @brief Reads NDEF Bluetooth MAC address for pairing from card.
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param bt_mac_address Pointer to char array containing Bluetooth MAC address
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_BT(OUT char *bt_mac_address);

    /**
    * @brief Multi reader support. Reads NDEF WiFi configuration from card..
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param ssid Pointer to char array containing SSID name
    * @param auth_type Pointer to char array containing authentication type
    * @param encryption_type Pointer to char array containing encryption type
    * @param password Pointer to char array containing password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_WiFiM(UFR_HANDLE hndUFR, OUT char *ssid, OUT char *auth_type, OUT char *encryption_type,
                                           OUT char *password);

    /**
    * @brief Multi reader support. Reads NDEF bitcoin address, amount and donation message from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param bitcoin_address Pointer to char array containing bitcoin_address
    * @param amount Pointer to char array containing bitcoin amount
    * @param message Pointer to char array containing donation message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_BitcoinM(UFR_HANDLE hndUFR, OUT char *bitcoin_address, OUT char *amount, OUT char *message);

    /**
    * @brief Multi reader support. Reads NDEF latitude and longitude from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param latitude Pointer to char array containing latitude
    * @param longitude Pointer to char array containing longitude
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_GeoLocationM(UFR_HANDLE hndUFR, OUT char *latitude, OUT char *longitude);

    /**
    * @brief Multi reader support. Reads NDEF navigation destination from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param destination Pointer to char array containing destination
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_NaviDestinationM(UFR_HANDLE hndUFR, OUT char *destination);

    /**
    * @brief Multi reader support. Reads NDEF email address, subject and message from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param email_address Pointer to char array containing recipient email address
    * @param subject Pointer to char array containing subject
    * @param message Pointer to char array containing message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_EmailM(UFR_HANDLE hndUFR, OUT char *email_address, OUT char *subject, OUT char *message);

    /**
    * @brief Multi reader support. Reads NDEF address (city, street name,etc) from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param address Pointer to char array containing address
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_AddressM(UFR_HANDLE hndUFR, OUT char *address);

    /**
    * @brief Reads android app package name stored as NDEF record
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param package_name Pointer to the null-terminated string that should contain android app package name
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_AndroidAppM(UFR_HANDLE hndUFR, OUT char *package_name);

    /**
    * @brief Multi reader support. Reads NDEF text from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param text Pointer to char array containing text
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_TextM(UFR_HANDLE hndUFR, OUT char *text);

    /**
    * @brief Multi reader support. Reads NDEF latitude and longitude for Google StreetView from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param latitude Pointer to char array containing latitude
    * @param longitude Pointer to char array containing longitude
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_StreetViewM(UFR_HANDLE hndUFR, OUT char *latitude, OUT char *longitude);

    /**
    * @brief Multi reader support. Reads NDEF skype username and action from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param user_name pointer to the null-terminated string that should contain skype username
    * @param action Pointer to char array containing Skype action (“call” or “chat”)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_SkypeM(UFR_HANDLE hndUFR, OUT char *user_name, OUT char *action);

    /**
    * @brief Multi reader support. Reads NDEF Whatsapp message from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message Pointer to char array containing Whatsapp message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_WhatsappM(UFR_HANDLE hndUFR, OUT char *message);

    /**
    * @brief Multi reader support. Reads NDEF Viber message from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param message Pointer to char array containing Viber message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_ViberM(UFR_HANDLE hndUFR, OUT char *message);

    /**
    * @brief Multi reader support. Reads NDEF phone contact from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param vCard Pointer to char array containing phone contact data
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_ContactM(UFR_HANDLE hndUFR, OUT char *vCard);

    /**
    * @brief Multi reader support. Reads NDEF phone number from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param phone_number Pointer to char array containing phone number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_PhoneM(UFR_HANDLE hndUFR, OUT char *phone_number);

    /**
    * @brief Multi reader support. Reads NDEF phone number and message from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param phone_number Pointer to char array containing phone number
    * @param message Pointer to char array containing message
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_SMSM(UFR_HANDLE hndUFR, OUT char *phone_number, OUT char *message);

    /**
    * @brief Multi reader support. Reads NDEF Bluetooth MAC address for pairing from card.
    *
    * @ingroup Card_Tag_NDEF_M
    *
    * @param hndUFR handle of the uFR device
    * @param bt_mac_address Pointer to char array containing Bluetooth MAC address
    *
    * @return Operation status
    */
    UFR_STATUS DL_API ReadNdefRecord_BTM(UFR_HANDLE hndUFR, OUT char *bt_mac_address);

    /**
    * @brief Used to parse NDEF record into separate parameters
    *
    * @ingroup Card_Tag_NDEF
    *
    * @param type_record pointer to the array containing record type
    * @param type_len length of the record type
    * @param payload pointer to the array containing record payload
    * @param payload_len length of the record payload
    *
    * @return Operation status
    */
    c_string DL_API ParseNdefMessage(IN uint8_t *type_record, uint8_t type_len, IN uint8_t *payload, uint32_t payload_len);

    // NT4H

    /**
    * @brief Multi reader support. Function sets file number, key number, and communication mode, before the using functions for reading and writing data into cards  which are used for NTAG 2xx cards. This makes it possible to use existing functions for the block and linear reading and writing.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 and NTAG 424 TT - 1 to 3
    * @param key_no NTAG 413 - 0 to 2 NTAG 424 and NTAG 424 TT - 0 to 4
    * @param communication_mode  0 - plain, 1 - MACed, 3 - enciphered
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_set_global_parametersM(UFR_HANDLE hndUFR, uint8_t file_no, uint8_t key_no, uint8_t communication_mode);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * The function changes the access parameters of an existing standard data file. The communication mode can be either plain or enciphered based on current access rights of the file, so current communication mode must be entered. Access rights are similar for Desfire cards.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 and NTAG 424 TT - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 and NTAG 424 TT - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no reading key number
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_standard_file_settings_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                             uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief Multi reader support. The function changes the access parameters of an existing standard data file. The communication mode can be either plain or enciphered based on current access rights of the file, so current communication mode must be entered. Access rights are similar for Desfire cards.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 and NTAG 424 TT - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 and NTAG 424 TT - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no reading key number
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_standard_file_settingsM(UFR_HANDLE hndUFR, uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                          uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file. Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG 424 only)  0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC read_crt_limit value of SDM reading counter limit
    * @param read_ctr_limit value of SDM reading counter limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_sdm_file_settings_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                        uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                        uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                        uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                        uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                        uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit);

    /**
    * @brief Multi reader support. Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file. Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no NTAG 413 - 1 or 2 NTAG 424 - 1 to 3
    * @param key_no current change key number NTAG 413 - 0 to 2 NTAG 424 - 0 to 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG 424 only)  0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC read_crt_limit value of SDM reading counter limit
    * @param read_ctr_limit value of SDM reading counter limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_sdm_file_settingsM(UFR_HANDLE hndUFR, uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                     uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                     uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                     uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                     uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                     uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit);

    /**
    * @brief Multi reader support. Function returns file settings.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param file_no NTAG 413 - 1 or 2, NTAG 424 - 1 to 3
    * @param file_type 0 - standard data file
    * @param communication_mode communication mode, 0 - plain, 1 - MACed, 3 - enciphered
    * @param sdm_enable 0 - SDM disabled, 1 - SDM enabled
    * @param file_size file size in bytes
    * @param read_key_no reading key number
    * @param write_key_no  writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG424 only) 0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_file_settingsM(UFR_HANDLE hndUFR, uint8_t file_no, VAR uint8_t *file_type, VAR uint8_t *communication_mode, VAR uint8_t *sdm_enable, VAR uint32_t *file_size,
                                              VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                              VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                              VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                              VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                              VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Function enables card Random ID. Authentication with application master key (key number 0) required.
    * Warning. This operation is ireversibile.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_set_rid_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext);

    /**
    * @brief Multi reader support. Function enables card Random ID. Authentication with application master key (key number 0) required.
    * Warning. This operation is ireversibile.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_set_ridM(UFR_HANDLE hndUFR, uint8_t aes_key_no);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Function returns card UID if Random ID activated. Valid authentication is required.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key pointer to array contained AES key
    * @param key_no card key no used for authentication
    * @param uid pointer to array contained UID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_uid_pkM(UFR_HANDLE hndUFR, IN uint8_t *auth_key, uint8_t key_no, OUT uint8_t *uid);

    /**
    * @brief Multi reader support. Function returns card UID if Random ID activated. Valid authentication is required.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key_no ordinal number of AES key into reader (0 - 15)
    * @param key_no card key no used for authentication
    * @param uid pointer to array contained UID
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_uidM(UFR_HANDLE hndUFR, uint8_t auth_key_no, uint8_t key_no, OUT uint8_t *uid);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Function changes AES key. Authentication with the application master key is required.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key pointer to array contained AES key
    * @param key_no key number 0 - 2 or 0 - 4
    * @param new_key pointer to array contained new AES key
    * @param old_key pointer to array contained current AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_key_pkM(UFR_HANDLE hndUFR, IN uint8_t *auth_key, uint8_t key_no, IN uint8_t *new_key, IN uint8_t *old_key);

    /**
    * @brief Multi reader support. Function changes AES key. Authentication with the application master key is required.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key_no ordinal number of AES key into reader (0 - 15)
    * @param key_no key number 0 - 2 or 0 - 4
    * @param new_key pointer to array contained new AES key
    * @param old_key pointer to array contained current AES key
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_change_keyM(UFR_HANDLE hndUFR, uint8_t auth_key_no, uint8_t key_no, IN uint8_t *new_key, IN uint8_t *old_key);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * Function supports retrieving of the current values of SDM reading counter.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key pointer to array contained AES key
    * @param file_no file number of SDM file (2)
    * @param key_no key number 0 - 2 or 0 - 4
    * @param sdm_read_ctr pointer to value of SDM reading counter
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_sdm_ctr_pkM(UFR_HANDLE hndUFR, IN uint8_t *auth_key, uint8_t file_no, uint8_t key_no, VAR uint32_t *sdm_read_ctr);

    /**
    * @brief Multi reader support. Function supports retrieving of the current values of SDM reading counter.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no file number of SDM file (2)
    * @param key_no key number 0 - 2 or 0 - 4
    * @param sdm_read_ctr pointer to value of SDM reading counter
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_sdm_ctrM(UFR_HANDLE hndUFR, uint8_t auth_key_no, uint8_t file_no, uint8_t key_no, VAR uint32_t *sdm_read_ctr);

    /**
    * @brief Multi reader support. No authentication
    * Function supports retrieving of the current values of SDM reading counter.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param file_no file number of SDM file (2)
    * @param sdm_read_ctr pointer to value of SDM reading counter
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_sdm_ctr_no_authM(UFR_HANDLE hndUFR, uint8_t file_no, VAR uint32_t *sdm_read_ctr);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file. Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no 1 - 3
    * @param key_no current change key number 0 - 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param tt_status_enable tag tamper status mirroring (0 - disabled, 1 - enabled)
    * @param tt_status_offset mirror position of tag tamper status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_tt_change_sdm_file_settings_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                           uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                           uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                           uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                           uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                           uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                           uint8_t tt_status_enable, uint32_t tt_status_offset);

    /**
    * @brief Multi reader support. NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function allows change parameters for secure dynamic messaging file, or change file type from standard data file to secure dynamic messaging file. Due to the large number of parameters, the function is separated from the function for creating a standard data file.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param file_no 1 - 3
    * @param key_no current change key number 0 - 4
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain
    * @param read_key_no reading key number (14 free access)
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4, 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data
    * @param enc_length length of encrypted part of file data
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param tt_status_enable tag tamper status mirroring (0 - disabled, 1 - enabled)
    * @param tt_status_offset mirror position of tag tamper status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_tt_change_sdm_file_settingsM(UFR_HANDLE hndUFR, uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                        uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no,
                                                        uint8_t uid_enable, uint8_t read_ctr_enable, uint8_t read_ctr_limit_enable, uint8_t enc_file_data_enable,
                                                        uint8_t meta_data_key_no, uint8_t file_data_read_key_no, uint8_t read_ctr_key_no,
                                                        uint32_t uid_offset, uint32_t read_ctr_offset, uint32_t picc_data_offset, uint32_t mac_input_offset,
                                                        uint32_t enc_offset, uint32_t enc_length, uint32_t mac_offset, uint32_t read_ctr_limit,
                                                        uint8_t tt_status_enable, uint32_t tt_status_offset);

    /**
    * @brief Multi reader support. NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param file_no NTAG 413 - 1 or 2; NTAG 424 - 1 to 3
    * @param file_type 0 - standard data file
    * @param communication_mode communication mode, 0 - plain, 1 - MACed, 3 - enciphered
    * @param sdm_enable 0 - SDM disabled, 1 - SDM enabled
    * @param file_size file size in bytes
    * @param read_key_no reading key number
    * @param write_key_no writing key number
    * @param read_write_key_no reading and writing key number
    * @param change_key_no new change key number
    * @param uid_enable UID mirroring (0 - disabled, 1 - enabled)
    * @param read_ctr_enable SDM reading counter (0 - disabled, 1 - enabled)
    * @param read_ctr_limit_enable SDM reading counter limit (0 - disabled, 1 - enabled)
    * @param enc_file_data_enable using encrypted part of file data (NTAG 424 only) (0 - disabled, 1 - enabled)
    * @param meta_data_key_no key number for PICC data (UID and SDM read ctr) encryption 0 - 4 (NTAG 424 only), 14 no encryption, 15 no PICC data
    * @param file_data_read_key_no key number for MAC and encrypted part of file data (NTAG424 only) 0 - 2 or 0 - 4, 15 no MAC
    * @param read_ctr_key_no key number for SDM reading counter retrieving 0 - 2 or 0 - 4, 14 free, 15 no access
    * @param uid_offset mirror position of UID if PICC data aren’t encrypted
    * @param read_ctr_offset mirror position of SDM reading counter if PICC data aren’t encrypted
    * @param picc_data_offset mirror position of encrypted PICC data (NTAG 424 only)
    * @param mac_input_offset offset in the file where the SDM MAC computation starts
    * @param enc_offset mirror position of encrypted part of file data (NTAG 424 only)
    * @param enc_length length of encrypted part of file data (NTAG 424 only)
    * @param mac_offset mirror position of SDM MAC
    * @param read_ctr_limit value of SDM reading counter limit
    * @param tt_status_enable tag tamper status (0 - disabled, 1 - enabled)
    * @param tt_status_offset mirror position of tag tamper status
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_tt_get_file_settingsM(UFR_HANDLE hndUFR, uint8_t file_no, VAR uint8_t *file_type, VAR uint8_t *communication_mode, VAR uint8_t *sdm_enable, VAR uint32_t *file_size,
                                                 VAR uint8_t *read_key_no, VAR uint8_t *write_key_no, VAR uint8_t *read_write_key_no, VAR uint8_t *change_key_no,
                                                 VAR uint8_t *uid_enable, VAR uint8_t *read_ctr_enable, VAR uint8_t *read_ctr_limit_enable, VAR uint8_t *enc_file_data_enable,
                                                 VAR uint8_t *meta_data_key_no, VAR uint8_t *file_data_read_key_no, VAR uint8_t *read_ctr_key_no,
                                                 VAR uint32_t *uid_offset, VAR uint32_t *read_ctr_offset, VAR uint32_t *picc_data_offset, VAR uint32_t *mac_input_offset,
                                                 VAR uint32_t *enc_offset, VAR uint32_t *enc_length, VAR uint32_t *mac_offset, VAR uint32_t *read_ctr_limit,
                                                 VAR uint8_t *tt_status_enable, VAR uint32_t *tt_status_offset);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * From library version 5.0.43 and firmware version 5.0.43.
    * Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA) when the Random ID is activated. Authentication with valid key required.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key pointer to array contained AES key auth_key_nr ordinal number of AES key into reader (0 - 15)
    * @param key_no 0 - 4
    * @param uid 7 bytes UID length
    * @param ecc_signature 56 bytes ECC signature
    * @param dlogic_card_type card type value based on DLogic CardType enumeration
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_rid_read_ecc_signature_pkM(UFR_HANDLE hndUFR, IN uint8_t *auth_key, uint8_t key_no, OUT uint8_t *uid,
                                                      OUT uint8_t *ecc_signature, VAR uint8_t *dlogic_card_type);

    /**
    * @brief Multi reader support. From library version 5.0.43 and firmware version 5.0.43.
    * Function retrieves the asymmetric originality signature based on an asymmetric cryptographic algorithm Elliptic Curve Cryptography Digital Signature Algorithm (ECDSA) when the Random ID is activated. Authentication with valid key required.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param auth_key_nr ordinal number of AES key into reader (0 - 15)
    * @param key_no 0 - 4
    * @param uid 7 bytes UID length
    * @param ecc_signature 56 bytes ECC signature
    * @param dlogic_card_type card type value based on DLogic CardType enumeration
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_rid_read_ecc_signatureM(UFR_HANDLE hndUFR, uint8_t auth_key_nr, uint8_t key_no, OUT uint8_t *uid,
                                                   OUT uint8_t *ecc_signature, OUT uint8_t *dlogic_card_type);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function supports retrieving of the permanent and current Tag Tamper Status.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key
    * @param key_no 0 - 4 *uid 7 bytes UID length *ecc_signature 56 bytes ECC signature *dlogic_card_type
    * @param tt_perm_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    * @param tt_curr_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_tt_status_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t key_no, VAR uint8_t *tt_perm_status, VAR uint8_t *tt_curr_status);

    /**
    * @brief Multi reader support. NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function supports retrieving of the permanent and current Tag Tamper Status.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_nr ordinal number of AES key into reader (0 - 15)
    * @param key_no 0 - 4 *uid 7 bytes UID length *ecc_signature 56 bytes ECC signature *dlogic_card_type
    * @param tt_perm_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    * @param tt_curr_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_tt_statusM(UFR_HANDLE hndUFR, uint8_t aes_key_nr, uint8_t key_no, VAR uint8_t *tt_perm_status, VAR uint8_t *tt_curr_status);

    /**
    * @brief Multi reader support. No authentication
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function supports retrieving of the permanent and current Tag Tamper Status.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param tt_perm_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    * @param tt_curr_status tag tamper permanent status: I - invalid status, feature not activated; C - tamper seal closed; O - tamper seal opened
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_get_tt_status_no_authM(UFR_HANDLE hndUFR, VAR uint8_t *tt_perm_status, VAR uint8_t *tt_curr_status);

    /**
    * @brief Multi reader support. Provided Key mode (PK)
    * NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function enabling tag tamper feature. Authentication with application master key (key number 0) required.
    * Warning. Enabling the Tag Tamper feature is permanent, it cannot be disabled once enabled.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key
    * @param tt_status_key_no 0 - 4, 14 free access
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_enable_tt_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t tt_status_key_no);

    /**
    * @brief Multi reader support. NTAG 424 TT only. From library version 5.0.43 and firmware version 5.0.43.
    * Function enabling tag tamper feature. Authentication with application master key (key number 0) required.
    * Warning. Enabling the Tag Tamper feature is permanent, it cannot be disabled once enabled.
    *
    * @ingroup Card_Tag_NT4H_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_no ordinal number of AES key into reader (0 - 15)
    * @param tt_status_key_no 0 - 4, 14 free access
    *
    * @return Operation status
    */
    UFR_STATUS DL_API nt4h_enable_ttM(UFR_HANDLE hndUFR, uint8_t aes_key_no, uint8_t tt_status_key_no);

    /**
    * @brief Multi reader support. From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function changes file settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number 0, 1, 3, 4, 15 or 31
    * @param key_no current change key no
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no read key number (0 - 4)
    * @param write_key_no write key number (0 - 4)
    * @param read_write_key_no read write key number (0 - 4)
    * @param change_key_no change key number (0 - 4)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_change_file_settings_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                   uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief Multi reader support. From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function changes file settings.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number 0, 1, 3, 4, 15 or 31
    * @param key_no current change key no
    * @param curr_communication_mode current communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param new_communication_mode new communication mode 0 - plain, 1 - MACed, 3 - enciphered
    * @param read_key_no read key number (0 - 4)
    * @param write_key_no write key number (0 - 4)
    * @param read_write_key_no read write key number (0 - 4)
    * @param change_key_no change key number (0 - 4)
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_change_file_settingsM(UFR_HANDLE hndUFR, uint8_t aes_key_no, uint8_t file_no, uint8_t key_no, uint8_t curr_communication_mode,
                                                uint8_t new_communication_mode, uint8_t read_key_no, uint8_t write_key_no, uint8_t read_write_key_no, uint8_t change_key_no);

    /**
    * @brief Multi reader support. From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function delete transaction MAC file.
    * NOTE: Transaction MAC file exist by factory default. To use the operations with value file, and cyclic record file, this file must be deleted.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_ext pointer to array contained AES key aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number 15
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_delete_tmc_file_pkM(UFR_HANDLE hndUFR, IN uint8_t *aes_key_ext, uint8_t file_no);

    /**
    * @brief Multi reader support. From library version 5.0.29 and firmware version 5.0.32.  Desfire Light specific command.
    * Function delete transaction MAC file.
    * NOTE: Transaction MAC file exist by factory default. To use the operations with value file, and cyclic record file, this file must be deleted.
    * From library version 5.0.37 and firmware version 5.0.38, Transaction MAC operation supported for Desfire Light and Desfire EV2. To use these features, an Transaction MAC file must exist in the selected application.
    *
    * @ingroup Card_Tag_Mifare_Desfire_Light_M
    *
    * @param hndUFR handle of the uFR device
    * @param aes_key_no reader key number of AES key (0 - 15)
    * @param file_no file number 15
    *
    * @return Operation status
    */
    UFR_STATUS DL_API dfl_delete_tmc_fileM(UFR_HANDLE hndUFR, uint8_t aes_key_no, uint8_t file_no);

    /**
    * @brief Multi reader support. Function enables sending data to the uFR Online. A string of data contains information about the intensity of color in each cell of the LED indication. Each cell has three LEDs (red, green and blue). For each cell of the three bytes is necessary. The first byte indicates the intensity of the green color, the second byte indicates the intensity of the red color, and the third byte indicates the intensity of blue color. For example, if the display has 2 cells, an array contains 6 bytes. Value of intensity is in the range from 0 to 255. On uFR Online, there are 2 cells.From firmware version 2.7.6, RGB LEDs can be connected to pin 5 of P5 connector (GPIO connector - ESP pin 18). First 6 bytes in display_data array will be sent to internal RGB LEDs, additional bytes will be sent to external connected RGB. There is no limit for number of external cells.
    * Array data example: 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    * First 6 bytes will be sent to internal RGB and additional 3 bytes will be sent to first cell of external RGB.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param display_data pointer to data array
    * @param data_length number of bytes into array
    * @param duration number of milliseconds to light. if value is 0, then rgb will light infinitely
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetDisplayDataM(UFR_HANDLE hndUFR, uint8_t *display_data, uint8_t data_length, uint16_t duration);

    /**
    * @brief Multi reader support. Physical reset of uFR reader communication port.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspReaderResetM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. It defines/changes password which I used for:
    * * Writing in EEPROM
    * * Setting date/time of RTC
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param old_password pointer to the 8 bytes array containing current password
    * @param new_password pointer to the 8 bytes array containing new password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspChangeReaderPasswordM(UFR_HANDLE hndUFR, uint8_t *old_password, uint8_t *new_password);

    /**
    * @brief Multi reader support. Function writes array of data into EEPROM of uFR Online. Maximal length of the array is 128 bytes. Function requires a password which is 8 bytes. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param data pointer to  array containing data from EEPROM
    * @param address address of first data
    * @param size length of array
    * @param password pointer to array containing password
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspReaderEepromWriteM(UFR_HANDLE hndUFR, uint8_t *data, uint32_t address, uint32_t size, uint8_t *password);

    /**
    * @brief Multi reader support. Function returns array of data read from EEPROM of uFR Online. Maximal length of the array is 128 bytes.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param data pointer to  array containing data from EEPROM
    * @param address address of first data
    * @param size length of array
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspReaderEepromReadM(UFR_HANDLE hndUFR, uint8_t *data, uint32_t address, uint32_t size);

    /**
    * @brief Multi reader support. Function returns 6 bytes array of uint8_t that represents current date and time into uFR Online RTC.
    * * Byte 0 represent year (current year - 2000)
    * * Byte 1 represent month (1 - 12)
    * * Byte 2 represent day of the month (1 - 31)
    * * Byte 3 represent hour (0 - 23)
    * * Byte 4 represent minute (0 - 59)
    * * Byte 5 represent second (0 - 59)
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param time pointer to the 6 bytes array containing date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetReaderTimeM(UFR_HANDLE hndUFR, uint8_t *time);

    /**
    * @brief Multi reader support. Function sets the date and time into uFR Online RTC. Function requires the 8 bytes password entry to set  date and time. Date and time are represented into a 6 bytes array in the same way as in EspGetReaderTime function. Factory password is “11111111” (0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31).
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param password pointer to the 8 bytes array containing password
    * @param time pointer to the 6 bytes array containing date and time representation
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetReaderTimeM(UFR_HANDLE hndUFR, uint8_t *password, uint8_t *time);

    /**
    * @brief Multi reader support. Function sets uFR Online IO pin state.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param pin IO pin number (1 - 6)
    * @param state IO pin state 0 - low level, 1 - high level, 2 - input
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetIOStateM(UFR_HANDLE hndUFR, uint8_t pin, uint8_t state);

    /**
    * @brief Multi reader support. Function returns 6 bytes array of uint8_t that represented IO pins logic level state.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param state pointer to the 6 bytes array containing IO pins states
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetIOStateM(UFR_HANDLE hndUFR, uint8_t *state);

    /**
    * @brief Multi reader support. Function sets uFR Online transparent reader.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param reader Transparent reader number
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspSetTransparentReaderM(UFR_HANDLE hndUFR, uint8_t reader);

    /**
    * @brief Multi reader support. Returns uFR Online reader serial number as a pointer to 4 byte value.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands_M
    *
    * @param hndUFR handle of the uFR device
    * @param lpulSerialNumber pointer to lpulSerialNumber variable. “lpulSerialNumber “ as result holds 4 byte serial number value.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetReaderSerialNumberM(UFR_HANDLE hndUFR, uint32_t *lpulSerialNumber);

    /**
    * @brief Multi reader support. Returns uFR Online reader firmware version.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    *
    * @param major Major firmware version
    * @param minor Minor firmware version
    * @param build Build firmware version
    *
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetFirmwareVersionM(UFR_HANDLE hndUFR, OUT uint8_t *major, OUT uint8_t *minor, OUT uint8_t *build);

    /**
    * @brief Multi reader support. Turn off uFR Online device.
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspTurnOffM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. This option is only avaliable in BT/BLE mode. Disable Wifi on uFR Online device when working in BLE/BT mode. This option is saved in flash and Wifi will stay turned off device restart. 
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspDisableWifiM(UFR_HANDLE hndUFR);

    /**
    * @brief Multi reader support. This option is only avaliable in BT/BLE mode. Enable Wifi on uFR Online device when working in BLE/BT mode. This option is saved in flash and Wifi will stay turned on device restart. 
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspEnableOnWifiM(UFR_HANDLE hndUFR);

/**
    * @brief uFR Zero Online get firmware list from server for connected device
    *
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @param option Option for setting uFR Zero Online main device or NFC part
    * @param current_version Returns current version of installed firmware. In case there is not firmware, it will return 0.0.0
    * @param versions Returns list of firmware versions and descriptions as string. Memory must be already allocated in main program. It must be two dimensional array
    * @param versions_size versions array size. This is maximum number of elements in array
    * @param returned_versions_size Returns how many elements are populated in array. This will be same as number of avaliable firmwares
    * 
    * @return Operation status
    */
    UFR_STATUS DL_API EspGetFirmwaresListM(UFR_HANDLE hndUFR, READER_FLASH_OPTION option, char *current_version, char **versions, int versions_size, int *returned_versions_size);

    /**
    * @brief uFR Zero Online start firmware update
    * @ingroup ReaderAndLibrary_uFROnlineCommands
    * 
    * @param option Option for setting uFR Zero Online main device or NFC part
    * @param current_version Provide version to be updated. In must be in x.x.x or x.x.x - description
    * @param token Provide token in case of premium firmwares. It can be empty.
    * @param callback Pointer to update progress callback function
    * @param arg Optional argument that will be provided to callback function
    * 
    * @return Operation status. In case of UFR_AUTH_ERROR token must be provided
    */
    UFR_STATUS DL_API EspUpdateFirmwareM(UFR_HANDLE hndUFR, READER_FLASH_OPTION option, const char *version, const char *token, UpdateProgressCallback callback, void *arg);    

    /**
    * @brief Multi reader support. As of uFCoder library v5.0.71 users can use COM protocol via uFCoder library by calling this method. It handles transmission of CMD and CMD_EXT commands and it handles RSP and RSP_EXT packets that are a response to the COM protocol commands.
    *
    * @ingroup Card_Tag_General_M
    *
    * @param hndUFR handle of the uFR device
    * @param cmd Pointer to array of CMD bytes for transmission. Last byte is the checksum.
    * @param cmd_length Length of the CMD array, always set it to 7.
    * @param cmd_ext Pointer to array of CMD_EXT bytes for transmission. Last byte is the checksum.
    * @param cmd_ext_length If the length is greater than 0, CMD_EXT bytes will be transmitted. Otherwise they will not. This is the size of CMD_EXT array that will be sent to the reader.
    * @param rsp Pointer to array of bytes containing RSP bytes.
    * @param rsp_length Pointer to a variable holding how many RSP bytes have been received.
    * @param rsp_ext Pointer to array of bytes containing RSP bytes. If greater than zero, RSP_EXT exists.
    * @param rsp_ext_length Pointer to a variable holding how many RSP_EXT byte have been received.
    *
    * @return Operation status
    */
   
    UFR_STATUS DL_API COMTransceiveM(UFR_HANDLE hndUFR, IN uint8_t *cmd, uint32_t cmd_length, IN uint8_t *cmd_ext, uint32_t cmd_ext_length, OUT uint8_t *rsp, VAR uint32_t *rsp_length, OUT uint8_t *rsp_ext, VAR uint32_t *rsp_ext_length);

    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    /**
    * @brief As of uFCoder library v5.0.71 users can use COM protocol via uFCoder library by calling this method. It handles transmission of CMD and CMD_EXT commands and it handles RSP and RSP_EXT packets that are a response to the COM protocol commands.
    *
    * @ingroup Card_Tag_General
    *
    * @param cmd Pointer to array of CMD bytes for transmission. Last byte is the checksum.
    * @param cmd_length Length of the CMD array, always set it to 7.
    * @param cmd_ext Pointer to array of CMD_EXT bytes for transmission. Last byte is the checksum.
    * @param cmd_ext_length If the length is greater than 0, CMD_EXT bytes will be transmitted. Otherwise they will not. This is the size of CMD_EXT array that will be sent to the reader.
    * @param rsp Pointer to array of bytes containing RSP bytes.
    * @param rsp_length Pointer to a variable holding how many RSP bytes have been received.
    * @param rsp_ext Pointer to array of bytes containing RSP bytes. If greater than zero, RSP_EXT exists.
    * @param rsp_ext_length Pointer to a variable holding how many RSP_EXT byte have been received.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API COMTransceive(IN uint8_t *cmd, uint32_t cmd_length, IN uint8_t *cmd_ext, uint32_t cmd_ext_length, OUT uint8_t *rsp, VAR uint32_t *rsp_length, OUT uint8_t *rsp_ext, VAR uint32_t *rsp_ext_length);
    // DLL version ----------------------------------------------------------------
    /**
    * @brief This function returns library version as string.
    *
    * @ingroup ReaderAndLibrary_HelperFunc
    *
    * @return Operation status
    */
    uint32_t DL_API GetDllVersion(void);

    /*
    * Get "exploded" dll version example:
    *
    *  #include <windows.h>
    *  #include <uFCoder.h>
    *
    *  void main(int argc, char *argv[])
    *  {
    *       uint32_t dwDllVersion = 0;
    *       uint32_t dwDllMajorVersion = 0;
    *       uint32_t dwDllMinorVersion = 0;
    *       uint32_t dwDllBuild = 0;
    *
    *       dwDllVersion = GetDllVersion();
    *
    *       // "explode" the dll version:
    *       dwDllMajorVersion = (DWORD)(LOBYTE(LOWORD(dwDllVersion)));
    *       dwDllMinorVersion = (DWORD)(HIBYTE(LOWORD(dwDllVersion)));
    *
    *       // Get the dll build number.
    *       dwDllBuild = (DWORD)(HIWORD(dwDllVersion));
    *
    *       printf("Dll version is %ld.%ld (%ld)\n", dwDllMajorVersion,
    *                                             dwDllMinorVersion,
    *                                             dwDllBuild);
    *  }
    *
    */
    // Originality Check (performs the check is the chip on the card/tag NXP genuine):
    /**
    * @brief This function depends on OpenSSL crypto library. Since OpenSSL crypto library is dynamically linked during execution, the only prerequisite for a successful call to this function is that the libeay32.dll is in the current folder (valid for Windows) and / or libcrypto.so is in the environment path (e.g. LD_LIBRARY_PATH on Linux / macOS). OriginalityCheck() performs the check if the chip on the card / tag is NXP genuine.
    *
    * @ingroup Card_Tag_CardFeatures_OriginalityChecking
    *
    * @param signature ECCSignature acquired by call to the ReadECCSignature() function.
    * @param uid Card UID. Best if the card UID is acquired by previous call to the ReadECCSignature() function.
    * @param uid_len Card UID length. Best if the card UID length is acquired by previous call to the ReadECCSignature() function.
    * @param DlogicCardType Card type. Best if the DlogicCardType is acquired by previous call to the ReadECCSignature() function.
    *
    * @return Operation status
    */
    UFR_STATUS DL_API OriginalityCheck(IN const uint8_t *signature, IN const uint8_t *uid, uint8_t uid_len, uint8_t DlogicCardType);
    // Returns:
    // UFR_OPEN_SSL_DYNAMIC_LIB_NOT_FOUND in case there is no OpenSSL library (libeay32.dll) in current folder or path
    // UFR_OPEN_SSL_DYNAMIC_LIB_FAILED    in case of OpenSSL library error (e.g. wrong OpenSSL version)
    // UFR_NOT_NXP_GENUINE                if chip on the card/tag is NOT NXP genuine
    // UFR_OK                             is chip on the card/tag is NXP GENUINE

    //// debug functions:
    /**
    * @brief This function returns library version as string.
    *
    * @ingroup ReaderAndLibrary_HelperFunc
    *
    * @return Operation status
    */
    c_string DL_API GetDllVersionStr(void);

    /**
    * @brief Returns UFR_STATUS error code as a c_string
    *
    * @ingroup ReaderAndLibrary_HelperFunc
    *
    * @param status UFR_STATUS status variable
    *
    * @return Operation status
    */
    c_string DL_API UFR_Status2String(const UFR_STATUS status);
    
    /**
    * @brief Returns UFR_SESSION_STATUS error code as a c_string
    *
    * @ingroup ReaderAndLibrary_HelperFunc
    *
    * @param session_status UFR_SESSION_STATUS status variable
    *
    * @return c_string value of the status code
    */
    c_string DL_API UFR_SessionStatus2String(const UFR_SESSION_STATUS session_status);

    /**
    * @brief Returns card type as a c_string instead of byte value
    *
    * @ingroup ReaderAndLibrary_HelperFunc
    *
    * @param dl_type_code card type value based on DLogic CardType enumeration
    *
    * @return Operation status
    */
    c_string DL_API UFR_DLCardType2String(uint8_t dl_type_code);

//// Helper functions:
#ifndef _WIN32

    unsigned long GetTickCount(void);

#endif // #ifndef _WIN32

    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    /**
    * @brief This function returns the reader's descriptive name. Return type is string. No parameters required.
    *
    * @ingroup ReaderAndLibrary_Information
    *
    * @return The reader's descriptive name
    */
    c_string DL_API GetReaderDescription(void);

    /**
    * @brief Multi reader support. This function returns the reader's descriptive name. Return type is string. No parameters required.
    *
    * @ingroup ReaderAndLibrary_Information_M
    *
    * @param hndUFR handle of the uFR device
    *
    * @return Teturns the reader's descriptive name.
    */
    c_string DL_API GetReaderDescriptionM(UFR_HANDLE hndUFR);

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#ifdef __ANDROID__
#include <jni.h>

    extern JNIEnv *global_env;
    extern jclass global_class;
    extern jclass usb_global_class;

    /**

    *
    * @param env
    * @param class1
    *
    * @return Operation status
    */
    void DL_API initVM(JNIEnv *env, jclass class1);
#endif

#ifdef __cplusplus
}
#endif

#ifdef __APPLE__
#include <TargetConditionals.h>
#if TARGET_OS_IPHONE
    void setNFCMessage(const char *message);

    typedef void (*CardDetectedCallback)(void* _Nonnull context,const char *uid, const char* dl_card_type, const char* manufacturer);
    typedef void (*CardRemovedCallback)(void* _Nonnull context);
    typedef void (*SessionErrorCallback)(void* _Nonnull context, UFR_SESSION_STATUS error_code, const char* error_description);

    void setCardDetectedCallback(CardDetectedCallback callback);
    void setCardRemovedCallback(CardRemovedCallback callback);
    void setSessionErrorCallback(SessionErrorCallback callback);

    UFR_STATUS DL_API openBLESession(void* _Nonnull context, const char* reader_sn, int timeout, CardDetectedCallback card_detected_callback, CardRemovedCallback card_removed_callback, SessionErrorCallback error_callback);
    void closeBLESession(void);

    UFR_STATUS DL_API openNFCSession(void* _Nonnull context, int timeout, CardDetectedCallback card_detected_callback, CardRemovedCallback card_removed_callback, SessionErrorCallback error_callback, const char* license_json);
    void closeNFCSession(void);

#endif
#endif



#endif /* uFCoder_H_ */
